diff --git a/Documentation/devicetree/bindings/clock/silabs,si5338.txt b/Documentation/devicetree/bindings/clock/silabs,si5338.txt
new file mode 100644
index 0000000..4c90c43
--- /dev/null
+++ b/Documentation/devicetree/bindings/clock/silabs,si5338.txt
@@ -0,0 +1,197 @@
+Binding for Silicon Labs Si5338 programmable i2c clock generator.
+
+Reference
+[1] Si5338 Data Sheet
+    http://www.silabs.com/Support%20Documents/TechnicalDocs/Si5338.pdf
+
+The Si5338 is a programmable i2c clock generators with up to 4 output
+clocks. It has 4 sets of possible input clocks
+
+IN1/IN2: differential
+IN3: single-ended
+IN4: single-ended
+IN5/IN6: differential
+
+Additionally, IN1/IN2 can be used as XTAL with different setting.
+The clock tree looks like below (without support of zero-delay)
+
+
+ XTAL IN1/IN2 IN3         IN4 IN5/IN6
+   |     |     |           |     |
+   |     |     |           |     |
+  OSC    |     |           |     |
+   |     \     /           \     /
+   \      \   /             \   /
+    \      \ /               \ /
+     \--- REFCLK            FBCLK
+           |  \             /   |
+           |   \           /    |
+           | DIVREFCLK DIVFBCLK |
+           |     \       /      |
+           |      \     /       |
+           |       \   /        |
+           |        PLL         |
+           |      / | | \       |
+           |     /  / \  \      |
+           |    /  /   \  \     |
+           |   /   |   |   \    |
+           |   |   |   |   |    |
+           |  MS0 MS1 MS2 MS3   |
+           |   |   |   |   |    |
+
+            OUT0 OUT1 OUT2 OUT3
+
+The output clock can choose from any of the above clock as its source, with
+exceptions: MS1 can only be used for OUT1, MS2 can only be used for OUT2, MS3
+can only be used for OUT3.
+
+==I2C device node==
+
+Required properties:
+- compatible: shall be "silabs,si5338".
+- reg: i2c device address, shall be 0x60, 0x61, 0x70, or 0x71
+- #clock-cells: shall be set to 1 for multiple outputs
+- clocks: list of parent clocks in the order of <xtal>, <in1/2>, <in3>, <in4>,
+	 <in5/6>.
+	Note, xtal and in1/2 are mutually exclusive. Only one can be set.
+- clock-names: The name of the clocks in the same order.
+- #address-cells: shall be set to 1.
+- #size-cells: shall be set to 0.
+- silabs,pll-master: If PLL is used, pick one MS (0, 1, 2, or 3) to allow
+	chaning PLL rate. This is arbitrary since MS0/1/2/3 share one PLL.
+	PLL can be calculated backward to satisfy MS. This node is not
+	required if PLL is not used, or if silabs,pll-vco is set.
+
+Optional properties if not set by platform driver:
+- silabs,name-prefix: name prefix for si5338
+        If multiple si5338 chips exist, use name-prefix to form unique names.
+	If omitted, i2c bus name will be used as the prefix.
+- silabs,ref-source: source of refclk, valid value is defined as
+	#define SI5338_REF_SRC_CLKIN12          0
+	#define SI5338_REF_SRC_CLKIN3           1
+	#define SI5338_REF_SRC_XTAL             4
+- silabs,fb-source:  source of fbclk, valid value is defined as
+	#define SI5338_FB_SRC_CLKIN4            2
+	#define SI5338_FB_SRC_CLKIN56           3
+	#define SI5338_FB_SRC_NOCLK             5
+- silabs,pll-source: source of pll, valid value is defined as
+	#define SI5338_PFD_IN_REF_REFCLK           0
+	#define SI5338_PFD_IN_REF_FBCLK            1
+	#define SI5338_PFD_IN_REF_DIVREFCLK        2
+	#define SI5338_PFD_IN_REF_DIVFBCLK         3
+	#define SI5338_PFD_IN_REF_XOCLK            4
+	#define SI5338_PFD_IN_REF_NOCLK            5
+- silabs,pll-vco: Specify VCO frequency for optimal ratios for all outputs.
+	If specified, silabs,pll-master is ignored.
+
+==Child nodes==
+
+Each of the clock outputs can be configured individually by
+using a child node to the I2C device node. If a child node for a clock
+output is not set, platform driver has to set up.
+
+Required child node properties:
+- name: name for the child node
+        It has to be unique. The name prefix is ignored.
+	If using platform data and the name is not specificed,
+        clkout0/1/2/3 will be used with name prefix.
+- reg: number of clock output.
+
+Optional child node properties:
+- silabs,drive-config: the configuration of output driver
+  The valid value list is long. Please refer to soruce code.
+- silabs,clock-source: source clock of the output divider
+	#define SI5338_OUT_MUX_FBCLK            0
+	#define SI5338_OUT_MUX_REFCLK           1
+	#define SI5338_OUT_MUX_DIVFBCLK         2
+	#define SI5338_OUT_MUX_DIVREFCLK        3
+	#define SI5338_OUT_MUX_XOCLK            4
+	#define SI5338_OUT_MUX_MS0              5
+	#define SI5338_OUT_MUX_MSN              6 /* MS0/1/2/3 */
+	#define SI5338_OUT_MUX_NOCLK            7
+- silabs,disable-state : clock output disable state, shall be
+	#define SI5338_OUT_DIS_HIZ              0
+	#define SI5338_OUT_DIS_LOW              1
+	#define SI5338_OUT_DIS_HI               2
+	#define SI5338_OUT_DIS_ALWAYS_ON        3
+- enabled: the output is enabled by default
+	The existence of this node enables the output when the driver is loaded
+	otherwise the clock is only enabled when used
+
+==Example==
+
+/* 25MHz reference crystal */
+ref25: ref25M {
+	compatible = "fixed-clock";
+	#clock-cells = <0>;
+	clock-frequency = <25000000>;
+};
+clkin56: ref100M {
+	compatible = "fixed-clock";
+	#clock-cells = <0>;
+	clock-frequency = <100000000>;
+};
+i2c-master-node {
+	si5338: clock-generator@70 {
+		compatible = "silabs,si5338";
+		reg = <0x70>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		#clock-cells = <1>;
+
+		/* connect xtal to 25MHz, in5/in6 to 100MHz */
+		clocks = <&ref25>, <0>, <0>, <0>, <&clkin56>;
+		clock-names = "xtal", "in12", "in3", "in4", "in56";
+
+		/* connect xtal as source of refclk */
+		silabs,ref-source = <SI5338_REF_SRC_XTAL>;
+
+		/* connect in5/in6 as source of fbclk */
+		silabs,fb-source = <SI5338_FB_SRC_CLKIN56>;
+
+		/* connect divrefclk as source of pll */
+		//silabs,pll-source = <SI5338_PFD_IN_REF_XOCLK>;
+		silabs,pll-source = <SI5338_PFD_IN_REF_DIVREFCLK>;
+
+		/* Choose one MS for pll master */
+		silabs,pll-master = <0>;
+
+		/* Specify pll-vco frequency. pll-master is ignored. */
+		//silabs,pll-vco = <2500000000>;
+		silabs,pll-vco = <2450000000>;
+
+		/* output */
+		clkout0 {
+			reg = <0>;
+			silabs,drive-config = "1V8_LVDS";
+			silabs,clock-source = <SI5338_OUT_MUX_MS0>;
+			silabs,disable-state = <SI5338_OUT_DIS_HIZ>;
+			clock-frequency = <125000000>;
+			//enabled;
+		};
+		clkout1 {
+			reg = <1>;
+			silabs,drive-config = "1V8_LVDS";
+			silabs,clock-source = <SI5338_OUT_MUX_MSN>;
+			silabs,disable-state = <SI5338_OUT_DIS_HIZ>;
+			clock-frequency = <125000000>;
+			//enabled;
+		};
+		clkout2 {
+			reg = <2>;
+			silabs,drive-config = "1V8_LVDS";
+			silabs,clock-source = <SI5338_OUT_MUX_MSN>;
+			silabs,disable-state = <SI5338_OUT_DIS_HIZ>;
+			clock-frequency = <125000000>;
+		};
+		clkout3 {
+			reg = <3>;
+			silabs,drive-config = "1V8_LVDS";
+			silabs,clock-source = <SI5338_OUT_MUX_MSN>;
+			silabs,disable-state = <SI5338_OUT_DIS_HIZ>;
+			clock-frequency = <125000000>;
+			//enabled;
+		};
+
+	};
+};
diff --git a/Documentation/devicetree/bindings/net/altera_tse.txt b/Documentation/devicetree/bindings/net/altera_tse.txt
index a706297..fbb8b2b 100644
--- a/Documentation/devicetree/bindings/net/altera_tse.txt
+++ b/Documentation/devicetree/bindings/net/altera_tse.txt
@@ -40,11 +40,7 @@ Required properties:
 	- #address-cells: Must be <1>.
 	- #size-cells: Must be <0>.
 
-	For each phy on the mdio bus, there must be a node with the following
-	fields:
-
-	- reg: phy id used to communicate to phy.
-	- device_type: Must be "ethernet-phy".
+	For each phy on the mdio bus, see phy.txt
 
 Optional properties:
 - local-mac-address: See ethernet.txt in the same directory.
@@ -52,7 +48,7 @@ Optional properties:
 
 Example:
 
-	tse_sub_0_eth_tse_0: ethernet@0x1,00000000 {
+	tse_sub_0_eth_tse_0: ethernet@1,00000000 {
 		compatible = "altr,tse-msgdma-1.0";
 		reg =	<0x00000001 0x00000000 0x00000400>,
 			<0x00000001 0x00000460 0x00000020>,
@@ -79,18 +75,18 @@ Example:
 			#size-cells = <0>;
 			phy0: ethernet-phy@0 {
 				reg = <0x0>;
-				device_type = "ethernet-phy";
+				compatible = "ethernet-phy-ieee802.3-c22";
 			};
 
 			phy1: ethernet-phy@1 {
 				reg = <0x1>;
-				device_type = "ethernet-phy";
+				compatible = "ethernet-phy-ieee802.3-c22";
 			};
 
 		};
 	};
 
-	tse_sub_1_eth_tse_0: ethernet@0x1,00001000 {
+	tse_sub_1_eth_tse_0: ethernet@1,00001000 {
 		compatible = "altr,tse-msgdma-1.0";
 		reg = 	<0x00000001 0x00001000 0x00000400>,
 			<0x00000001 0x00001460 0x00000020>,
diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile
index 43eafd4..b34a477 100644
--- a/arch/arm/boot/dts/Makefile
+++ b/arch/arm/boot/dts/Makefile
@@ -697,6 +697,8 @@ dtb-$(CONFIG_ARCH_SOCFPGA) += \
 	socfpga_arria10_socdk_nand.dtb \
 	socfpga_arria10_socdk_qspi.dtb \
 	socfpga_arria10_socdk_sdmmc.dtb \
+	facc-a10ad9371x2.dtb \
+	facc-a10ad9371x4dma.dtb \
 	socfpga_arria10_swvp.dtb \
 	socfpga_cyclone5_mcvevk.dtb \
 	socfpga_cyclone5_socdk.dtb \
diff --git a/arch/arm/boot/dts/eth_altr_tse.dtsi b/arch/arm/boot/dts/eth_altr_tse.dtsi
new file mode 100644
index 0000000..d71a9d5
--- /dev/null
+++ b/arch/arm/boot/dts/eth_altr_tse.dtsi
@@ -0,0 +1,62 @@
+/* Documentation/devicetree/bindings/net/altera_tse.txt */
+/* Documentation/devicetree/bindings/interrupt-controller/arm,gic.txt */
+
+/ {
+soc {
+	gemac_tse: ethernet@ff2c0000 {
+		compatible = "altr,tse-msgdma-1.0";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		reg = <0xff2c0000 0x00000400>,
+			<0xff2c0460 0x00000020>,
+			<0xff2c0480 0x00000020>,
+			<0xff2c04A0 0x00000008>,
+			<0xff2c0400 0x00000020>,
+			<0xff2c0420 0x00000020>;
+		reg-names = "control_port", "rx_csr", "rx_desc", "rx_resp", "tx_csr", "tx_desc";
+		interrupt-parent = <&intc>;
+		interrupts = <0 81 IRQ_TYPE_LEVEL_HIGH>, <0 80 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "rx_irq", "tx_irq";
+		tx-fifo-depth = <2048>; //<8192>;
+		rx-fifo-depth = <2048>; //<32768>;
+		/* copy from stmmac but unused here
+		clocks = <&sys_clk>;
+		clock-names = "gemac_tse_clk";
+		resets = <&rst EMAC0_RESET>;
+		reset-names = "gemac_tse_rst";*/
+		address-bits = <48>;
+		max-frame-size = <1500>;
+		local-mac-address = [ 00 00 00 00 00 00 ];
+		phy-mode = "sgmii";
+		altr,has-supplementary-unicast;
+		altr,has-hash-multicast-filter;
+		/* mdio-bus[0] + phy[0]/pcs;
+		   unused for now as current driver support one mdio only!
+		pcs-mdio = <0>;
+		mdio0: mdio@0 {
+			compatible = "altr,tse-mdio";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			sgmii_pcs: sgmii-pcs@0 {
+				reg = <0x0>;
+				device_type = "sgmii-pcs";
+				//compatible = "altr-pcs";
+			};
+		};*/
+		phy-handle = <&tse_mdio1_phy0>;
+		//phy-addr = <0>; /* -1 for auto-probing, to be debugged */
+		mdio1: mdio@1 {
+			compatible = "altr,tse-mdio";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			/* #define MARVELL_PHY_ID_88E1111 0x01410cc0 */
+			tse_mdio1_phy0: ethernet-phy@0 {
+				reg = <0x0>;
+				compatible = "ethernet-phy-id0141.0cc0", "ethernet-phy-ieee802.3-c22";
+				//interrupt-parent = <40000>;
+				//interrupts = <35 1>;
+			};
+		};
+	};
+};
+};
diff --git a/arch/arm/boot/dts/facc-a10ad9371n1.dtsi b/arch/arm/boot/dts/facc-a10ad9371n1.dtsi
new file mode 100644
index 0000000..e209d52
--- /dev/null
+++ b/arch/arm/boot/dts/facc-a10ad9371n1.dtsi
@@ -0,0 +1,330 @@
+
+&sys_hps_bridges {
+	axi_ad9371_tx_jesd: axi-jesd204-tx@20000 {
+		compatible = "adi,axi-jesd204-tx-1.0";
+		reg = <0x00020000 0x4000>;
+
+		interrupt-parent = <&intc>;
+		interrupts = <0 28 IRQ_TYPE_NONE>;
+
+		clocks = <&sys_clk>, <&tx_device_clk_pll>, <&axi_ad9371_tx_xcvr>;
+		clock-names = "s_axi_aclk", "device_clk", "lane_clk";
+
+		adi,octets-per-frame = <2>;
+		adi,frames-per-multiframe = <32>;
+		adi,converter-resolution = <14>;
+		adi,bits-per-sample = <16>;
+		adi,converters-per-device = <4>;
+		adi,control-bits-per-sample = <2>;
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd_tx_lane_clk";
+	};
+
+	axi_ad9371_rx_jesd: axi-jesd204-rx@30000 {
+		compatible = "adi,axi-jesd204-rx-1.0";
+		reg = <0x00030000 0x4000>;
+
+		interrupt-parent = <&intc>;
+		interrupts = <0 27 IRQ_TYPE_NONE>;
+
+		clocks = <&sys_clk>, <&rx_device_clk_pll>, <&axi_ad9371_rx_xcvr>;
+		clock-names = "s_axi_aclk", "device_clk", "lane_clk";
+
+		adi,octets-per-frame = <4>;
+		adi,frames-per-multiframe = <32>;
+		adi,converter-resolution = <16>;
+		adi,bits-per-sample = <16>;
+		adi,converters-per-device = <4>;
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd_rx_lane_clk";
+	};
+
+	axi_ad9371_rx_os_jesd: axi-jesd204-rx@40000 {
+		compatible = "adi,axi-jesd204-rx-1.0";
+		reg = <0x00040000 0x4000>;
+
+		interrupt-parent = <&intc>;
+		interrupts = <0 29 IRQ_TYPE_NONE>;
+
+		clocks = <&sys_clk>, <&rx_os_device_clk_pll>, <&axi_ad9371_rx_os_xcvr>;
+		clock-names = "s_axi_aclk", "device_clk", "lane_clk";
+
+		adi,octets-per-frame = <2>;
+		adi,frames-per-multiframe = <32>;
+		adi,converter-resolution = <16>;
+		adi,bits-per-sample = <16>;
+		adi,converters-per-device = <4>;
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd_rx_os_lane_clk";
+	};
+
+	axi_ad9371_tx_xcvr: axi-ad9371-tx-xcvr@24000 {
+		compatible = "adi,altera-adxcvr-1.00.a";
+		reg = <0x00024000 0x00001000>,
+			<0x00026000 0x00001000>,
+			<0x00028000 0x00001000>,
+			<0x00029000 0x00001000>,
+			<0x0002a000 0x00001000>,
+			<0x0002b000 0x00001000>;
+		reg-names = "adxcvr", "atx-pll", "adxcfg-0", "adxcfg-1", "adxcfg-2", "adxcfg-3";
+
+		clocks = <&clk0_ad9528 3>, <&tx_device_clk_pll>;
+		clock-names = "ref", "link";
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd204_tx_lane_clock";
+	};
+
+	axi_ad9371_rx_xcvr: axi-ad9371-rx-xcvr@34000 {
+		compatible = "adi,altera-adxcvr-1.00.a";
+		reg = <0x00034000 0x00001000>,
+			<0x00038000 0x00001000>,
+			<0x00039000 0x00001000>;
+		reg-names = "adxcvr", "adxcfg-0", "adxcfg-1";
+
+		clocks = <&clk0_ad9528 3>, <&rx_device_clk_pll>;
+		clock-names = "ref", "link";
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd204_rx_lane_clock";
+	};
+
+	axi_ad9371_rx_os_xcvr: axi-ad9371-rx-os-xcvr@44000 {
+		compatible = "adi,altera-adxcvr-1.00.a";
+		reg = <0x00044000 0x00001000>,
+			<0x00048000 0x00001000>,
+			<0x00049000 0x00001000>;
+		reg-names = "adxcvr", "adxcfg-0", "adxcfg-1";
+
+		clocks = <&clk0_ad9528 3>, <&rx_os_device_clk_pll>;
+		clock-names = "ref", "link";
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd204_rx_os_lane_clock";
+	};
+
+	axi_ad9371_tx_dma: axi-ad9371-tx-dma@2c000 {
+		compatible = "adi,axi-dmac-1.00.a";
+		reg = <0x0002c000 0x00004000>;
+		interrupt-parent = <&intc>;
+		interrupts = <0 30 IRQ_TYPE_LEVEL_HIGH>;
+		#dma-cells = <1>;
+		clocks = <&dma_clk>;
+
+		dma-channel {
+			adi,source-bus-width = <128>;
+			adi,destination-bus-width = <128>;
+			adi,type = <1>;
+			//adi,cyclic;
+		};
+	};
+
+	axi_ad9371_rx_dma: axi-ad9371-rx-dma@3c000 {
+		compatible = "adi,axi-dmac-1.00.a";
+		reg = <0x0003c000 0x00004000>;
+		interrupt-parent = <&intc>;
+		interrupts = <0 31 IRQ_TYPE_LEVEL_HIGH>;
+		#dma-cells = <1>;
+		clocks = <&dma_clk>;
+
+		dma-channel {
+			adi,source-bus-width = <64>;
+			adi,destination-bus-width = <128>;
+			adi,type = <0>;
+		};
+	};
+
+	axi_ad9371_rx_os_dma: axi-ad9371-rx-os-dma@4c000 {
+		compatible = "adi,axi-dmac-1.00.a";
+		reg = <0x0004c000 0x00004000>;
+		interrupt-parent = <&intc>;
+		interrupts = <0 32 IRQ_TYPE_LEVEL_HIGH>;
+		#dma-cells = <1>;
+		clocks = <&dma_clk>;
+
+		dma-channel {
+			adi,source-bus-width = <64>;
+			adi,destination-bus-width = <128>;
+			adi,type = <0>;
+		};
+	};
+
+	axi_ad9371_rx: axi-ad9371-rx-hpc@50000 {
+		compatible = "adi,axi-ad9371-rx-1.0";
+		reg = <0x00050000 0x00008000>;
+		dmas = <&axi_ad9371_rx_dma 0>;
+		dma-names = "rx";
+		spibus-connected = <&trx0_ad9371>;
+	};
+
+	axi_ad9371_tx: axi-ad9371-tx-hpc@54000 {
+		compatible = "adi,axi-ad9371-tx-1.0";
+		reg = <0x00054000 0x00004000>;
+		dmas = <&axi_ad9371_tx_dma 0>;
+		dma-names = "tx";
+		clocks = <&trx0_ad9371 2>;
+		clock-names = "sampl_clk";
+		spibus-connected = <&trx0_ad9371>;
+		//adi,axi-pl-fifo-enable;/* RxDMA fifo mode */
+		adi,axi-pl-fifo-disable;
+	};
+
+	xcvr_rx_os_core: axi-ad9371-rx-obs-hpc@58000 {
+		compatible = "adi,axi-ad9371-obs-1.0";
+		reg = <0x00058000 0x00001000>;
+		dmas = <&axi_ad9371_rx_os_dma 0>;
+		dma-names = "rx";
+		clocks = <&trx0_ad9371 1>;
+		clock-names = "sampl_clk";
+	};
+
+	tx_device_clk_pll: a10-fpll-tx@25000 {
+		compatible = "altr,a10-fpll";
+		reg = <0x00025000 0x1000>;
+		clocks = <&clk0_ad9528 3>;
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd204_tx_link_clock";
+	};
+
+	rx_device_clk_pll: a10-fpll-rx@35000 {
+		compatible = "altr,a10-fpll";
+		reg = <0x00035000 0x1000>;
+		clocks = <&clk0_ad9528 3>;
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd204_rx_link_clock";
+	};
+
+	rx_os_device_clk_pll: a10-fpll-rx-os@45000 {
+		compatible = "altr,a10-fpll";
+		reg = <0x00045000 0x1000>;
+		clocks = <&clk0_ad9528 3>;
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd204_rx_os_link_clock";
+	};
+};
+
+&fmc_spi {
+	trx0_ad9371: ad9371-phy@1 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		#clock-cells = <1>;
+		compatible = "ad9371";
+
+		/* SPI Setup */
+		reg = <1>;
+		spi-max-frequency = <25000000>;
+
+		reset-gpios = <&sys_gpio_out 20 0>;
+		test-gpios = <&sys_gpio_out 21 0>;
+		sysref_req-gpios = <&sys_gpio_out 26 0>;
+		rx2_enable-gpios = <&sys_gpio_out 22 0>;
+		rx1_enable-gpios = <&sys_gpio_out 23 0>;
+		tx2_enable-gpios = <&sys_gpio_out 24 0>;
+		tx1_enable-gpios = <&sys_gpio_out 25 0>;
+
+		/* all interrupts in HW design should be reviewed */
+		//interrupt-parent = <&intc>;
+		//interrupts = <0 31 IRQ_TYPE_LEVEL_HIGH>;
+
+		/* Clocks */
+		clocks = <&axi_ad9371_rx_jesd>, <&axi_ad9371_tx_jesd>,
+			<&axi_ad9371_rx_os_jesd>, <&clk0_ad9528 6>,
+			<&clk0_ad9528 3>;
+		clock-names = "jesd_rx_clk", "jesd_tx_clk",
+			"jesd_rx_os_clk", "dev_clk", "fmc_clk";
+		clock-output-names = "rx_sampl_clk", "rx_os_sampl_clk", "tx_sampl_clk";
+
+		adi,clocks-clk-pll-vco-freq_khz = <9830400>;
+		adi,clocks-device-clock_khz = <122880>;
+		adi,clocks-clk-pll-hs-div = <4>;
+		adi,clocks-clk-pll-vco-div = <2>;
+
+		adi,jesd204-obs-framer-over-sample = <0>;
+
+		adi,rx-profile-adc-div = <1>;
+		adi,rx-profile-en-high-rej-dec5 = <1>;
+		adi,rx-profile-iq-rate_khz = <122880>;
+		adi,rx-profile-rf-bandwidth_hz = <100000000>;
+		adi,rx-profile-rhb1-decimation = <1>;
+		adi,rx-profile-rx-bbf-3db-corner_khz = <100000>;
+		adi,rx-profile-rx-dec5-decimation = <5>;
+		adi,rx-profile-rx-fir-decimation = <2>;
+
+		adi,rx-profile-rx-fir-gain_db = <(-6)>;
+		adi,rx-profile-rx-fir-num-fir-coefs = <48>;
+		adi,rx-profile-rx-fir-coefs = /bits/ 16 <(-5) (-26) (32) (51) (-67) (-116) (140) (212) (-252) (-367) (429) (595) (-688) (-931) (1072) (1427) (-1650) (-2188) (2612) (3496) (-4802) (-7591) (9656) (32317) (32317) (9656) (-7591) (-4802) (3496) (2612) (-2188) (-1650) (1427) (1072) (-931) (-688) (595) (429) (-367) (-252) (212) (140) (-116) (-67) (51) (32) (-26) (-5)>;
+
+		adi,rx-profile-custom-adc-profile = /bits/ 16  <534 386 201 98 1280 491 1591 279 1306 104 792 28 48 39 23 187>;
+
+		adi,obs-profile-adc-div = <1>;
+		adi,obs-profile-en-high-rej-dec5 = <1>;
+		adi,obs-profile-iq-rate_khz = <245760>;
+		adi,obs-profile-rf-bandwidth_hz = <200000000>;
+		adi,obs-profile-rhb1-decimation = <1>;
+		adi,obs-profile-rx-bbf-3db-corner_khz = <100000>;
+		adi,obs-profile-rx-dec5-decimation = <5>;
+		adi,obs-profile-rx-fir-decimation = <1>;
+
+		adi,obs-profile-rx-fir-gain_db = <6>;
+		adi,obs-profile-rx-fir-num-fir-coefs = <24>;
+		adi,obs-profile-rx-fir-coefs = /bits/ 16 <(-289) (81) (-23) (-86) (229) (-354) (397) (-233) (-657) (1699) (-4172) (23010) (-4172) (1699) (-657) (-233) (397) (-354) (229) (-86) (-23) (81) (-289) (0)>;
+
+		adi,obs-profile-custom-adc-profile = /bits/ 16  <450 349 201 98 1280 730 1626 818 1476 732 834 20 41 36 24 200>;
+		adi,obs-settings-custom-loopback-adc-profile = /bits/ 16  <569 369 201 98 1280 291 1541 149 1320 58 807 34 48 40 23 189>;
+
+		adi,tx-profile-dac-div = <1>;
+		adi,tx-profile-iq-rate_khz = <245760>;
+		adi,tx-profile-primary-sig-bandwidth_hz = <75000000>;
+		adi,tx-profile-rf-bandwidth_hz = <200000000>;
+		adi,tx-profile-thb1-interpolation = <2>;
+		adi,tx-profile-thb2-interpolation = <1>;
+		adi,tx-profile-tx-bbf-3db-corner_khz = <100000>;
+		adi,tx-profile-tx-dac-3db-corner_khz = <187000>;
+		adi,tx-profile-tx-fir-interpolation = <1>;
+		adi,tx-profile-tx-input-hb-interpolation = <1>;
+
+		adi,tx-profile-tx-fir-gain_db = <6>;
+		adi,tx-profile-tx-fir-num-fir-coefs = <16>;
+		adi,tx-profile-tx-fir-coefs = /bits/ 16 <(6) (-270) (203) (-168) (-84) (983) (-3222) (21143) (-3222) (983) (-84) (-168) (203) (-270) (6) (0)>;
+
+		adi,sniffer-profile-adc-div = <1>;
+		adi,sniffer-profile-en-high-rej-dec5 = <0>;
+		adi,sniffer-profile-iq-rate_khz = <30720>;
+		adi,sniffer-profile-rf-bandwidth_hz = <20000000>;
+		adi,sniffer-profile-rhb1-decimation = <2>;
+		adi,sniffer-profile-rx-bbf-3db-corner_khz = <100000>;
+		adi,sniffer-profile-rx-dec5-decimation = <5>;
+		adi,sniffer-profile-rx-fir-decimation = <4>;
+#if 0
+		/* Jacky:2018/07/25: enable pin-mode 
+		   https://wiki.analog.com/resources/tools-software/linux-drivers/iio-transceiver/ad9371-customization */
+		adi,arm-gpio-use-rx2-enable-pin = <1>;	// 0= RX1_ENABLE controls RX1&RX2, 1= separate RX1/RX2_ENABLE pins
+		adi,arm-gpio-use-tx2-enable-pin = <1>;	// 0= TX1_ENABLE controls TX1&TX2, 1= separate TX1/TX2_ENABLE pins
+		adi,arm-gpio-tx-rx-pin-mode = <1>;		// 0= ARM command mode, 1 = Pin mode to power up Tx/Rx chains
+		adi,arm-gpio-orx-pin-mode = <1>;		// 0= ARM command mode, 1 = Pin mode to power up ObsRx receiver
+		// to be tested: enable pin-mode but NOT enable gpio-ack
+		adi,arm-gpio-orx-trigger-pin = <0>;		// Select desired GPIO pin (valid 4-15)
+		adi,arm-gpio-orx-mode2-pin = <0>;		// Select desired GPIO pin (valid 0-18)
+		adi,arm-gpio-orx-mode1-pin = <0>;		// Select desired GPIO pin (valid 0-18)
+		adi,arm-gpio-orx-mode0-pin = <0>;		// Select desired GPIO pin (valid 0-18)
+		adi,arm-gpio-rx1-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-rx2-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-tx1-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-tx2-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-orx1-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-orx2-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-srx-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-tx-obs-select = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable.
+			// When 2 Tx are used with only 1 ORx input, this GPIO tells BBIC which Tx channel is active
+			// for calibrations, so BBIC can route correct RF Tx path into the single ORx input
+		adi,arm-gpio-enable-mask = <0>;
+#endif
+	};
+};
+
diff --git a/arch/arm/boot/dts/facc-a10ad9371n1dma.dtsi b/arch/arm/boot/dts/facc-a10ad9371n1dma.dtsi
new file mode 100644
index 0000000..2d3a5f0
--- /dev/null
+++ b/arch/arm/boot/dts/facc-a10ad9371n1dma.dtsi
@@ -0,0 +1,330 @@
+
+&sys_hps_bridges {
+	axi_ad9371_tx_jesd: axi-jesd204-tx@20000 {
+		compatible = "adi,axi-jesd204-tx-1.0";
+		reg = <0x00020000 0x4000>;
+
+		interrupt-parent = <&intc>;
+		interrupts = <0 28 IRQ_TYPE_NONE>;
+
+		clocks = <&sys_clk>, <&tx_device_clk_pll>, <&axi_ad9371_tx_xcvr>;
+		clock-names = "s_axi_aclk", "device_clk", "lane_clk";
+
+		adi,octets-per-frame = <2>;
+		adi,frames-per-multiframe = <32>;
+		adi,converter-resolution = <14>;
+		adi,bits-per-sample = <16>;
+		adi,converters-per-device = <4>;
+		adi,control-bits-per-sample = <2>;
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd_tx_lane_clk";
+	};
+
+	axi_ad9371_rx_jesd: axi-jesd204-rx@30000 {
+		compatible = "adi,axi-jesd204-rx-1.0";
+		reg = <0x00030000 0x4000>;
+
+		interrupt-parent = <&intc>;
+		interrupts = <0 27 IRQ_TYPE_NONE>;
+
+		clocks = <&sys_clk>, <&rx_device_clk_pll>, <&axi_ad9371_rx_xcvr>;
+		clock-names = "s_axi_aclk", "device_clk", "lane_clk";
+
+		adi,octets-per-frame = <4>;
+		adi,frames-per-multiframe = <32>;
+		adi,converter-resolution = <16>;
+		adi,bits-per-sample = <16>;
+		adi,converters-per-device = <4>;
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd_rx_lane_clk";
+	};
+
+	axi_ad9371_rx_os_jesd: axi-jesd204-rx@40000 {
+		compatible = "adi,axi-jesd204-rx-1.0";
+		reg = <0x00040000 0x4000>;
+
+		interrupt-parent = <&intc>;
+		interrupts = <0 29 IRQ_TYPE_NONE>;
+
+		clocks = <&sys_clk>, <&rx_os_device_clk_pll>, <&axi_ad9371_rx_os_xcvr>;
+		clock-names = "s_axi_aclk", "device_clk", "lane_clk";
+
+		adi,octets-per-frame = <2>;
+		adi,frames-per-multiframe = <32>;
+		adi,converter-resolution = <16>;
+		adi,bits-per-sample = <16>;
+		adi,converters-per-device = <4>;
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd_rx_os_lane_clk";
+	};
+
+	axi_ad9371_tx_xcvr: axi-ad9371-tx-xcvr@24000 {
+		compatible = "adi,altera-adxcvr-1.00.a";
+		reg = <0x00024000 0x00001000>,
+			<0x00026000 0x00001000>,
+			<0x00028000 0x00001000>,
+			<0x00029000 0x00001000>,
+			<0x0002a000 0x00001000>,
+			<0x0002b000 0x00001000>;
+		reg-names = "adxcvr", "atx-pll", "adxcfg-0", "adxcfg-1", "adxcfg-2", "adxcfg-3";
+
+		clocks = <&clk0_ad9528 3>, <&tx_device_clk_pll>;
+		clock-names = "ref", "link";
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd204_tx_lane_clock";
+	};
+
+	axi_ad9371_rx_xcvr: axi-ad9371-rx-xcvr@34000 {
+		compatible = "adi,altera-adxcvr-1.00.a";
+		reg = <0x00034000 0x00001000>,
+			<0x00038000 0x00001000>,
+			<0x00039000 0x00001000>;
+		reg-names = "adxcvr", "adxcfg-0", "adxcfg-1";
+
+		clocks = <&clk0_ad9528 3>, <&rx_device_clk_pll>;
+		clock-names = "ref", "link";
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd204_rx_lane_clock";
+	};
+
+	axi_ad9371_rx_os_xcvr: axi-ad9371-rx-os-xcvr@44000 {
+		compatible = "adi,altera-adxcvr-1.00.a";
+		reg = <0x00044000 0x00001000>,
+			<0x00048000 0x00001000>,
+			<0x00049000 0x00001000>;
+		reg-names = "adxcvr", "adxcfg-0", "adxcfg-1";
+
+		clocks = <&clk0_ad9528 3>, <&rx_os_device_clk_pll>;
+		clock-names = "ref", "link";
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd204_rx_os_lane_clock";
+	};
+
+	axi_ad9371_tx_dma: axi-ad9371-tx-dma@2c000 {
+		compatible = "adi,axi-dmac-1.00.a";
+		reg = <0x0002c000 0x00004000>;
+		interrupt-parent = <&intc>;
+		interrupts = <0 30 IRQ_TYPE_LEVEL_HIGH>;
+		#dma-cells = <1>;
+		clocks = <&dma_clk>;
+
+		dma-channel {
+			adi,source-bus-width = <128>;
+			adi,destination-bus-width = <128>;
+			adi,type = <1>;
+			//adi,cyclic;
+		};
+	};
+
+	axi_ad9371_rx_dma: axi-ad9371-rx-dma@3c000 {
+		compatible = "adi,axi-dmac-1.00.a";
+		reg = <0x0003c000 0x00004000>;
+		interrupt-parent = <&intc>;
+		interrupts = <0 31 IRQ_TYPE_LEVEL_HIGH>;
+		#dma-cells = <1>;
+		clocks = <&dma_clk>;
+
+		dma-channel {
+			adi,source-bus-width = <64>;
+			adi,destination-bus-width = <128>;
+			adi,type = <0>;
+		};
+	};
+
+	axi_ad9371_rx_os_dma: axi-ad9371-rx-os-dma@4c000 {
+		compatible = "adi,axi-dmac-1.00.a";
+		reg = <0x0004c000 0x00004000>;
+		interrupt-parent = <&intc>;
+		interrupts = <0 32 IRQ_TYPE_LEVEL_HIGH>;
+		#dma-cells = <1>;
+		clocks = <&dma_clk>;
+
+		dma-channel {
+			adi,source-bus-width = <64>;
+			adi,destination-bus-width = <128>;
+			adi,type = <0>;
+		};
+	};
+
+	axi_ad9371_rx: axi-ad9371-rx-hpc@50000 {
+		compatible = "adi,axi-ad9371-rx-1.0";
+		reg = <0x00050000 0x00008000>;
+		dmas = <&axi_ad9371_rx_dma 0>;
+		dma-names = "rx";
+		spibus-connected = <&trx0_ad9371>;
+	};
+
+	axi_ad9371_tx: axi-ad9371-tx-hpc@54000 {
+		compatible = "adi,axi-ad9371-tx-1.0";
+		reg = <0x00054000 0x00004000>;
+		dmas = <&axi_ad9371_tx_dma 0>;
+		dma-names = "tx";
+		clocks = <&trx0_ad9371 2>;
+		clock-names = "sampl_clk";
+		spibus-connected = <&trx0_ad9371>;
+		adi,axi-pl-fifo-enable;/* RxDMA fifo mode */
+		//adi,axi-pl-fifo-disable;
+	};
+
+	xcvr_rx_os_core: axi-ad9371-rx-obs-hpc@58000 {
+		compatible = "adi,axi-ad9371-obs-1.0";
+		reg = <0x00058000 0x00001000>;
+		dmas = <&axi_ad9371_rx_os_dma 0>;
+		dma-names = "rx";
+		clocks = <&trx0_ad9371 1>;
+		clock-names = "sampl_clk";
+	};
+
+	tx_device_clk_pll: a10-fpll-tx@25000 {
+		compatible = "altr,a10-fpll";
+		reg = <0x00025000 0x1000>;
+		clocks = <&clk0_ad9528 3>;
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd204_tx_link_clock";
+	};
+
+	rx_device_clk_pll: a10-fpll-rx@35000 {
+		compatible = "altr,a10-fpll";
+		reg = <0x00035000 0x1000>;
+		clocks = <&clk0_ad9528 3>;
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd204_rx_link_clock";
+	};
+
+	rx_os_device_clk_pll: a10-fpll-rx-os@45000 {
+		compatible = "altr,a10-fpll";
+		reg = <0x00045000 0x1000>;
+		clocks = <&clk0_ad9528 3>;
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd204_rx_os_link_clock";
+	};
+};
+
+&fmc_spi {
+	trx0_ad9371: ad9371-phy@1 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		#clock-cells = <1>;
+		compatible = "ad9371";
+
+		/* SPI Setup */
+		reg = <1>;
+		spi-max-frequency = <25000000>;
+
+		reset-gpios = <&sys_gpio_out 20 0>;
+		test-gpios = <&sys_gpio_out 21 0>;
+		sysref_req-gpios = <&sys_gpio_out 26 0>;
+		rx2_enable-gpios = <&sys_gpio_out 22 0>;
+		rx1_enable-gpios = <&sys_gpio_out 23 0>;
+		tx2_enable-gpios = <&sys_gpio_out 24 0>;
+		tx1_enable-gpios = <&sys_gpio_out 25 0>;
+
+		/* all interrupts in HW design should be reviewed */
+		//interrupt-parent = <&intc>;
+		//interrupts = <0 31 IRQ_TYPE_LEVEL_HIGH>;
+
+		/* Clocks */
+		clocks = <&axi_ad9371_rx_jesd>, <&axi_ad9371_tx_jesd>,
+			<&axi_ad9371_rx_os_jesd>, <&clk0_ad9528 6>,
+			<&clk0_ad9528 3>;
+		clock-names = "jesd_rx_clk", "jesd_tx_clk",
+			"jesd_rx_os_clk", "dev_clk", "fmc_clk";
+		clock-output-names = "rx_sampl_clk", "rx_os_sampl_clk", "tx_sampl_clk";
+
+		adi,clocks-clk-pll-vco-freq_khz = <9830400>;
+		adi,clocks-device-clock_khz = <122880>;
+		adi,clocks-clk-pll-hs-div = <4>;
+		adi,clocks-clk-pll-vco-div = <2>;
+
+		adi,jesd204-obs-framer-over-sample = <0>;
+
+		adi,rx-profile-adc-div = <1>;
+		adi,rx-profile-en-high-rej-dec5 = <1>;
+		adi,rx-profile-iq-rate_khz = <122880>;
+		adi,rx-profile-rf-bandwidth_hz = <100000000>;
+		adi,rx-profile-rhb1-decimation = <1>;
+		adi,rx-profile-rx-bbf-3db-corner_khz = <100000>;
+		adi,rx-profile-rx-dec5-decimation = <5>;
+		adi,rx-profile-rx-fir-decimation = <2>;
+
+		adi,rx-profile-rx-fir-gain_db = <(-6)>;
+		adi,rx-profile-rx-fir-num-fir-coefs = <48>;
+		adi,rx-profile-rx-fir-coefs = /bits/ 16 <(-5) (-26) (32) (51) (-67) (-116) (140) (212) (-252) (-367) (429) (595) (-688) (-931) (1072) (1427) (-1650) (-2188) (2612) (3496) (-4802) (-7591) (9656) (32317) (32317) (9656) (-7591) (-4802) (3496) (2612) (-2188) (-1650) (1427) (1072) (-931) (-688) (595) (429) (-367) (-252) (212) (140) (-116) (-67) (51) (32) (-26) (-5)>;
+
+		adi,rx-profile-custom-adc-profile = /bits/ 16  <534 386 201 98 1280 491 1591 279 1306 104 792 28 48 39 23 187>;
+
+		adi,obs-profile-adc-div = <1>;
+		adi,obs-profile-en-high-rej-dec5 = <1>;
+		adi,obs-profile-iq-rate_khz = <245760>;
+		adi,obs-profile-rf-bandwidth_hz = <200000000>;
+		adi,obs-profile-rhb1-decimation = <1>;
+		adi,obs-profile-rx-bbf-3db-corner_khz = <100000>;
+		adi,obs-profile-rx-dec5-decimation = <5>;
+		adi,obs-profile-rx-fir-decimation = <1>;
+
+		adi,obs-profile-rx-fir-gain_db = <6>;
+		adi,obs-profile-rx-fir-num-fir-coefs = <24>;
+		adi,obs-profile-rx-fir-coefs = /bits/ 16 <(-289) (81) (-23) (-86) (229) (-354) (397) (-233) (-657) (1699) (-4172) (23010) (-4172) (1699) (-657) (-233) (397) (-354) (229) (-86) (-23) (81) (-289) (0)>;
+
+		adi,obs-profile-custom-adc-profile = /bits/ 16  <450 349 201 98 1280 730 1626 818 1476 732 834 20 41 36 24 200>;
+		adi,obs-settings-custom-loopback-adc-profile = /bits/ 16  <569 369 201 98 1280 291 1541 149 1320 58 807 34 48 40 23 189>;
+
+		adi,tx-profile-dac-div = <1>;
+		adi,tx-profile-iq-rate_khz = <245760>;
+		adi,tx-profile-primary-sig-bandwidth_hz = <75000000>;
+		adi,tx-profile-rf-bandwidth_hz = <200000000>;
+		adi,tx-profile-thb1-interpolation = <2>;
+		adi,tx-profile-thb2-interpolation = <1>;
+		adi,tx-profile-tx-bbf-3db-corner_khz = <100000>;
+		adi,tx-profile-tx-dac-3db-corner_khz = <187000>;
+		adi,tx-profile-tx-fir-interpolation = <1>;
+		adi,tx-profile-tx-input-hb-interpolation = <1>;
+
+		adi,tx-profile-tx-fir-gain_db = <6>;
+		adi,tx-profile-tx-fir-num-fir-coefs = <16>;
+		adi,tx-profile-tx-fir-coefs = /bits/ 16 <(6) (-270) (203) (-168) (-84) (983) (-3222) (21143) (-3222) (983) (-84) (-168) (203) (-270) (6) (0)>;
+
+		adi,sniffer-profile-adc-div = <1>;
+		adi,sniffer-profile-en-high-rej-dec5 = <0>;
+		adi,sniffer-profile-iq-rate_khz = <30720>;
+		adi,sniffer-profile-rf-bandwidth_hz = <20000000>;
+		adi,sniffer-profile-rhb1-decimation = <2>;
+		adi,sniffer-profile-rx-bbf-3db-corner_khz = <100000>;
+		adi,sniffer-profile-rx-dec5-decimation = <5>;
+		adi,sniffer-profile-rx-fir-decimation = <4>;
+#if 0
+		/* Jacky:2018/07/25: enable pin-mode 
+		   https://wiki.analog.com/resources/tools-software/linux-drivers/iio-transceiver/ad9371-customization */
+		adi,arm-gpio-use-rx2-enable-pin = <1>;	// 0= RX1_ENABLE controls RX1&RX2, 1= separate RX1/RX2_ENABLE pins
+		adi,arm-gpio-use-tx2-enable-pin = <1>;	// 0= TX1_ENABLE controls TX1&TX2, 1= separate TX1/TX2_ENABLE pins
+		adi,arm-gpio-tx-rx-pin-mode = <1>;		// 0= ARM command mode, 1 = Pin mode to power up Tx/Rx chains
+		adi,arm-gpio-orx-pin-mode = <1>;		// 0= ARM command mode, 1 = Pin mode to power up ObsRx receiver
+		// to be tested: enable pin-mode but NOT enable gpio-ack
+		adi,arm-gpio-orx-trigger-pin = <0>;		// Select desired GPIO pin (valid 4-15)
+		adi,arm-gpio-orx-mode2-pin = <0>;		// Select desired GPIO pin (valid 0-18)
+		adi,arm-gpio-orx-mode1-pin = <0>;		// Select desired GPIO pin (valid 0-18)
+		adi,arm-gpio-orx-mode0-pin = <0>;		// Select desired GPIO pin (valid 0-18)
+		adi,arm-gpio-rx1-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-rx2-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-tx1-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-tx2-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-orx1-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-orx2-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-srx-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-tx-obs-select = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable.
+			// When 2 Tx are used with only 1 ORx input, this GPIO tells BBIC which Tx channel is active
+			// for calibrations, so BBIC can route correct RF Tx path into the single ORx input
+		adi,arm-gpio-enable-mask = <0>;
+#endif
+	};
+};
+
diff --git a/arch/arm/boot/dts/facc-a10ad9371n2.dtsi b/arch/arm/boot/dts/facc-a10ad9371n2.dtsi
new file mode 100644
index 0000000..ae72df7
--- /dev/null
+++ b/arch/arm/boot/dts/facc-a10ad9371n2.dtsi
@@ -0,0 +1,339 @@
+
+&sys_hps_bridges {
+	axi_ad9371_tx_jesd_n2: axi-jesd204-tx-n2@e0000 {
+		compatible = "adi,axi-jesd204-tx-1.0";
+		reg = <0x000e0000 0x4000>;
+
+		interrupt-parent = <&intc>;
+		interrupts = <0 23 IRQ_TYPE_NONE>;
+
+		clocks = <&sys_clk>, <&tx_device_clk_pll_n2>, <&axi_ad9371_tx_xcvr_n2>;
+		clock-names = "s_axi_aclk", "device_clk", "lane_clk";
+
+		adi,octets-per-frame = <2>;
+		adi,frames-per-multiframe = <32>;
+		adi,converter-resolution = <14>;
+		adi,bits-per-sample = <16>;
+		adi,converters-per-device = <4>;
+		adi,control-bits-per-sample = <2>;
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd_tx_lane_clk_n2";
+	};
+
+	axi_ad9371_rx_jesd_n2: axi-jesd204-rx-n2@f0000 {
+		compatible = "adi,axi-jesd204-rx-1.0";
+		reg = <0x000f0000 0x4000>;
+
+		interrupt-parent = <&intc>;
+		interrupts = <0 51 IRQ_TYPE_NONE>;
+
+		clocks = <&sys_clk>, <&rx_device_clk_pll_n2>, <&axi_ad9371_rx_xcvr_n2>;
+		clock-names = "s_axi_aclk", "device_clk", "lane_clk";
+
+		adi,octets-per-frame = <4>;
+		adi,frames-per-multiframe = <32>;
+		adi,converter-resolution = <16>;
+		adi,bits-per-sample = <16>;
+		adi,converters-per-device = <4>;
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd_rx_lane_clk_n2";
+	};
+
+	axi_ad9371_rx_os_jesd_n2: axi-jesd204-rx-n2@100000 {
+		compatible = "adi,axi-jesd204-rx-1.0";
+		reg = <0x00100000 0x4000>;
+
+		interrupt-parent = <&intc>;
+		interrupts = <0 25 IRQ_TYPE_NONE>;
+
+		clocks = <&sys_clk>, <&rx_os_device_clk_pll_n2>, <&axi_ad9371_rx_os_xcvr_n2>;
+		clock-names = "s_axi_aclk", "device_clk", "lane_clk";
+
+		adi,octets-per-frame = <2>;
+		adi,frames-per-multiframe = <32>;
+		adi,converter-resolution = <16>;
+		adi,bits-per-sample = <16>;
+		adi,converters-per-device = <4>;
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd_rx_os_lane_clk_n2";
+	};
+
+	 axi_ad9371_tx_xcvr_n2: axi-ad9371-tx-xcvr-n2@e4000 {
+		compatible = "adi,altera-adxcvr-1.00.a";
+		reg = <0x000e4000 0x00001000>,
+			<0x000e6000 0x00001000>,
+			<0x000e8000 0x00001000>,
+			<0x000e9000 0x00001000>,
+			<0x000ea000 0x00001000>,
+			<0x000eb000 0x00001000>;
+		reg-names = "adxcvr", "atx-pll", "adxcfg-0", "adxcfg-1", "adxcfg-2", "adxcfg-3";
+
+		clocks = <&clk0_ad9528 3>, <&tx_device_clk_pll_n2>;
+		clock-names = "ref", "link";
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd204_tx_lane_clock_n2";
+	};
+
+	axi_ad9371_rx_xcvr_n2: axi-ad9371-rx-xcvr-n2@f4000 {
+		compatible = "adi,altera-adxcvr-1.00.a";
+		reg = <0x000f4000 0x00001000>,
+			<0x000f8000 0x00001000>,
+			<0x000f9000 0x00001000>;
+		reg-names = "adxcvr", "adxcfg-0", "adxcfg-1";
+
+		clocks = <&clk0_ad9528 3>, <&rx_device_clk_pll_n2>;
+		clock-names = "ref", "link";
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd204_rx_lane_clock_n2";
+	};
+
+	axi_ad9371_rx_os_xcvr_n2: axi-ad9371-rx-os-xcvr-n2@104000 {
+		compatible = "adi,altera-adxcvr-1.00.a";
+		reg = <0x00104000 0x00001000>,
+			<0x00108000 0x00001000>,
+			<0x00109000 0x00001000>;
+		reg-names = "adxcvr", "adxcfg-0", "adxcfg-1";
+
+		clocks = <&clk0_ad9528 3>, <&rx_os_device_clk_pll_n2>;
+		clock-names = "ref", "link";
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd204_rx_os_lane_clock_n2";
+	};
+
+	axi_ad9371_tx_dma_n2: axi-ad9371-tx-dma-n2@ec000 {
+		compatible = "adi,axi-dmac-1.00.a";
+		reg = <0x000ec000 0x00004000>;
+		interrupt-parent = <&intc>;
+		interrupts = <0 40 IRQ_TYPE_LEVEL_HIGH>;
+		#dma-cells = <1>;
+		clocks = <&dma_clk>;
+
+		dma-channel {
+			adi,source-bus-width = <128>;
+			adi,destination-bus-width = <128>;
+			adi,type = <1>;
+			//adi,cyclic;
+		};
+	};
+
+	axi_ad9371_rx_dma_n2: axi-ad9371-rx-dma-n2@fc000 {
+		compatible = "adi,axi-dmac-1.00.a";
+		reg = <0x000fc000 0x00004000>;
+		interrupt-parent = <&intc>;
+		interrupts = <0 41 IRQ_TYPE_LEVEL_HIGH>;
+		#dma-cells = <1>;
+		clocks = <&dma_clk>;
+
+		dma-channel {
+			adi,source-bus-width = <64>;
+			adi,destination-bus-width = <128>;
+			adi,type = <0>;
+		};
+	};
+
+	axi_ad9371_rx_os_dma_n2: axi-ad9371-rx-os-dma-n2@10c000 {
+		compatible = "adi,axi-dmac-1.00.a";
+		reg = <0x0010c000 0x00004000>;
+		interrupt-parent = <&intc>;
+		interrupts = <0 42 IRQ_TYPE_LEVEL_HIGH>;
+		#dma-cells = <1>;
+		clocks = <&dma_clk>;
+
+		dma-channel {
+			adi,source-bus-width = <64>;
+			adi,destination-bus-width = <128>;
+			adi,type = <0>;
+		};
+	};
+
+	axi_ad9371_rx_n2: axi-ad9371-rx-hpc-n2@110000 {
+		compatible = "adi,axi-ad9371-rx-1.0";
+		reg = <0x00110000 0x00008000>;
+		dmas = <&axi_ad9371_rx_dma_n2 0>;
+		dma-names = "rx";
+		spibus-connected = <&trx0_ad9371_n2>;
+	};
+
+	axi_ad9371_tx_n2: axi-ad9371-tx-hpc-n2@114000 {
+		compatible = "adi,axi-ad9371-tx-1.0";
+		reg = <0x00114000 0x00004000>;
+		dmas = <&axi_ad9371_tx_dma_n2 0>;
+		dma-names = "tx";
+		clocks = <&trx0_ad9371_n2 2>;
+		clock-names = "sampl_clk";
+		spibus-connected = <&trx0_ad9371_n2>;
+		//adi,axi-pl-fifo-enable;/* RxDMA fifo mode */
+		adi,axi-pl-fifo-disable;
+	};
+
+	xcvr_rx_os_core_n2: axi-ad9371-rx-obs-hpc-n2@118000 {
+		compatible = "adi,axi-ad9371-obs-1.0";
+		reg = <0x00118000 0x00001000>;
+		dmas = <&axi_ad9371_rx_os_dma_n2 0>;
+		dma-names = "rx";
+		clocks = <&trx0_ad9371_n2 1>;
+		clock-names = "sampl_clk";
+	};
+
+	tx_device_clk_pll_n2: a10-fpll-tx-n2@e5000 {
+		compatible = "altr,a10-fpll";
+		reg = <0x000e5000 0x1000>;
+		clocks = <&clk0_ad9528 3>;
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd204_tx_link_clock_n2";
+	};
+
+	rx_device_clk_pll_n2: a10-fpll-rx-n2@f5000 {
+		compatible = "altr,a10-fpll";
+		reg = <0x000f5000 0x1000>;
+		clocks = <&clk0_ad9528 3>;
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd204_rx_link_clock_n2";
+	};
+
+	rx_os_device_clk_pll_n2: a10-fpll-rx-os-n2@105000 {
+		compatible = "altr,a10-fpll";
+		reg = <0x00105000 0x1000>;
+		clocks = <&clk0_ad9528 3>;
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd204_rx_os_link_clock_n2";
+	};
+
+	fmc_spi_n2: spi@60040 {
+		compatible = "altr,spi-1.0";
+		reg = <0x00060040 0x00000020>;
+		interrupt-parent = <&intc>;
+		interrupts = <0 44 IRQ_TYPE_LEVEL_HIGH>;
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+	};
+};
+
+&fmc_spi_n2 {
+	trx0_ad9371_n2: ad9371-phy-n2@1 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		#clock-cells = <1>;
+		compatible = "ad9371";
+
+		/* SPI Setup */
+		reg = <1>;
+		spi-max-frequency = <25000000>;
+
+		reset-gpios = <&sys_gpio_out 13 0>;
+		test-gpios = <&sys_gpio_out 14 0>;
+		sysref_req-gpios = <&sys_gpio_out 26 0>;
+		rx2_enable-gpios = <&sys_gpio_out 15 0>;
+		rx1_enable-gpios = <&sys_gpio_out 16 0>;
+		tx2_enable-gpios = <&sys_gpio_out 17 0>;
+		tx1_enable-gpios = <&sys_gpio_out 18 0>;
+
+		/* all interrupts in HW design should be reviewed */
+		//interrupt-parent = <&intc>;
+		//interrupts = <0 39 IRQ_TYPE_LEVEL_HIGH>;
+
+		/* Clocks */
+		clocks = <&axi_ad9371_rx_jesd_n2>, <&axi_ad9371_tx_jesd_n2>,
+			<&axi_ad9371_rx_os_jesd_n2>, <&clk0_ad9528 1>,
+			<&clk0_ad9528 3>;
+		clock-names = "jesd_rx_clk", "jesd_tx_clk",
+			"jesd_rx_os_clk", "dev_clk", "fmc_clk";
+		clock-output-names = "rx_sampl_clk_n2", "rx_os_sampl_clk_n2", "tx_sampl_clk_n2";
+
+		adi,clocks-clk-pll-vco-freq_khz = <9830400>;
+		adi,clocks-device-clock_khz = <122880>;
+		adi,clocks-clk-pll-hs-div = <4>;
+		adi,clocks-clk-pll-vco-div = <2>;
+
+		adi,jesd204-obs-framer-over-sample = <0>;
+
+		adi,rx-profile-adc-div = <1>;
+		adi,rx-profile-en-high-rej-dec5 = <1>;
+		adi,rx-profile-iq-rate_khz = <122880>;
+		adi,rx-profile-rf-bandwidth_hz = <100000000>;
+		adi,rx-profile-rhb1-decimation = <1>;
+		adi,rx-profile-rx-bbf-3db-corner_khz = <100000>;
+		adi,rx-profile-rx-dec5-decimation = <5>;
+		adi,rx-profile-rx-fir-decimation = <2>;
+
+		adi,rx-profile-rx-fir-gain_db = <(-6)>;
+		adi,rx-profile-rx-fir-num-fir-coefs = <48>;
+		adi,rx-profile-rx-fir-coefs = /bits/ 16 <(-5) (-26) (32) (51) (-67) (-116) (140) (212) (-252) (-367) (429) (595) (-688) (-931) (1072) (1427) (-1650) (-2188) (2612) (3496) (-4802) (-7591) (9656) (32317) (32317) (9656) (-7591) (-4802) (3496) (2612) (-2188) (-1650) (1427) (1072) (-931) (-688) (595) (429) (-367) (-252) (212) (140) (-116) (-67) (51) (32) (-26) (-5)>;
+
+		adi,rx-profile-custom-adc-profile = /bits/ 16  <534 386 201 98 1280 491 1591 279 1306 104 792 28 48 39 23 187>;
+
+		adi,obs-profile-adc-div = <1>;
+		adi,obs-profile-en-high-rej-dec5 = <1>;
+		adi,obs-profile-iq-rate_khz = <245760>;
+		adi,obs-profile-rf-bandwidth_hz = <200000000>;
+		adi,obs-profile-rhb1-decimation = <1>;
+		adi,obs-profile-rx-bbf-3db-corner_khz = <100000>;
+		adi,obs-profile-rx-dec5-decimation = <5>;
+		adi,obs-profile-rx-fir-decimation = <1>;
+
+		adi,obs-profile-rx-fir-gain_db = <6>;
+		adi,obs-profile-rx-fir-num-fir-coefs = <24>;
+		adi,obs-profile-rx-fir-coefs = /bits/ 16 <(-289) (81) (-23) (-86) (229) (-354) (397) (-233) (-657) (1699) (-4172) (23010) (-4172) (1699) (-657) (-233) (397) (-354) (229) (-86) (-23) (81) (-289) (0)>;
+
+		adi,obs-profile-custom-adc-profile = /bits/ 16  <450 349 201 98 1280 730 1626 818 1476 732 834 20 41 36 24 200>;
+		adi,obs-settings-custom-loopback-adc-profile = /bits/ 16  <569 369 201 98 1280 291 1541 149 1320 58 807 34 48 40 23 189>;
+
+		adi,tx-profile-dac-div = <1>;
+		adi,tx-profile-iq-rate_khz = <245760>;
+		adi,tx-profile-primary-sig-bandwidth_hz = <75000000>;
+		adi,tx-profile-rf-bandwidth_hz = <200000000>;
+		adi,tx-profile-thb1-interpolation = <2>;
+		adi,tx-profile-thb2-interpolation = <1>;
+		adi,tx-profile-tx-bbf-3db-corner_khz = <100000>;
+		adi,tx-profile-tx-dac-3db-corner_khz = <187000>;
+		adi,tx-profile-tx-fir-interpolation = <1>;
+		adi,tx-profile-tx-input-hb-interpolation = <1>;
+
+		adi,tx-profile-tx-fir-gain_db = <6>;
+		adi,tx-profile-tx-fir-num-fir-coefs = <16>;
+		adi,tx-profile-tx-fir-coefs = /bits/ 16 <(6) (-270) (203) (-168) (-84) (983) (-3222) (21143) (-3222) (983) (-84) (-168) (203) (-270) (6) (0)>;
+
+		adi,sniffer-profile-adc-div = <1>;
+		adi,sniffer-profile-en-high-rej-dec5 = <0>;
+		adi,sniffer-profile-iq-rate_khz = <30720>;
+		adi,sniffer-profile-rf-bandwidth_hz = <20000000>;
+		adi,sniffer-profile-rhb1-decimation = <2>;
+		adi,sniffer-profile-rx-bbf-3db-corner_khz = <100000>;
+		adi,sniffer-profile-rx-dec5-decimation = <5>;
+		adi,sniffer-profile-rx-fir-decimation = <4>;
+#if 0
+		/* Jacky:2018/07/25: enable pin-mode 
+		   https://wiki.analog.com/resources/tools-software/linux-drivers/iio-transceiver/ad9371-customization */
+		adi,arm-gpio-use-rx2-enable-pin = <1>;	// 0= RX1_ENABLE controls RX1&RX2, 1= separate RX1/RX2_ENABLE pins
+		adi,arm-gpio-use-tx2-enable-pin = <1>;	// 0= TX1_ENABLE controls TX1&TX2, 1= separate TX1/TX2_ENABLE pins
+		adi,arm-gpio-tx-rx-pin-mode = <1>;		// 0= ARM command mode, 1 = Pin mode to power up Tx/Rx chains
+		adi,arm-gpio-orx-pin-mode = <1>;		// 0= ARM command mode, 1 = Pin mode to power up ObsRx receiver
+		// to be tested: enable pin-mode but NOT enable gpio-ack
+		adi,arm-gpio-orx-trigger-pin = <0>;		// Select desired GPIO pin (valid 4-15)
+		adi,arm-gpio-orx-mode2-pin = <0>;		// Select desired GPIO pin (valid 0-18)
+		adi,arm-gpio-orx-mode1-pin = <0>;		// Select desired GPIO pin (valid 0-18)
+		adi,arm-gpio-orx-mode0-pin = <0>;		// Select desired GPIO pin (valid 0-18)
+		adi,arm-gpio-rx1-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-rx2-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-tx1-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-tx2-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-orx1-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-orx2-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-srx-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-tx-obs-select = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable.
+			// When 2 Tx are used with only 1 ORx input, this GPIO tells BBIC which Tx channel is active
+			// for calibrations, so BBIC can route correct RF Tx path into the single ORx input
+		adi,arm-gpio-enable-mask = <0>;
+#endif
+	};
+};
+
diff --git a/arch/arm/boot/dts/facc-a10ad9371n2dma.dtsi b/arch/arm/boot/dts/facc-a10ad9371n2dma.dtsi
new file mode 100644
index 0000000..feb1974
--- /dev/null
+++ b/arch/arm/boot/dts/facc-a10ad9371n2dma.dtsi
@@ -0,0 +1,339 @@
+
+&sys_hps_bridges {
+	axi_ad9371_tx_jesd_n2: axi-jesd204-tx-n2@80000 {
+		compatible = "adi,axi-jesd204-tx-1.0";
+		reg = <0x00080000 0x4000>;
+
+		interrupt-parent = <&intc>;
+		interrupts = <0 20 IRQ_TYPE_NONE>;
+
+		clocks = <&sys_clk>, <&tx_device_clk_pll_n2>, <&axi_ad9371_tx_xcvr_n2>;
+		clock-names = "s_axi_aclk", "device_clk", "lane_clk";
+
+		adi,octets-per-frame = <2>;
+		adi,frames-per-multiframe = <32>;
+		adi,converter-resolution = <14>;
+		adi,bits-per-sample = <16>;
+		adi,converters-per-device = <4>;
+		adi,control-bits-per-sample = <2>;
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd_tx_lane_clk_n2";
+	};
+
+	axi_ad9371_rx_jesd_n2: axi-jesd204-rx-n2@90000 {
+		compatible = "adi,axi-jesd204-rx-1.0";
+		reg = <0x00090000 0x4000>;
+
+		interrupt-parent = <&intc>;
+		interrupts = <0 21 IRQ_TYPE_NONE>;
+
+		clocks = <&sys_clk>, <&rx_device_clk_pll_n2>, <&axi_ad9371_rx_xcvr_n2>;
+		clock-names = "s_axi_aclk", "device_clk", "lane_clk";
+
+		adi,octets-per-frame = <4>;
+		adi,frames-per-multiframe = <32>;
+		adi,converter-resolution = <16>;
+		adi,bits-per-sample = <16>;
+		adi,converters-per-device = <4>;
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd_rx_lane_clk_n2";
+	};
+
+	axi_ad9371_rx_os_jesd_n2: axi-jesd204-rx-n2@a0000 {
+		compatible = "adi,axi-jesd204-rx-1.0";
+		reg = <0x000a0000 0x4000>;
+
+		interrupt-parent = <&intc>;
+		interrupts = <0 22 IRQ_TYPE_NONE>;
+
+		clocks = <&sys_clk>, <&rx_os_device_clk_pll_n2>, <&axi_ad9371_rx_os_xcvr_n2>;
+		clock-names = "s_axi_aclk", "device_clk", "lane_clk";
+
+		adi,octets-per-frame = <2>;
+		adi,frames-per-multiframe = <32>;
+		adi,converter-resolution = <16>;
+		adi,bits-per-sample = <16>;
+		adi,converters-per-device = <4>;
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd_rx_os_lane_clk_n2";
+	};
+
+	 axi_ad9371_tx_xcvr_n2: axi-ad9371-tx-xcvr-n2@84000 {
+		compatible = "adi,altera-adxcvr-1.00.a";
+		reg = <0x00084000 0x00001000>,
+			<0x00086000 0x00001000>,
+			<0x00088000 0x00001000>,
+			<0x00089000 0x00001000>,
+			<0x0008a000 0x00001000>,
+			<0x0008b000 0x00001000>;
+		reg-names = "adxcvr", "atx-pll", "adxcfg-0", "adxcfg-1", "adxcfg-2", "adxcfg-3";
+
+		clocks = <&clk0_ad9528 3>, <&tx_device_clk_pll_n2>;
+		clock-names = "ref", "link";
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd204_tx_lane_clock_n2";
+	};
+
+	axi_ad9371_rx_xcvr_n2: axi-ad9371-rx-xcvr-n2@94000 {
+		compatible = "adi,altera-adxcvr-1.00.a";
+		reg = <0x00094000 0x00001000>,
+			<0x00098000 0x00001000>,
+			<0x00099000 0x00001000>;
+		reg-names = "adxcvr", "adxcfg-0", "adxcfg-1";
+
+		clocks = <&clk0_ad9528 3>, <&rx_device_clk_pll_n2>;
+		clock-names = "ref", "link";
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd204_rx_lane_clock_n2";
+	};
+
+	axi_ad9371_rx_os_xcvr_n2: axi-ad9371-rx-os-xcvr-n2@a4000 {
+		compatible = "adi,altera-adxcvr-1.00.a";
+		reg = <0x000a4000 0x00001000>,
+			<0x000a8000 0x00001000>,
+			<0x000a9000 0x00001000>;
+		reg-names = "adxcvr", "adxcfg-0", "adxcfg-1";
+
+		clocks = <&clk0_ad9528 3>, <&rx_os_device_clk_pll_n2>;
+		clock-names = "ref", "link";
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd204_rx_os_lane_clock_n2";
+	};
+
+	axi_ad9371_tx_dma_n2: axi-ad9371-tx-dma-n2@8c000 {
+		compatible = "adi,axi-dmac-1.00.a";
+		reg = <0x0008c000 0x00004000>;
+		interrupt-parent = <&intc>;
+		interrupts = <0 35 IRQ_TYPE_LEVEL_HIGH>;
+		#dma-cells = <1>;
+		clocks = <&dma_clk>;
+
+		dma-channel {
+			adi,source-bus-width = <128>;
+			adi,destination-bus-width = <128>;
+			adi,type = <1>;
+			//adi,cyclic;
+		};
+	};
+
+	axi_ad9371_rx_dma_n2: axi-ad9371-rx-dma-n2@9c000 {
+		compatible = "adi,axi-dmac-1.00.a";
+		reg = <0x0009c000 0x00004000>;
+		interrupt-parent = <&intc>;
+		interrupts = <0 36 IRQ_TYPE_LEVEL_HIGH>;
+		#dma-cells = <1>;
+		clocks = <&dma_clk>;
+
+		dma-channel {
+			adi,source-bus-width = <64>;
+			adi,destination-bus-width = <128>;
+			adi,type = <0>;
+		};
+	};
+
+	axi_ad9371_rx_os_dma_n2: axi-ad9371-rx-os-dma-n2@ac000 {
+		compatible = "adi,axi-dmac-1.00.a";
+		reg = <0x000ac000 0x00004000>;
+		interrupt-parent = <&intc>;
+		interrupts = <0 37 IRQ_TYPE_LEVEL_HIGH>;
+		#dma-cells = <1>;
+		clocks = <&dma_clk>;
+
+		dma-channel {
+			adi,source-bus-width = <64>;
+			adi,destination-bus-width = <128>;
+			adi,type = <0>;
+		};
+	};
+
+	axi_ad9371_rx_n2: axi-ad9371-rx-hpc-n2@b0000 {
+		compatible = "adi,axi-ad9371-rx-1.0";
+		reg = <0x000b0000 0x00008000>;
+		dmas = <&axi_ad9371_rx_dma_n2 0>;
+		dma-names = "rx";
+		spibus-connected = <&trx0_ad9371_n2>;
+	};
+
+	axi_ad9371_tx_n2: axi-ad9371-tx-hpc-n2@b4000 {
+		compatible = "adi,axi-ad9371-tx-1.0";
+		reg = <0x000b4000 0x00004000>;
+		dmas = <&axi_ad9371_tx_dma_n2 0>;
+		dma-names = "tx";
+		clocks = <&trx0_ad9371_n2 2>;
+		clock-names = "sampl_clk";
+		spibus-connected = <&trx0_ad9371_n2>;
+		adi,axi-pl-fifo-enable;/* RxDMA fifo mode */
+		//adi,axi-pl-fifo-disable;
+	};
+
+	xcvr_rx_os_core_n2: axi-ad9371-rx-obs-hpc-n2@b8000 {
+		compatible = "adi,axi-ad9371-obs-1.0";
+		reg = <0x000b8000 0x00001000>;
+		dmas = <&axi_ad9371_rx_os_dma_n2 0>;
+		dma-names = "rx";
+		clocks = <&trx0_ad9371_n2 1>;
+		clock-names = "sampl_clk";
+	};
+
+	tx_device_clk_pll_n2: a10-fpll-tx-n2@85000 {
+		compatible = "altr,a10-fpll";
+		reg = <0x00085000 0x1000>;
+		clocks = <&clk0_ad9528 3>;
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd204_tx_link_clock_n2";
+	};
+
+	rx_device_clk_pll_n2: a10-fpll-rx-n2@95000 {
+		compatible = "altr,a10-fpll";
+		reg = <0x00095000 0x1000>;
+		clocks = <&clk0_ad9528 3>;
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd204_rx_link_clock_n2";
+	};
+
+	rx_os_device_clk_pll_n2: a10-fpll-rx-os-n2@a5000 {
+		compatible = "altr,a10-fpll";
+		reg = <0x000a5000 0x1000>;
+		clocks = <&clk0_ad9528 3>;
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd204_rx_os_link_clock_n2";
+	};
+
+	fmc_spi_n2: spi@60040 {
+		compatible = "altr,spi-1.0";
+		reg = <0x00060040 0x00000020>;
+		interrupt-parent = <&intc>;
+		interrupts = <0 39 IRQ_TYPE_LEVEL_HIGH>;
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+	};
+};
+
+&fmc_spi_n2 {
+	trx0_ad9371_n2: ad9371-phy-n2@1 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		#clock-cells = <1>;
+		compatible = "ad9371";
+
+		/* SPI Setup */
+		reg = <1>;
+		spi-max-frequency = <25000000>;
+
+		reset-gpios = <&sys_gpio_out 13 0>;
+		test-gpios = <&sys_gpio_out 14 0>;
+		sysref_req-gpios = <&sys_gpio_out 26 0>;
+		rx2_enable-gpios = <&sys_gpio_out 15 0>;
+		rx1_enable-gpios = <&sys_gpio_out 16 0>;
+		tx2_enable-gpios = <&sys_gpio_out 17 0>;
+		tx1_enable-gpios = <&sys_gpio_out 18 0>;
+
+		/* all interrupts in HW design should be reviewed */
+		//interrupt-parent = <&intc>;
+		//interrupts = <0 39 IRQ_TYPE_LEVEL_HIGH>;
+
+		/* Clocks */
+		clocks = <&axi_ad9371_rx_jesd_n2>, <&axi_ad9371_tx_jesd_n2>,
+			<&axi_ad9371_rx_os_jesd_n2>, <&clk0_ad9528 1>,
+			<&clk0_ad9528 3>;
+		clock-names = "jesd_rx_clk", "jesd_tx_clk",
+			"jesd_rx_os_clk", "dev_clk", "fmc_clk";
+		clock-output-names = "rx_sampl_clk_n2", "rx_os_sampl_clk_n2", "tx_sampl_clk_n2";
+
+		adi,clocks-clk-pll-vco-freq_khz = <9830400>;
+		adi,clocks-device-clock_khz = <122880>;
+		adi,clocks-clk-pll-hs-div = <4>;
+		adi,clocks-clk-pll-vco-div = <2>;
+
+		adi,jesd204-obs-framer-over-sample = <0>;
+
+		adi,rx-profile-adc-div = <1>;
+		adi,rx-profile-en-high-rej-dec5 = <1>;
+		adi,rx-profile-iq-rate_khz = <122880>;
+		adi,rx-profile-rf-bandwidth_hz = <100000000>;
+		adi,rx-profile-rhb1-decimation = <1>;
+		adi,rx-profile-rx-bbf-3db-corner_khz = <100000>;
+		adi,rx-profile-rx-dec5-decimation = <5>;
+		adi,rx-profile-rx-fir-decimation = <2>;
+
+		adi,rx-profile-rx-fir-gain_db = <(-6)>;
+		adi,rx-profile-rx-fir-num-fir-coefs = <48>;
+		adi,rx-profile-rx-fir-coefs = /bits/ 16 <(-5) (-26) (32) (51) (-67) (-116) (140) (212) (-252) (-367) (429) (595) (-688) (-931) (1072) (1427) (-1650) (-2188) (2612) (3496) (-4802) (-7591) (9656) (32317) (32317) (9656) (-7591) (-4802) (3496) (2612) (-2188) (-1650) (1427) (1072) (-931) (-688) (595) (429) (-367) (-252) (212) (140) (-116) (-67) (51) (32) (-26) (-5)>;
+
+		adi,rx-profile-custom-adc-profile = /bits/ 16  <534 386 201 98 1280 491 1591 279 1306 104 792 28 48 39 23 187>;
+
+		adi,obs-profile-adc-div = <1>;
+		adi,obs-profile-en-high-rej-dec5 = <1>;
+		adi,obs-profile-iq-rate_khz = <245760>;
+		adi,obs-profile-rf-bandwidth_hz = <200000000>;
+		adi,obs-profile-rhb1-decimation = <1>;
+		adi,obs-profile-rx-bbf-3db-corner_khz = <100000>;
+		adi,obs-profile-rx-dec5-decimation = <5>;
+		adi,obs-profile-rx-fir-decimation = <1>;
+
+		adi,obs-profile-rx-fir-gain_db = <6>;
+		adi,obs-profile-rx-fir-num-fir-coefs = <24>;
+		adi,obs-profile-rx-fir-coefs = /bits/ 16 <(-289) (81) (-23) (-86) (229) (-354) (397) (-233) (-657) (1699) (-4172) (23010) (-4172) (1699) (-657) (-233) (397) (-354) (229) (-86) (-23) (81) (-289) (0)>;
+
+		adi,obs-profile-custom-adc-profile = /bits/ 16  <450 349 201 98 1280 730 1626 818 1476 732 834 20 41 36 24 200>;
+		adi,obs-settings-custom-loopback-adc-profile = /bits/ 16  <569 369 201 98 1280 291 1541 149 1320 58 807 34 48 40 23 189>;
+
+		adi,tx-profile-dac-div = <1>;
+		adi,tx-profile-iq-rate_khz = <245760>;
+		adi,tx-profile-primary-sig-bandwidth_hz = <75000000>;
+		adi,tx-profile-rf-bandwidth_hz = <200000000>;
+		adi,tx-profile-thb1-interpolation = <2>;
+		adi,tx-profile-thb2-interpolation = <1>;
+		adi,tx-profile-tx-bbf-3db-corner_khz = <100000>;
+		adi,tx-profile-tx-dac-3db-corner_khz = <187000>;
+		adi,tx-profile-tx-fir-interpolation = <1>;
+		adi,tx-profile-tx-input-hb-interpolation = <1>;
+
+		adi,tx-profile-tx-fir-gain_db = <6>;
+		adi,tx-profile-tx-fir-num-fir-coefs = <16>;
+		adi,tx-profile-tx-fir-coefs = /bits/ 16 <(6) (-270) (203) (-168) (-84) (983) (-3222) (21143) (-3222) (983) (-84) (-168) (203) (-270) (6) (0)>;
+
+		adi,sniffer-profile-adc-div = <1>;
+		adi,sniffer-profile-en-high-rej-dec5 = <0>;
+		adi,sniffer-profile-iq-rate_khz = <30720>;
+		adi,sniffer-profile-rf-bandwidth_hz = <20000000>;
+		adi,sniffer-profile-rhb1-decimation = <2>;
+		adi,sniffer-profile-rx-bbf-3db-corner_khz = <100000>;
+		adi,sniffer-profile-rx-dec5-decimation = <5>;
+		adi,sniffer-profile-rx-fir-decimation = <4>;
+#if 0
+		/* Jacky:2018/07/25: enable pin-mode 
+		   https://wiki.analog.com/resources/tools-software/linux-drivers/iio-transceiver/ad9371-customization */
+		adi,arm-gpio-use-rx2-enable-pin = <1>;	// 0= RX1_ENABLE controls RX1&RX2, 1= separate RX1/RX2_ENABLE pins
+		adi,arm-gpio-use-tx2-enable-pin = <1>;	// 0= TX1_ENABLE controls TX1&TX2, 1= separate TX1/TX2_ENABLE pins
+		adi,arm-gpio-tx-rx-pin-mode = <1>;		// 0= ARM command mode, 1 = Pin mode to power up Tx/Rx chains
+		adi,arm-gpio-orx-pin-mode = <1>;		// 0= ARM command mode, 1 = Pin mode to power up ObsRx receiver
+		// to be tested: enable pin-mode but NOT enable gpio-ack
+		adi,arm-gpio-orx-trigger-pin = <0>;		// Select desired GPIO pin (valid 4-15)
+		adi,arm-gpio-orx-mode2-pin = <0>;		// Select desired GPIO pin (valid 0-18)
+		adi,arm-gpio-orx-mode1-pin = <0>;		// Select desired GPIO pin (valid 0-18)
+		adi,arm-gpio-orx-mode0-pin = <0>;		// Select desired GPIO pin (valid 0-18)
+		adi,arm-gpio-rx1-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-rx2-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-tx1-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-tx2-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-orx1-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-orx2-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-srx-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-tx-obs-select = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable.
+			// When 2 Tx are used with only 1 ORx input, this GPIO tells BBIC which Tx channel is active
+			// for calibrations, so BBIC can route correct RF Tx path into the single ORx input
+		adi,arm-gpio-enable-mask = <0>;
+#endif
+	};
+};
+
diff --git a/arch/arm/boot/dts/facc-a10ad9371n3dma.dtsi b/arch/arm/boot/dts/facc-a10ad9371n3dma.dtsi
new file mode 100644
index 0000000..8e9e3c9
--- /dev/null
+++ b/arch/arm/boot/dts/facc-a10ad9371n3dma.dtsi
@@ -0,0 +1,339 @@
+
+&sys_hps_bridges {
+	axi_ad9371_tx_jesd_n3: axi-jesd204-tx-n3@e0000 {
+		compatible = "adi,axi-jesd204-tx-1.0";
+		reg = <0x000e0000 0x4000>;
+
+		interrupt-parent = <&intc>;
+		interrupts = <0 23 IRQ_TYPE_NONE>;
+
+		clocks = <&sys_clk>, <&tx_device_clk_pll_n3>, <&axi_ad9371_tx_xcvr_n3>;
+		clock-names = "s_axi_aclk", "device_clk", "lane_clk";
+
+		adi,octets-per-frame = <2>;
+		adi,frames-per-multiframe = <32>;
+		adi,converter-resolution = <14>;
+		adi,bits-per-sample = <16>;
+		adi,converters-per-device = <4>;
+		adi,control-bits-per-sample = <2>;
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd_tx_lane_clk_n3";
+	};
+
+	axi_ad9371_rx_jesd_n3: axi-jesd204-rx-n3@f0000 {
+		compatible = "adi,axi-jesd204-rx-1.0";
+		reg = <0x000f0000 0x4000>;
+
+		interrupt-parent = <&intc>;
+		interrupts = <0 51 IRQ_TYPE_NONE>;
+
+		clocks = <&sys_clk>, <&rx_device_clk_pll_n3>, <&axi_ad9371_rx_xcvr_n3>;
+		clock-names = "s_axi_aclk", "device_clk", "lane_clk";
+
+		adi,octets-per-frame = <4>;
+		adi,frames-per-multiframe = <32>;
+		adi,converter-resolution = <16>;
+		adi,bits-per-sample = <16>;
+		adi,converters-per-device = <4>;
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd_rx_lane_clk_n3";
+	};
+
+	axi_ad9371_rx_os_jesd_n3: axi-jesd204-rx-n3@100000 {
+		compatible = "adi,axi-jesd204-rx-1.0";
+		reg = <0x00100000 0x4000>;
+
+		interrupt-parent = <&intc>;
+		interrupts = <0 25 IRQ_TYPE_NONE>;
+
+		clocks = <&sys_clk>, <&rx_os_device_clk_pll_n3>, <&axi_ad9371_rx_os_xcvr_n3>;
+		clock-names = "s_axi_aclk", "device_clk", "lane_clk";
+
+		adi,octets-per-frame = <2>;
+		adi,frames-per-multiframe = <32>;
+		adi,converter-resolution = <16>;
+		adi,bits-per-sample = <16>;
+		adi,converters-per-device = <4>;
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd_rx_os_lane_clk_n3";
+	};
+
+	 axi_ad9371_tx_xcvr_n3: axi-ad9371-tx-xcvr-n3@e4000 {
+		compatible = "adi,altera-adxcvr-1.00.a";
+		reg = <0x000e4000 0x00001000>,
+			<0x000e6000 0x00001000>,
+			<0x000e8000 0x00001000>,
+			<0x000e9000 0x00001000>,
+			<0x000ea000 0x00001000>,
+			<0x000eb000 0x00001000>;
+		reg-names = "adxcvr", "atx-pll", "adxcfg-0", "adxcfg-1", "adxcfg-2", "adxcfg-3";
+
+		clocks = <&clk0_ad9528 11>, <&tx_device_clk_pll_n3>;
+		clock-names = "ref", "link";
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd204_tx_lane_clock_n3";
+	};
+
+	axi_ad9371_rx_xcvr_n3: axi-ad9371-rx-xcvr-n3@f4000 {
+		compatible = "adi,altera-adxcvr-1.00.a";
+		reg = <0x000f4000 0x00001000>,
+			<0x000f8000 0x00001000>,
+			<0x000f9000 0x00001000>;
+		reg-names = "adxcvr", "adxcfg-0", "adxcfg-1";
+
+		clocks = <&clk0_ad9528 11>, <&rx_device_clk_pll_n3>;
+		clock-names = "ref", "link";
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd204_rx_lane_clock_n3";
+	};
+
+	axi_ad9371_rx_os_xcvr_n3: axi-ad9371-rx-os-xcvr-n3@104000 {
+		compatible = "adi,altera-adxcvr-1.00.a";
+		reg = <0x00104000 0x00001000>,
+			<0x00108000 0x00001000>,
+			<0x00109000 0x00001000>;
+		reg-names = "adxcvr", "adxcfg-0", "adxcfg-1";
+
+		clocks = <&clk0_ad9528 11>, <&rx_os_device_clk_pll_n3>;
+		clock-names = "ref", "link";
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd204_rx_os_lane_clock_n3";
+	};
+
+	axi_ad9371_tx_dma_n3: axi-ad9371-tx-dma-n3@ec000 {
+		compatible = "adi,axi-dmac-1.00.a";
+		reg = <0x000ec000 0x00004000>;
+		interrupt-parent = <&intc>;
+		interrupts = <0 40 IRQ_TYPE_LEVEL_HIGH>;
+		#dma-cells = <1>;
+		clocks = <&dma_clk>;
+
+		dma-channel {
+			adi,source-bus-width = <128>;
+			adi,destination-bus-width = <128>;
+			adi,type = <1>;
+			//adi,cyclic;
+		};
+	};
+
+	axi_ad9371_rx_dma_n3: axi-ad9371-rx-dma-n3@fc000 {
+		compatible = "adi,axi-dmac-1.00.a";
+		reg = <0x000fc000 0x00004000>;
+		interrupt-parent = <&intc>;
+		interrupts = <0 41 IRQ_TYPE_LEVEL_HIGH>;
+		#dma-cells = <1>;
+		clocks = <&dma_clk>;
+
+		dma-channel {
+			adi,source-bus-width = <64>;
+			adi,destination-bus-width = <128>;
+			adi,type = <0>;
+		};
+	};
+
+	axi_ad9371_rx_os_dma_n3: axi-ad9371-rx-os-dma-n3@10c000 {
+		compatible = "adi,axi-dmac-1.00.a";
+		reg = <0x0010c000 0x00004000>;
+		interrupt-parent = <&intc>;
+		interrupts = <0 42 IRQ_TYPE_LEVEL_HIGH>;
+		#dma-cells = <1>;
+		clocks = <&dma_clk>;
+
+		dma-channel {
+			adi,source-bus-width = <64>;
+			adi,destination-bus-width = <128>;
+			adi,type = <0>;
+		};
+	};
+
+	axi_ad9371_rx_n3: axi-ad9371-rx-hpc_n3@110000 {
+		compatible = "adi,axi-ad9371-rx-1.0";
+		reg = <0x00110000 0x00008000>;
+		dmas = <&axi_ad9371_rx_dma_n3 0>;
+		dma-names = "rx";
+		spibus-connected = <&trx0_ad9371_n3>;
+	};
+
+	axi_ad9371_tx_n3: axi-ad9371-tx-hpc-n3@114000 {
+		compatible = "adi,axi-ad9371-tx-1.0";
+		reg = <0x00114000 0x00004000>;
+		dmas = <&axi_ad9371_tx_dma_n3 0>;
+		dma-names = "tx";
+		clocks = <&trx0_ad9371_n3 2>;
+		clock-names = "sampl_clk";
+		spibus-connected = <&trx0_ad9371_n3>;
+		adi,axi-pl-fifo-enable;/* RxDMA fifo mode */
+		//adi,axi-pl-fifo-disable;
+	};
+
+	xcvr_rx_os_core_n3: axi-ad9371-rx-obs-hpc-n3@118000 {
+		compatible = "adi,axi-ad9371-obs-1.0";
+		reg = <0x00118000 0x00001000>;
+		dmas = <&axi_ad9371_rx_os_dma_n3 0>;
+		dma-names = "rx";
+		clocks = <&trx0_ad9371_n3 1>;
+		clock-names = "sampl_clk";
+	};
+
+	tx_device_clk_pll_n3: a10-fpll-tx-n3@e5000 {
+		compatible = "altr,a10-fpll";
+		reg = <0x000e5000 0x1000>;
+		clocks = <&clk0_ad9528 11>;
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd204_tx_link_clock_n3";
+	};
+
+	rx_device_clk_pll_n3: a10-fpll-rx-n3@f5000 {
+		compatible = "altr,a10-fpll";
+		reg = <0x000f5000 0x1000>;
+		clocks = <&clk0_ad9528 11>;
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd204_rx_link_clock_n3";
+	};
+
+	rx_os_device_clk_pll_n3: a10-fpll-rx-os-n3@105000 {
+		compatible = "altr,a10-fpll";
+		reg = <0x00105000 0x1000>;
+		clocks = <&clk0_ad9528 11>;
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd204_rx_os_link_clock_n3";
+	};
+
+	fmc_spi_n3: spi@c0040 {
+		compatible = "altr,spi-1.0";
+		reg = <0x000c0040 0x00000020>;
+		interrupt-parent = <&intc>;
+		interrupts = <0 44 IRQ_TYPE_LEVEL_HIGH>;
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+	};
+};
+
+&fmc_spi_n3 {
+	trx0_ad9371_n3: ad9371-phy-n3@1 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		#clock-cells = <1>;
+		compatible = "ad9371";
+
+		/* SPI Setup */
+		reg = <1>;
+		spi-max-frequency = <25000000>;
+
+		reset-gpios = <&sys_gpio_out 6 0>;
+		test-gpios = <&sys_gpio_out 7 0>;
+		sysref_req-gpios = <&sys_gpio_out 26 0>;
+		rx2_enable-gpios = <&sys_gpio_out 8 0>;
+		rx1_enable-gpios = <&sys_gpio_out 9 0>;
+		tx2_enable-gpios = <&sys_gpio_out 10 0>;
+		tx1_enable-gpios = <&sys_gpio_out 11 0>;
+
+		/* all interrupts in HW design should be reviewed */
+		//interrupt-parent = <&intc>;
+		//interrupts = <0 44 IRQ_TYPE_LEVEL_HIGH>;
+
+		/* Clocks */
+		clocks = <&axi_ad9371_rx_jesd_n3>, <&axi_ad9371_tx_jesd_n3>,
+			<&axi_ad9371_rx_os_jesd_n3>, <&clk0_ad9528 13>,
+			<&clk0_ad9528 11>;
+		clock-names = "jesd_rx_clk", "jesd_tx_clk",
+			"jesd_rx_os_clk", "dev_clk", "fmc_clk";
+		clock-output-names = "rx_sampl_clk_n3", "rx_os_sampl_clk_n3", "tx_sampl_clk_n3";
+
+		adi,clocks-clk-pll-vco-freq_khz = <9830400>;
+		adi,clocks-device-clock_khz = <122880>;
+		adi,clocks-clk-pll-hs-div = <4>;
+		adi,clocks-clk-pll-vco-div = <2>;
+
+		adi,jesd204-obs-framer-over-sample = <0>;
+
+		adi,rx-profile-adc-div = <1>;
+		adi,rx-profile-en-high-rej-dec5 = <1>;
+		adi,rx-profile-iq-rate_khz = <122880>;
+		adi,rx-profile-rf-bandwidth_hz = <100000000>;
+		adi,rx-profile-rhb1-decimation = <1>;
+		adi,rx-profile-rx-bbf-3db-corner_khz = <100000>;
+		adi,rx-profile-rx-dec5-decimation = <5>;
+		adi,rx-profile-rx-fir-decimation = <2>;
+
+		adi,rx-profile-rx-fir-gain_db = <(-6)>;
+		adi,rx-profile-rx-fir-num-fir-coefs = <48>;
+		adi,rx-profile-rx-fir-coefs = /bits/ 16 <(-5) (-26) (32) (51) (-67) (-116) (140) (212) (-252) (-367) (429) (595) (-688) (-931) (1072) (1427) (-1650) (-2188) (2612) (3496) (-4802) (-7591) (9656) (32317) (32317) (9656) (-7591) (-4802) (3496) (2612) (-2188) (-1650) (1427) (1072) (-931) (-688) (595) (429) (-367) (-252) (212) (140) (-116) (-67) (51) (32) (-26) (-5)>;
+
+		adi,rx-profile-custom-adc-profile = /bits/ 16  <534 386 201 98 1280 491 1591 279 1306 104 792 28 48 39 23 187>;
+
+		adi,obs-profile-adc-div = <1>;
+		adi,obs-profile-en-high-rej-dec5 = <1>;
+		adi,obs-profile-iq-rate_khz = <245760>;
+		adi,obs-profile-rf-bandwidth_hz = <200000000>;
+		adi,obs-profile-rhb1-decimation = <1>;
+		adi,obs-profile-rx-bbf-3db-corner_khz = <100000>;
+		adi,obs-profile-rx-dec5-decimation = <5>;
+		adi,obs-profile-rx-fir-decimation = <1>;
+
+		adi,obs-profile-rx-fir-gain_db = <6>;
+		adi,obs-profile-rx-fir-num-fir-coefs = <24>;
+		adi,obs-profile-rx-fir-coefs = /bits/ 16 <(-289) (81) (-23) (-86) (229) (-354) (397) (-233) (-657) (1699) (-4172) (23010) (-4172) (1699) (-657) (-233) (397) (-354) (229) (-86) (-23) (81) (-289) (0)>;
+
+		adi,obs-profile-custom-adc-profile = /bits/ 16  <450 349 201 98 1280 730 1626 818 1476 732 834 20 41 36 24 200>;
+		adi,obs-settings-custom-loopback-adc-profile = /bits/ 16  <569 369 201 98 1280 291 1541 149 1320 58 807 34 48 40 23 189>;
+
+		adi,tx-profile-dac-div = <1>;
+		adi,tx-profile-iq-rate_khz = <245760>;
+		adi,tx-profile-primary-sig-bandwidth_hz = <75000000>;
+		adi,tx-profile-rf-bandwidth_hz = <200000000>;
+		adi,tx-profile-thb1-interpolation = <2>;
+		adi,tx-profile-thb2-interpolation = <1>;
+		adi,tx-profile-tx-bbf-3db-corner_khz = <100000>;
+		adi,tx-profile-tx-dac-3db-corner_khz = <187000>;
+		adi,tx-profile-tx-fir-interpolation = <1>;
+		adi,tx-profile-tx-input-hb-interpolation = <1>;
+
+		adi,tx-profile-tx-fir-gain_db = <6>;
+		adi,tx-profile-tx-fir-num-fir-coefs = <16>;
+		adi,tx-profile-tx-fir-coefs = /bits/ 16 <(6) (-270) (203) (-168) (-84) (983) (-3222) (21143) (-3222) (983) (-84) (-168) (203) (-270) (6) (0)>;
+
+		adi,sniffer-profile-adc-div = <1>;
+		adi,sniffer-profile-en-high-rej-dec5 = <0>;
+		adi,sniffer-profile-iq-rate_khz = <30720>;
+		adi,sniffer-profile-rf-bandwidth_hz = <20000000>;
+		adi,sniffer-profile-rhb1-decimation = <2>;
+		adi,sniffer-profile-rx-bbf-3db-corner_khz = <100000>;
+		adi,sniffer-profile-rx-dec5-decimation = <5>;
+		adi,sniffer-profile-rx-fir-decimation = <4>;
+#if 0
+		/* Jacky:2018/07/25: enable pin-mode 
+		   https://wiki.analog.com/resources/tools-software/linux-drivers/iio-transceiver/ad9371-customization */
+		adi,arm-gpio-use-rx2-enable-pin = <1>;	// 0= RX1_ENABLE controls RX1&RX2, 1= separate RX1/RX2_ENABLE pins
+		adi,arm-gpio-use-tx2-enable-pin = <1>;	// 0= TX1_ENABLE controls TX1&TX2, 1= separate TX1/TX2_ENABLE pins
+		adi,arm-gpio-tx-rx-pin-mode = <1>;		// 0= ARM command mode, 1 = Pin mode to power up Tx/Rx chains
+		adi,arm-gpio-orx-pin-mode = <1>;		// 0= ARM command mode, 1 = Pin mode to power up ObsRx receiver
+		// to be tested: enable pin-mode but NOT enable gpio-ack
+		adi,arm-gpio-orx-trigger-pin = <0>;		// Select desired GPIO pin (valid 4-15)
+		adi,arm-gpio-orx-mode2-pin = <0>;		// Select desired GPIO pin (valid 0-18)
+		adi,arm-gpio-orx-mode1-pin = <0>;		// Select desired GPIO pin (valid 0-18)
+		adi,arm-gpio-orx-mode0-pin = <0>;		// Select desired GPIO pin (valid 0-18)
+		adi,arm-gpio-rx1-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-rx2-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-tx1-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-tx2-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-orx1-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-orx2-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-srx-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-tx-obs-select = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable.
+			// When 2 Tx are used with only 1 ORx input, this GPIO tells BBIC which Tx channel is active
+			// for calibrations, so BBIC can route correct RF Tx path into the single ORx input
+		adi,arm-gpio-enable-mask = <0>;
+#endif
+	};
+};
+
diff --git a/arch/arm/boot/dts/facc-a10ad9371n4dma.dtsi b/arch/arm/boot/dts/facc-a10ad9371n4dma.dtsi
new file mode 100644
index 0000000..78d53ce
--- /dev/null
+++ b/arch/arm/boot/dts/facc-a10ad9371n4dma.dtsi
@@ -0,0 +1,339 @@
+
+&sys_hps_bridges {
+	axi_ad9371_tx_jesd_n4: axi-jesd204-tx-n4@140000 {
+		compatible = "adi,axi-jesd204-tx-1.0";
+		reg = <0x00140000 0x4000>;
+
+		interrupt-parent = <&intc>;
+		interrupts = <0 33 IRQ_TYPE_NONE>;
+
+		clocks = <&sys_clk>, <&tx_device_clk_pll_n4>, <&axi_ad9371_tx_xcvr_n4>;
+		clock-names = "s_axi_aclk", "device_clk", "lane_clk";
+
+		adi,octets-per-frame = <2>;
+		adi,frames-per-multiframe = <32>;
+		adi,converter-resolution = <14>;
+		adi,bits-per-sample = <16>;
+		adi,converters-per-device = <4>;
+		adi,control-bits-per-sample = <2>;
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd_tx_lane_clk_n4";
+	};
+
+	axi_ad9371_rx_jesd_n4: axi-jesd204-rx-n4@150000 {
+		compatible = "adi,axi-jesd204-rx-1.0";
+		reg = <0x00150000 0x4000>;
+
+		interrupt-parent = <&intc>;
+		interrupts = <0 34 IRQ_TYPE_NONE>;
+
+		clocks = <&sys_clk>, <&rx_device_clk_pll_n4>, <&axi_ad9371_rx_xcvr_n4>;
+		clock-names = "s_axi_aclk", "device_clk", "lane_clk";
+
+		adi,octets-per-frame = <4>;
+		adi,frames-per-multiframe = <32>;
+		adi,converter-resolution = <16>;
+		adi,bits-per-sample = <16>;
+		adi,converters-per-device = <4>;
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd_rx_lane_clk_n4";
+	};
+
+	axi_ad9371_rx_os_jesd_n4: axi-jesd204-rx-n4@160000 {
+		compatible = "adi,axi-jesd204-rx-1.0";
+		reg = <0x00160000 0x4000>;
+
+		interrupt-parent = <&intc>;
+		interrupts = <0 50 IRQ_TYPE_NONE>;
+
+		clocks = <&sys_clk>, <&rx_os_device_clk_pll_n4>, <&axi_ad9371_rx_os_xcvr_n4>;
+		clock-names = "s_axi_aclk", "device_clk", "lane_clk";
+
+		adi,octets-per-frame = <2>;
+		adi,frames-per-multiframe = <32>;
+		adi,converter-resolution = <16>;
+		adi,bits-per-sample = <16>;
+		adi,converters-per-device = <4>;
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd_rx_os_lane_clk_n4";
+	};
+
+	 axi_ad9371_tx_xcvr_n4: axi-ad9371-tx-xcvr-n4@144000 {
+		compatible = "adi,altera-adxcvr-1.00.a";
+		reg = <0x00144000 0x00001000>,
+			<0x00146000 0x00001000>,
+			<0x00148000 0x00001000>,
+			<0x00149000 0x00001000>,
+			<0x0014a000 0x00001000>,
+			<0x0014b000 0x00001000>;
+		reg-names = "adxcvr", "atx-pll", "adxcfg-0", "adxcfg-1", "adxcfg-2", "adxcfg-3";
+
+		clocks = <&clk0_ad9528 11>, <&tx_device_clk_pll_n4>;
+		clock-names = "ref", "link";
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd204_tx_lane_clock_n4";
+	};
+
+	axi_ad9371_rx_xcvr_n4: axi-ad9371-rx-xcvr-n4@154000 {
+		compatible = "adi,altera-adxcvr-1.00.a";
+		reg = <0x00154000 0x00001000>,
+			<0x00158000 0x00001000>,
+			<0x00159000 0x00001000>;
+		reg-names = "adxcvr", "adxcfg-0", "adxcfg-1";
+
+		clocks = <&clk0_ad9528 11>, <&rx_device_clk_pll_n4>;
+		clock-names = "ref", "link";
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd204_rx_lane_clock_n4";
+	};
+
+	axi_ad9371_rx_os_xcvr_n4: axi-ad9371-rx-os-xcvr-n4@164000 {
+		compatible = "adi,altera-adxcvr-1.00.a";
+		reg = <0x00164000 0x00001000>,
+			<0x00168000 0x00001000>,
+			<0x00169000 0x00001000>;
+		reg-names = "adxcvr", "adxcfg-0", "adxcfg-1";
+
+		clocks = <&clk0_ad9528 11>, <&rx_os_device_clk_pll_n4>;
+		clock-names = "ref", "link";
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd204_rx_os_lane_clock_n4";
+	};
+
+	axi_ad9371_tx_dma_n4: axi-ad9371-tx-dma-n4@14c000 {
+		compatible = "adi,axi-dmac-1.00.a";
+		reg = <0x0014c000 0x00004000>;
+		interrupt-parent = <&intc>;
+		interrupts = <0 45 IRQ_TYPE_LEVEL_HIGH>;
+		#dma-cells = <1>;
+		clocks = <&dma_clk>;
+
+		dma-channel {
+			adi,source-bus-width = <128>;
+			adi,destination-bus-width = <128>;
+			adi,type = <1>;
+			adi,cyclic;
+		};
+	};
+
+	axi_ad9371_rx_dma_n4: axi-ad9371-rx-dma-n4@15c000 {
+		compatible = "adi,axi-dmac-1.00.a";
+		reg = <0x0015c000 0x00004000>;
+		interrupt-parent = <&intc>;
+		interrupts = <0 46 IRQ_TYPE_LEVEL_HIGH>;
+		#dma-cells = <1>;
+		clocks = <&dma_clk>;
+
+		dma-channel {
+			adi,source-bus-width = <64>;
+			adi,destination-bus-width = <128>;
+			adi,type = <0>;
+		};
+	};
+
+	axi_ad9371_rx_os_dma_n4: axi-ad9371-rx-os-dma-n4@16c000 {
+		compatible = "adi,axi-dmac-1.00.a";
+		reg = <0x0016c000 0x00004000>;
+		interrupt-parent = <&intc>;
+		interrupts = <0 47 IRQ_TYPE_LEVEL_HIGH>;
+		#dma-cells = <1>;
+		clocks = <&dma_clk>;
+
+		dma-channel {
+			adi,source-bus-width = <64>;
+			adi,destination-bus-width = <128>;
+			adi,type = <0>;
+		};
+	};
+
+	axi_ad9371_rx_n4: axi-ad9371-rx-hpc-n4@170000 {
+		compatible = "adi,axi-ad9371-rx-1.0";
+		reg = <0x00170000 0x00008000>;
+		dmas = <&axi_ad9371_rx_dma_n4 0>;
+		dma-names = "rx";
+		spibus-connected = <&trx0_ad9371_n4>;
+	};
+
+	axi_ad9371_tx_n4: axi-ad9371-tx-hpc-n4@174000 {
+		compatible = "adi,axi-ad9371-tx-1.0";
+		reg = <0x00174000 0x00004000>;
+		dmas = <&axi_ad9371_tx_dma_n4 0>;
+		dma-names = "tx";
+		clocks = <&trx0_ad9371_n4 2>;
+		clock-names = "sampl_clk";
+		spibus-connected = <&trx0_ad9371_n4>;
+		adi,axi-pl-fifo-enable;/* RxDMA fifo mode */
+		//adi,axi-pl-fifo-disable;
+	};
+
+	xcvr_rx_os_core_n4: axi-ad9371-rx-obs-hpc-n4@178000 {
+		compatible = "adi,axi-ad9371-obs-1.0";
+		reg = <0x00178000 0x00001000>;
+		dmas = <&axi_ad9371_rx_os_dma_n4 0>;
+		dma-names = "rx";
+		clocks = <&trx0_ad9371_n4 1>;
+		clock-names = "sampl_clk";
+	};
+
+	tx_device_clk_pll_n4: a10-fpll-tx-n4@145000 {
+		compatible = "altr,a10-fpll";
+		reg = <0x00145000 0x1000>;
+		clocks = <&clk0_ad9528 11>;
+
+		#clock-cells = <0>;
+		clock-output-names = "n4_jesd204_tx_link_clock";
+	};
+
+	rx_device_clk_pll_n4: a10-fpll-rx-n4@155000 {
+		compatible = "altr,a10-fpll";
+		reg = <0x00155000 0x1000>;
+		clocks = <&clk0_ad9528 11>;
+
+		#clock-cells = <0>;
+		clock-output-names = "n4_jesd204_rx_link_clock";
+	};
+
+	rx_os_device_clk_pll_n4: a10-fpll-rx-os-n4@165000 {
+		compatible = "altr,a10-fpll";
+		reg = <0x00165000 0x1000>;
+		clocks = <&clk0_ad9528 11>;
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd204_rx_os_link_clock_n4";
+	};
+
+	fmc_spi_n4: spi@120040 {
+		compatible = "altr,spi-1.0";
+		reg = <0x00120040 0x00000020>;
+		interrupt-parent = <&intc>;
+		interrupts = <0 49 IRQ_TYPE_LEVEL_HIGH>;
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+	};
+};
+
+&fmc_spi_n4 {
+	trx0_ad9371_n4: ad9371-phy-n4@1 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		#clock-cells = <1>;
+		compatible = "ad9371";
+
+		/* SPI Setup */
+		reg = <1>;
+		spi-max-frequency = <25000000>;
+
+		reset-gpios = <&sys_gpio_out 30 0>;
+		test-gpios = <&sys_gpio_out 0 0>;
+		sysref_req-gpios = <&sys_gpio_out 26 0>;
+		rx2_enable-gpios = <&sys_gpio_out 1 0>;
+		rx1_enable-gpios = <&sys_gpio_out 2 0>;
+		tx2_enable-gpios = <&sys_gpio_out 3 0>;
+		tx1_enable-gpios = <&sys_gpio_out 4 0>;
+
+		/* all interrupts in HW design should be reviewed */
+		//interrupt-parent = <&intc>;
+		//interrupts = <0 49 IRQ_TYPE_LEVEL_HIGH>;
+
+		/* Clocks */
+		clocks = <&axi_ad9371_rx_jesd_n4>, <&axi_ad9371_tx_jesd_n4>,
+			<&axi_ad9371_rx_os_jesd_n4>, <&clk0_ad9528 8>,
+			<&clk0_ad9528 11>;
+		clock-names = "jesd_rx_clk", "jesd_tx_clk",
+			"jesd_rx_os_clk", "dev_clk", "fmc_clk";
+		clock-output-names = "rx_sampl_clk_n4", "rx_os_sampl_clk_n4", "tx_sampl_clk_n4";
+
+		adi,clocks-clk-pll-vco-freq_khz = <9830400>;
+		adi,clocks-device-clock_khz = <122880>;
+		adi,clocks-clk-pll-hs-div = <4>;
+		adi,clocks-clk-pll-vco-div = <2>;
+
+		adi,jesd204-obs-framer-over-sample = <0>;
+
+		adi,rx-profile-adc-div = <1>;
+		adi,rx-profile-en-high-rej-dec5 = <1>;
+		adi,rx-profile-iq-rate_khz = <122880>;
+		adi,rx-profile-rf-bandwidth_hz = <100000000>;
+		adi,rx-profile-rhb1-decimation = <1>;
+		adi,rx-profile-rx-bbf-3db-corner_khz = <100000>;
+		adi,rx-profile-rx-dec5-decimation = <5>;
+		adi,rx-profile-rx-fir-decimation = <2>;
+
+		adi,rx-profile-rx-fir-gain_db = <(-6)>;
+		adi,rx-profile-rx-fir-num-fir-coefs = <48>;
+		adi,rx-profile-rx-fir-coefs = /bits/ 16 <(-5) (-26) (32) (51) (-67) (-116) (140) (212) (-252) (-367) (429) (595) (-688) (-931) (1072) (1427) (-1650) (-2188) (2612) (3496) (-4802) (-7591) (9656) (32317) (32317) (9656) (-7591) (-4802) (3496) (2612) (-2188) (-1650) (1427) (1072) (-931) (-688) (595) (429) (-367) (-252) (212) (140) (-116) (-67) (51) (32) (-26) (-5)>;
+
+		adi,rx-profile-custom-adc-profile = /bits/ 16  <534 386 201 98 1280 491 1591 279 1306 104 792 28 48 39 23 187>;
+
+		adi,obs-profile-adc-div = <1>;
+		adi,obs-profile-en-high-rej-dec5 = <1>;
+		adi,obs-profile-iq-rate_khz = <245760>;
+		adi,obs-profile-rf-bandwidth_hz = <200000000>;
+		adi,obs-profile-rhb1-decimation = <1>;
+		adi,obs-profile-rx-bbf-3db-corner_khz = <100000>;
+		adi,obs-profile-rx-dec5-decimation = <5>;
+		adi,obs-profile-rx-fir-decimation = <1>;
+
+		adi,obs-profile-rx-fir-gain_db = <6>;
+		adi,obs-profile-rx-fir-num-fir-coefs = <24>;
+		adi,obs-profile-rx-fir-coefs = /bits/ 16 <(-289) (81) (-23) (-86) (229) (-354) (397) (-233) (-657) (1699) (-4172) (23010) (-4172) (1699) (-657) (-233) (397) (-354) (229) (-86) (-23) (81) (-289) (0)>;
+
+		adi,obs-profile-custom-adc-profile = /bits/ 16  <450 349 201 98 1280 730 1626 818 1476 732 834 20 41 36 24 200>;
+		adi,obs-settings-custom-loopback-adc-profile = /bits/ 16  <569 369 201 98 1280 291 1541 149 1320 58 807 34 48 40 23 189>;
+
+		adi,tx-profile-dac-div = <1>;
+		adi,tx-profile-iq-rate_khz = <245760>;
+		adi,tx-profile-primary-sig-bandwidth_hz = <75000000>;
+		adi,tx-profile-rf-bandwidth_hz = <200000000>;
+		adi,tx-profile-thb1-interpolation = <2>;
+		adi,tx-profile-thb2-interpolation = <1>;
+		adi,tx-profile-tx-bbf-3db-corner_khz = <100000>;
+		adi,tx-profile-tx-dac-3db-corner_khz = <187000>;
+		adi,tx-profile-tx-fir-interpolation = <1>;
+		adi,tx-profile-tx-input-hb-interpolation = <1>;
+
+		adi,tx-profile-tx-fir-gain_db = <6>;
+		adi,tx-profile-tx-fir-num-fir-coefs = <16>;
+		adi,tx-profile-tx-fir-coefs = /bits/ 16 <(6) (-270) (203) (-168) (-84) (983) (-3222) (21143) (-3222) (983) (-84) (-168) (203) (-270) (6) (0)>;
+
+		adi,sniffer-profile-adc-div = <1>;
+		adi,sniffer-profile-en-high-rej-dec5 = <0>;
+		adi,sniffer-profile-iq-rate_khz = <30720>;
+		adi,sniffer-profile-rf-bandwidth_hz = <20000000>;
+		adi,sniffer-profile-rhb1-decimation = <2>;
+		adi,sniffer-profile-rx-bbf-3db-corner_khz = <100000>;
+		adi,sniffer-profile-rx-dec5-decimation = <5>;
+		adi,sniffer-profile-rx-fir-decimation = <4>;
+#if 0
+		/* Jacky:2018/07/25: enable pin-mode 
+		   https://wiki.analog.com/resources/tools-software/linux-drivers/iio-transceiver/ad9371-customization */
+		adi,arm-gpio-use-rx2-enable-pin = <1>;	// 0= RX1_ENABLE controls RX1&RX2, 1= separate RX1/RX2_ENABLE pins
+		adi,arm-gpio-use-tx2-enable-pin = <1>;	// 0= TX1_ENABLE controls TX1&TX2, 1= separate TX1/TX2_ENABLE pins
+		adi,arm-gpio-tx-rx-pin-mode = <1>;		// 0= ARM command mode, 1 = Pin mode to power up Tx/Rx chains
+		adi,arm-gpio-orx-pin-mode = <1>;		// 0= ARM command mode, 1 = Pin mode to power up ObsRx receiver
+		// to be tested: enable pin-mode but NOT enable gpio-ack
+		adi,arm-gpio-orx-trigger-pin = <0>;		// Select desired GPIO pin (valid 4-15)
+		adi,arm-gpio-orx-mode2-pin = <0>;		// Select desired GPIO pin (valid 0-18)
+		adi,arm-gpio-orx-mode1-pin = <0>;		// Select desired GPIO pin (valid 0-18)
+		adi,arm-gpio-orx-mode0-pin = <0>;		// Select desired GPIO pin (valid 0-18)
+		adi,arm-gpio-rx1-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-rx2-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-tx1-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-tx2-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-orx1-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-orx2-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-srx-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-tx-obs-select = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable.
+			// When 2 Tx are used with only 1 ORx input, this GPIO tells BBIC which Tx channel is active
+			// for calibrations, so BBIC can route correct RF Tx path into the single ORx input
+		adi,arm-gpio-enable-mask = <0>;
+#endif
+	};
+};
+
diff --git a/arch/arm/boot/dts/facc-a10ad9371x2.dts b/arch/arm/boot/dts/facc-a10ad9371x2.dts
new file mode 100644
index 0000000..7500668
--- /dev/null
+++ b/arch/arm/boot/dts/facc-a10ad9371x2.dts
@@ -0,0 +1,118 @@
+/dts-v1/;
+#include "socfpga_arria10_socdk.dtsi"
+#include "i2c_dev_si5338.dtsi"
+#include "eth_altr_tse.dtsi"
+
+&mmc {
+	status = "okay";
+	num-slots = <1>;
+	cap-sd-highspeed;
+	broken-cd;
+	bus-width = <4>;
+	altr,dw-mshc-ciu-div = <3>;
+	altr,dw-mshc-sdr-timing = <0 3>;
+};
+
+/ {
+	clocks {
+		sys_clk: sys_clk {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <100000000>;
+			clock-output-names = "system_clock";
+		};
+
+		dma_clk: dma_clk {
+			#clock-cells = <0x0>;
+			compatible = "fixed-clock";
+			clock-frequency = <250000000>;
+			clock-output-names = "dma_clk";
+		};
+	};
+
+	soc {
+		sys_hps_bridges: bridge@ff200000 {
+			compatible = "simple-bus";
+			reg = <0xff200000 0x00200000>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges = <0x00000000 0xff200000 0x00200000>;
+
+			sys_gpio_out: gpioctrl@20 {
+				compatible = "altr,pio-1.0";
+				reg = <0x00000020 0x00000010>;
+				altr,gpio-bank-width = <32>;
+				resetvalue = <0>;
+				#gpio-cells = <2>;
+				gpio-controller;
+			};
+
+			/* Documentation/devicetree/bindings/interrupt-controller/arm,gic.txt */
+			/* Documentation/devicetree/bindings/gpio/gpio-altera.txt */
+			sys_gpio_in: gpioctrl@0 {
+				gpio-controller;
+				reg = <0x00000000 0x10>;
+				altr,gpio-bank-width = <32>;
+				resetvalue = <0>;
+				#gpio-cells = <2>;
+				compatible = "altr,pio-1.0";
+
+				/* gpioin31irq */
+	   			interrupt-controller;
+				gpios = <&sys_gpio_in 31 0>;
+				/* irq-type irq-number low-to-high-edge */
+				/* irq-number = 24(FPGA_IRQ_BASE) + specific irq vector */
+	   			interrupts = <0 24 IRQ_TYPE_EDGE_RISING>;
+	   			#interrupt-cells = <1>;
+	   			altr,interrupt-type = <IRQ_TYPE_EDGE_RISING>;
+			};
+
+			/* Documentation/devicetree/bindings/pps/pps-gpio.txt  */
+			pps_gpioin31: pps_gpio@31 {
+				compatible = "pps-gpio";
+				gpios = <&sys_gpio_in 31 0>;
+				/* comment means assert is indicated by a rising edge */
+				assert-rising-edge;
+			};
+
+			sys_spi: spi@40 {
+				compatible = "altr,spi-1.0";
+				reg = <0x00000040 0x00000020>;
+				interrupt-parent = <&intc>;
+				interrupts = <0 26 IRQ_TYPE_LEVEL_HIGH>;
+				#address-cells = <0x1>;
+				#size-cells = <0x0>;
+
+				clkgen_lmk04828: clkgen@3 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					//compatible = "spidev";
+					compatible = "ti,lmk04828";
+
+					reg = <3>;
+					//spi-3wire; /* HW design is 4wire mode */
+					spi-max-frequency = <10000000>;
+				};
+			};
+		};
+	};
+};
+
+#define fmc_spi sys_spi
+
+&fmc_spi {
+	clksyn_ad9548: clksyn@2 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		//compatible = "spidev";
+		compatible = "adi,ad9548";
+
+		reg = <2>;
+		//spi-3wire; /* HW design is 4wire mode */
+		spi-max-frequency = <10000000>;
+	};
+};
+
+#include "facc-a10ad9528.dtsi"
+#include "facc-a10ad9371n1.dtsi"
+#include "facc-a10ad9371n2.dtsi"
diff --git a/arch/arm/boot/dts/facc-a10ad9371x4dma.dts b/arch/arm/boot/dts/facc-a10ad9371x4dma.dts
new file mode 100644
index 0000000..c508745
--- /dev/null
+++ b/arch/arm/boot/dts/facc-a10ad9371x4dma.dts
@@ -0,0 +1,120 @@
+/dts-v1/;
+#include "socfpga_arria10_socdk.dtsi"
+#include "i2c_dev_si5338.dtsi"
+//#include "eth_altr_tse.dtsi" /* no TSE in this FPGA-design version */
+
+&mmc {
+	status = "okay";
+	num-slots = <1>;
+	cap-sd-highspeed;
+	broken-cd;
+	bus-width = <4>;
+	altr,dw-mshc-ciu-div = <3>;
+	altr,dw-mshc-sdr-timing = <0 3>;
+};
+
+/ {
+	clocks {
+		sys_clk: sys_clk {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <100000000>;
+			clock-output-names = "system_clock";
+		};
+
+		dma_clk: dma_clk {
+			#clock-cells = <0x0>;
+			compatible = "fixed-clock";
+			clock-frequency = <250000000>;
+			clock-output-names = "dma_clk";
+		};
+	};
+
+	soc {
+		sys_hps_bridges: bridge@ff200000 {
+			compatible = "simple-bus";
+			reg = <0xff200000 0x00200000>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges = <0x00000000 0xff200000 0x00200000>;
+
+			sys_gpio_out: gpioctrl@20 {
+				compatible = "altr,pio-1.0";
+				reg = <0x00000020 0x00000010>;
+				altr,gpio-bank-width = <32>;
+				resetvalue = <0>;
+				#gpio-cells = <2>;
+				gpio-controller;
+			};
+
+			/* Documentation/devicetree/bindings/interrupt-controller/arm,gic.txt */
+			/* Documentation/devicetree/bindings/gpio/gpio-altera.txt */
+			sys_gpio_in: gpioctrl@0 {
+				gpio-controller;
+				reg = <0x00000000 0x10>;
+				altr,gpio-bank-width = <32>;
+				resetvalue = <0>;
+				#gpio-cells = <2>;
+				compatible = "altr,pio-1.0";
+
+				/* gpioin31irq */
+	   			interrupt-controller;
+				gpios = <&sys_gpio_in 31 0>;
+				/* irq-type irq-number low-to-high-edge */
+				/* irq-number = 24(FPGA_IRQ_BASE) + specific irq vector */
+	   			interrupts = <0 24 IRQ_TYPE_EDGE_RISING>;
+	   			#interrupt-cells = <1>;
+	   			altr,interrupt-type = <IRQ_TYPE_EDGE_RISING>;
+			};
+
+			/* Documentation/devicetree/bindings/pps/pps-gpio.txt  */
+			pps_gpioin31: pps_gpio@31 {
+				compatible = "pps-gpio";
+				gpios = <&sys_gpio_in 31 0>;
+				/* comment means assert is indicated by a rising edge */
+				assert-rising-edge;
+			};
+
+			sys_spi: spi@40 {
+				compatible = "altr,spi-1.0";
+				reg = <0x00000040 0x00000020>;
+				interrupt-parent = <&intc>;
+				interrupts = <0 26 IRQ_TYPE_LEVEL_HIGH>;
+				#address-cells = <0x1>;
+				#size-cells = <0x0>;
+
+				clkgen_lmk04828: clkgen@3 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					//compatible = "spidev";
+					compatible = "ti,lmk04828";
+
+					reg = <3>;
+					//spi-3wire; /* HW design is 4wire mode */
+					spi-max-frequency = <10000000>;
+				};
+			};
+		};
+	};
+};
+
+#define fmc_spi sys_spi
+
+&fmc_spi {
+	clksyn_ad9548: clksyn@2 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		//compatible = "spidev";
+		compatible = "adi,ad9548";
+
+		reg = <2>;
+		//spi-3wire; /* HW design is 4wire mode */
+		spi-max-frequency = <10000000>;
+	};
+};
+
+#include "facc-a10ad9528.dtsi"
+#include "facc-a10ad9371n1dma.dtsi"
+#include "facc-a10ad9371n2dma.dtsi"
+#include "facc-a10ad9371n3dma.dtsi"
+#include "facc-a10ad9371n4dma.dtsi"
diff --git a/arch/arm/boot/dts/facc-a10ad9528.dtsi b/arch/arm/boot/dts/facc-a10ad9528.dtsi
new file mode 100644
index 0000000..5ec5cab
--- /dev/null
+++ b/arch/arm/boot/dts/facc-a10ad9528.dtsi
@@ -0,0 +1,170 @@
+
+#include <dt-bindings/iio/frequency/ad9528.h>
+
+/ {
+	clocks {
+		ad9371_clkin: clock@0 {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <12288000>;
+			clock-output-names = "ad9371_ext_refclk";
+		};
+	};
+};
+
+&sys_spi {
+	clk0_ad9528: ad9528-1@0 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		#clock-cells = <1>;
+		compatible = "ad9528";
+
+		spi-max-frequency = <10000000>;
+		//adi,spi-3wire-enable;
+		reg = <0>;
+
+		reset-gpios = <&sys_gpio_out 27 0>;
+
+		clock-output-names = "ad9528-1_out0", "ad9528-1_out1", "ad9528-1_out2", "ad9528-1_out3", "ad9528-1_out4", "ad9528-1_out5", "ad9528-1_out6", "ad9528-1_out7", "ad9528-1_out8", "ad9528-1_out9", "ad9528-1_out10", "ad9528-1_out11", "ad9528-1_out12", "ad9528-1_out13";
+		adi,vcxo-freq = <122880000>;
+
+		adi,refa-enable;
+		adi,refa-diff-rcv-enable;
+		adi,refa-r-div = <1>;
+		adi,osc-in-cmos-neg-inp-enable;
+
+		/* PLL1 config */
+		adi,pll1-feedback-div = <1>;/* change from 4 to 1 per RF, 2018/11/01 */
+		adi,pll1-charge-pump-current-nA = <5000>;
+
+		/* PLL2 config */
+		adi,pll2-vco-div-m1 = <3>; /* use 5 for 184320000 output device clock */
+		adi,pll2-n2-div = <10>; /* N / M1 */
+		adi,pll2-r1-div = <1>;
+		adi,pll2-charge-pump-current-nA = <805000>;
+
+		/* SYSREF config */
+		adi,sysref-src = <SYSREF_SRC_INTERNAL>;/* SYSREF Mode3: Internal */
+		adi,sysref-pattern-mode = <SYSREF_PATTERN_CONTINUOUS>;
+		adi,sysref-k-div = <512>;
+		/* [0x0402]bit7: SYSREF request method: 1/hardware(SYSREF_REQ), 0/software(SPI-interface) */
+		//adi,sysref-request-enable;
+		adi,sysref-nshot-mode = <SYSREF_NSHOT_4_PULSES>;
+		adi,sysref-request-trigger-mode = <SYSREF_LEVEL_HIGH>;
+
+		adi,rpole2 = <RPOLE2_900_OHM>;
+		adi,rzero = <RZERO_1850_OHM>;
+		adi,cpole1 = <CPOLE1_16_PF>;
+
+		adi,status-mon-pin0-function-select = <1>; /* PLL1 & PLL2 Locked */
+		adi,status-mon-pin1-function-select = <7>; /* REFA Correct */
+
+		ad9528_0_c6: channel@6 {
+			reg = <6>;
+			adi,extended-name = "DEV_CLK_N1";
+			adi,driver-mode = <DRIVER_MODE_LVDS>;
+			adi,divider-phase = <0>;
+			adi,channel-divider = <10>;
+			adi,signal-source = <SOURCE_VCO>;
+		};
+
+		ad9528_0_c3: channel@3 {
+			reg = <3>;
+			adi,extended-name = "FMC_CLK_M1";
+			adi,driver-mode = <DRIVER_MODE_LVDS>;
+			adi,divider-phase = <0>;
+			adi,channel-divider = <10>;
+			adi,signal-source = <SOURCE_VCO>;
+		};
+
+		ad9528_0_c5: channel@5 {
+			reg = <5>;
+			adi,extended-name = "DEV_SYSREF_N1";
+			adi,driver-mode = <DRIVER_MODE_LVDS>;
+			adi,divider-phase = <0>;
+			adi,channel-divider = <10>;
+			adi,signal-source = <SOURCE_SYSREF_VCO>;
+		};
+
+		ad9528_0_c2: channel@2 {
+			reg = <2>;
+			adi,extended-name = "FMC_SYSREF_M1";
+			adi,driver-mode = <DRIVER_MODE_LVDS>;
+			adi,divider-phase = <0>;
+			adi,channel-divider = <10>;
+			adi,signal-source = <SOURCE_SYSREF_VCO>;
+		};
+
+		ad9528_0_c0: channel@0 {
+			reg = <0>;
+			adi,extended-name = "DEV_SYSREF_N2";
+			adi,driver-mode = <DRIVER_MODE_LVDS>;
+			adi,divider-phase = <0>;
+			adi,channel-divider = <10>;
+			adi,signal-source = <SOURCE_SYSREF_VCO>;
+		};
+
+		ad9528_0_c1: channel@1 {
+			reg = <1>;
+			adi,extended-name = "DEV_CLK_N2";
+			adi,driver-mode = <DRIVER_MODE_LVDS>;
+			adi,divider-phase = <0>;
+			adi,channel-divider = <10>;
+			adi,signal-source = <SOURCE_VCO>;
+		};
+
+		ad9528_0_c7: channel@7 {
+			reg = <7>;
+			adi,extended-name = "DEV_SYSREF_N4";
+			adi,driver-mode = <DRIVER_MODE_LVDS>;
+			adi,divider-phase = <0>;
+			adi,channel-divider = <10>;
+			adi,signal-source = <SOURCE_SYSREF_VCO>;
+		};
+
+		ad9528_0_c8: channel@8 {
+			reg = <8>;
+			adi,extended-name = "DEV_CLK_N4";
+			adi,driver-mode = <DRIVER_MODE_LVDS>;
+			adi,divider-phase = <0>;
+			adi,channel-divider = <10>;
+			adi,signal-source = <SOURCE_VCO>;
+		};
+
+		ad9528_0_c12: channel@12 {
+			reg = <12>;
+			adi,extended-name = "DEV_SYSREF_N3";
+			adi,driver-mode = <DRIVER_MODE_LVDS>;
+			adi,divider-phase = <0>;
+			adi,channel-divider = <10>;
+			adi,signal-source = <SOURCE_SYSREF_VCO>;
+		};
+
+		ad9528_0_c13: channel@13 {
+			reg = <13>;
+			adi,extended-name = "DEV_CLK_N3";
+			adi,driver-mode = <DRIVER_MODE_LVDS>;
+			adi,divider-phase = <0>;
+			adi,channel-divider = <10>;
+			adi,signal-source = <SOURCE_VCO>;
+		};
+
+		ad9528_0_c9: channel@9 {
+			reg = <9>;
+			adi,extended-name = "FMC_SYSREF_M2";
+			adi,driver-mode = <DRIVER_MODE_LVDS>;
+			adi,divider-phase = <0>;
+			adi,channel-divider = <10>;
+			adi,signal-source = <SOURCE_SYSREF_VCO>;
+		};
+
+		ad9528_0_c11: channel@11 {
+			reg = <11>;
+			adi,extended-name = "FMC_CLK_M2";
+			adi,driver-mode = <DRIVER_MODE_LVDS>;
+			adi,divider-phase = <0>;
+			adi,channel-divider = <10>;
+			adi,signal-source = <SOURCE_VCO>;
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/facc-adrv9009.dtsi b/arch/arm/boot/dts/facc-adrv9009.dtsi
new file mode 100644
index 0000000..517a2d7
--- /dev/null
+++ b/arch/arm/boot/dts/facc-adrv9009.dtsi
@@ -0,0 +1,468 @@
+
+#include <dt-bindings/iio/frequency/ad9528.h>
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/interrupt-controller/irq.h>
+
+/ {
+	clocks {
+		adrv9009_clkin: clock@0 {
+			compatible = "fixed-clock";
+
+			clock-frequency = <12288000>;
+			clock-output-names = "adrv9009_ext_refclk";
+			#clock-cells = <0>;
+		};
+	};
+};
+
+&fmc_spi {
+
+	clk0_ad9528: ad9528-1@0 {
+		compatible = "adi,ad9528";
+		reg = <0>;
+
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		//spi-max-frequency = <10000000>;
+		spi-max-frequency = <500000>;
+		//adi,spi-3wire-enable;
+
+		clock-output-names = "ad9528-1_out0", "ad9528-1_out1", "ad9528-1_out2",
+			"ad9528-1_out3", "ad9528-1_out4", "ad9528-1_out5", "ad9528-1_out6",
+			"ad9528-1_out7", "ad9528-1_out8", "ad9528-1_out9", "ad9528-1_out10",
+			"ad9528-1_out11", "ad9528-1_out12", "ad9528-1_out13";
+		#clock-cells = <1>;
+
+		adi,vcxo-freq = <122880000>;
+
+		adi,refa-enable;
+		adi,refa-diff-rcv-enable;
+		adi,refa-r-div = <1>;
+		adi,osc-in-cmos-neg-inp-enable;
+
+		/* PLL1 config */
+		adi,pll1-feedback-div = <4>;
+		adi,pll1-charge-pump-current-nA = <5000>;
+
+		/* PLL2 config */
+		adi,pll2-vco-div-m1 = <3>; /* use 5 for 184320000 output device clock */
+		adi,pll2-n2-div = <10>; /* N / M1 */
+		adi,pll2-r1-div = <1>;
+		adi,pll2-charge-pump-current-nA = <805000>;
+
+		/* SYSREF config */
+		adi,sysref-src = <SYSREF_SRC_INTERNAL>;
+		adi,sysref-pattern-mode = <SYSREF_PATTERN_CONTINUOUS>;
+		adi,sysref-k-div = <512>;
+		adi,sysref-request-enable;
+		adi,sysref-nshot-mode = <SYSREF_NSHOT_4_PULSES>;
+		adi,sysref-request-trigger-mode = <SYSREF_LEVEL_HIGH>;
+
+		adi,rpole2 = <RPOLE2_900_OHM>;
+		adi,rzero = <RZERO_1850_OHM>;
+		adi,cpole1 = <CPOLE1_16_PF>;
+
+		adi,status-mon-pin0-function-select = <1>; /* PLL1 & PLL2 Locked */
+		adi,status-mon-pin1-function-select = <7>; /* REFA Correct */
+
+		ad9528_0_c13: channel@13 {
+			reg = <13>;
+			adi,extended-name = "DEV_CLK";
+			adi,driver-mode = <DRIVER_MODE_LVDS>;
+			adi,divider-phase = <0>;
+			adi,channel-divider = <5>;
+			adi,signal-source = <SOURCE_VCO>;
+		};
+
+		ad9528_0_c1: channel@1 {
+			reg = <1>;
+			adi,extended-name = "FMC_CLK";
+			adi,driver-mode = <DRIVER_MODE_LVDS>;
+			adi,divider-phase = <0>;
+			adi,channel-divider = <5>;
+			adi,signal-source = <SOURCE_VCO>;
+		};
+
+		ad9528_0_c12: channel@12 {
+			reg = <12>;
+			adi,extended-name = "DEV_SYSREF";
+			adi,driver-mode = <DRIVER_MODE_LVDS>;
+			adi,divider-phase = <0>;
+			adi,channel-divider = <5>;
+			adi,signal-source = <SOURCE_SYSREF_VCO>;
+		};
+
+		ad9528_0_c3: channel@3 {
+			reg = <3>;
+			adi,extended-name = "FMC_SYSREF";
+			adi,driver-mode = <DRIVER_MODE_LVDS>;
+			adi,divider-phase = <0>;
+			adi,channel-divider = <5>;
+			adi,signal-source = <SOURCE_SYSREF_VCO>;
+		};
+	};
+
+	trx0_adrv9009: adrv9009-phy@1 {
+		compatible = "adi,adrv9009";
+		reg = <1>;
+
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		/* SPI Setup */
+		spi-max-frequency = <25000000>;
+
+		interrupt-parent = <&gpio0>;
+		interrupts = <105 IRQ_TYPE_EDGE_RISING>;
+
+		/* Clocks */
+		clocks = <&axi_adrv9009_rx_jesd>, <&axi_adrv9009_tx_jesd>,
+			<&axi_adrv9009_rx_os_jesd>, <&clk0_ad9528 13>,
+			<&clk0_ad9528 1>, <&clk0_ad9528 12>, <&clk0_ad9528 3>;
+		clock-names = "jesd_rx_clk", "jesd_tx_clk", "jesd_rx_os_clk",
+			"dev_clk", "fmc_clk", "sysref_dev_clk",
+			"sysref_fmc_clk";
+
+		clock-output-names = "rx_sampl_clk", "rx_os_sampl_clk", "tx_sampl_clk";
+		#clock-cells = <1>;
+
+		/* JESD204 */
+
+		/* JESD204 RX */
+		adi,jesd204-framer-a-bank-id = <1>;
+		adi,jesd204-framer-a-device-id = <0>;
+		adi,jesd204-framer-a-lane0-id = <0>;
+		adi,jesd204-framer-a-m = <4>;
+		adi,jesd204-framer-a-k = <32>;
+		adi,jesd204-framer-a-f = <4>;
+		adi,jesd204-framer-a-np = <16>;
+		adi,jesd204-framer-a-scramble = <1>;
+		adi,jesd204-framer-a-external-sysref = <1>;
+		adi,jesd204-framer-a-serializer-lanes-enabled = <0x03>;
+		adi,jesd204-framer-a-serializer-lane-crossbar = <0xE4>;
+		adi,jesd204-framer-a-lmfc-offset = <31>;
+		adi,jesd204-framer-a-new-sysref-on-relink = <0>;
+		adi,jesd204-framer-a-syncb-in-select = <0>;
+		adi,jesd204-framer-a-over-sample = <0>;
+		adi,jesd204-framer-a-syncb-in-lvds-mode = <1>;
+		adi,jesd204-framer-a-syncb-in-lvds-pn-invert = <0>;
+		adi,jesd204-framer-a-enable-manual-lane-xbar = <0>;
+
+		/* JESD204 OBS */
+		adi,jesd204-framer-b-bank-id = <0>;
+		adi,jesd204-framer-b-device-id = <0>;
+		adi,jesd204-framer-b-lane0-id = <0>;
+		adi,jesd204-framer-b-m = <2>;
+		adi,jesd204-framer-b-k = <32>;
+		adi,jesd204-framer-b-f = <2>;
+		adi,jesd204-framer-b-np = <16>;
+		adi,jesd204-framer-b-scramble = <1>;
+		adi,jesd204-framer-b-external-sysref = <1>;
+		adi,jesd204-framer-b-serializer-lanes-enabled = <0x0C>;
+		adi,jesd204-framer-b-serializer-lane-crossbar = <0xE4>;
+		adi,jesd204-framer-b-lmfc-offset = <31>;
+		adi,jesd204-framer-b-new-sysref-on-relink = <0>;
+		adi,jesd204-framer-b-syncb-in-select = <1>;
+		adi,jesd204-framer-b-over-sample = <0>;
+		adi,jesd204-framer-b-syncb-in-lvds-mode = <1>;
+		adi,jesd204-framer-b-syncb-in-lvds-pn-invert = <0>;
+		adi,jesd204-framer-b-enable-manual-lane-xbar = <0>;
+
+		/* JESD204 TX */
+		adi,jesd204-deframer-a-bank-id = <0>;
+		adi,jesd204-deframer-a-device-id = <0>;
+		adi,jesd204-deframer-a-lane0-id = <0>;
+		adi,jesd204-deframer-a-m = <4>;
+		adi,jesd204-deframer-a-k = <32>;
+		adi,jesd204-deframer-a-scramble = <1>;
+		adi,jesd204-deframer-a-external-sysref = <1>;
+		adi,jesd204-deframer-a-deserializer-lanes-enabled = <0x0F>;
+		adi,jesd204-deframer-a-deserializer-lane-crossbar = <0xE4>;
+		adi,jesd204-deframer-a-lmfc-offset = <17>;
+		adi,jesd204-deframer-a-new-sysref-on-relink = <0>;
+		adi,jesd204-deframer-a-syncb-out-select = <0>;
+		adi,jesd204-deframer-a-np = <16>;
+		adi,jesd204-deframer-a-syncb-out-lvds-mode = <1>;
+		adi,jesd204-deframer-a-syncb-out-lvds-pn-invert = <0>;
+		adi,jesd204-deframer-a-syncb-out-cmos-slew-rate = <0>;
+		adi,jesd204-deframer-a-syncb-out-cmos-drive-level = <0>;
+		adi,jesd204-deframer-a-enable-manual-lane-xbar = <0>;
+
+		adi,jesd204-ser-amplitude = <15>;
+		adi,jesd204-ser-pre-emphasis = <1>;
+		adi,jesd204-ser-invert-lane-polarity = <0>;
+		adi,jesd204-des-invert-lane-polarity = <0>;
+		adi,jesd204-des-eq-setting = <1>;
+		adi,jesd204-sysref-lvds-mode = <1>;
+		adi,jesd204-sysref-lvds-pn-invert = <0>;
+
+		/* RX */
+
+		adi,rx-profile-rx-fir-gain_db = <(-6)>;
+		adi,rx-profile-rx-fir-num-fir-coefs = <48>;
+		adi,rx-profile-rx-fir-coefs = /bits/ 16 <(-2) (23) (46) (-17) (-104) (10) (208) (23) (-370) (-97) (607) (240) (-942) (-489) (1407) (910) (-2065) (-1637) (3058) (2995) (-4912) (-6526) (9941) (30489) (30489) (9941) (-6526) (-4912) (2995) (3058) (-1637) (-2065) (910) (1407) (-489) (-942) (240) (607) (-97) (-370) (23) (208) (10) (-104) (-17) (46) (23) (-2)>;
+
+		adi,rx-profile-rx-fir-decimation = <2>;
+		adi,rx-profile-rx-dec5-decimation = <4>;
+		adi,rx-profile-rhb1-decimation = <1>;
+		adi,rx-profile-rx-output-rate_khz = <245760>;
+		adi,rx-profile-rf-bandwidth_hz = <200000000>;
+		adi,rx-profile-rx-bbf3d-bcorner_khz = <200000>;
+		adi,rx-profile-rx-adc-profile = /bits/ 16 <182 142 173 90 1280 982 1335 96 1369 48 1012 18 48 48 37 208 0 0 0 0 52 0 7 6 42 0 7 6 42 0 25 27 0 0 25 27 0 0 165 44 31 905>;
+		adi,rx-profile-rx-ddc-mode = <0>;
+
+		adi,rx-nco-shifter-band-a-input-band-width_khz = <0>;
+		adi,rx-nco-shifter-band-a-input-center-freq_khz = <0>;
+		adi,rx-nco-shifter-band-a-nco1-freq_khz = <0>;
+		adi,rx-nco-shifter-band-a-nco2-freq_khz = <0>;
+		adi,rx-nco-shifter-band-binput-band-width_khz = <0>;
+		adi,rx-nco-shifter-band-binput-center-freq_khz = <0>;
+		adi,rx-nco-shifter-band-bnco1-freq_khz = <0>;
+		adi,rx-nco-shifter-band-bnco2-freq_khz = <0>;
+
+		adi,rx-gain-control-gain-mode = <0>;
+		adi,rx-gain-control-rx1-gain-index = <255>;
+		adi,rx-gain-control-rx2-gain-index = <255>;
+		adi,rx-gain-control-rx1-max-gain-index = <255>;
+		adi,rx-gain-control-rx1-min-gain-index = <195>;
+		adi,rx-gain-control-rx2-max-gain-index = <255>;
+		adi,rx-gain-control-rx2-min-gain-index = <195>;
+
+		adi,rx-settings-framer-sel = <0>;
+		adi,rx-settings-rx-channels = <3>;
+
+		/* ORX */
+
+		adi,orx-profile-rx-fir-gain_db = <6>;
+		adi,orx-profile-rx-fir-num-fir-coefs = <24>;
+		adi,orx-profile-rx-fir-coefs = /bits/ 16  <(-10) (7) (-10) (-12) (6) (-12) (16) (-16) (1) (63) (-431) (17235) (-431) (63) (1) (-16) (16) (-12) (6) (-12) (-10) (7) (-10) (0)>;
+		adi,orx-profile-rx-fir-decimation = <1>;
+		adi,orx-profile-rx-dec5-decimation = <4>;
+		adi,orx-profile-rhb1-decimation = <2>;
+		adi,orx-profile-orx-output-rate_khz = <245760>;
+		adi,orx-profile-rf-bandwidth_hz = <200000000>;
+		adi,orx-profile-rx-bbf3d-bcorner_khz = <225000>;
+		adi,orx-profile-orx-low-pass-adc-profile = /bits/ 16  <185 141 172 90 1280 942 1332 90 1368 46 1016 19 48 48 37 208 0 0 0 0 52 0 7 6 42 0 7 6 42 0 25 27 0 0 25 27 0 0 165 44 31 905>;
+		adi,orx-profile-orx-band-pass-adc-profile = /bits/ 16  <0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0>;
+		adi,orx-profile-orx-ddc-mode = <0>;
+		adi,orx-profile-orx-merge-filter = /bits/ 16  <0 0 0 0 0 0 0 0 0 0 0 0>;
+
+		adi,orx-gain-control-gain-mode = <0>;
+		adi,orx-gain-control-orx1-gain-index = <255>;
+		adi,orx-gain-control-orx2-gain-index = <255>;
+		adi,orx-gain-control-orx1-max-gain-index = <255>;
+		adi,orx-gain-control-orx1-min-gain-index = <195>;
+		adi,orx-gain-control-orx2-max-gain-index = <255>;
+		adi,orx-gain-control-orx2-min-gain-index = <195>;
+
+		adi,obs-settings-framer-sel = <1>;
+		adi,obs-settings-obs-rx-channels-enable = <3>;
+		adi,obs-settings-obs-rx-lo-source = <0>;
+
+		/* TX */
+
+		adi,tx-profile-tx-fir-gain_db = <6>;
+		adi,tx-profile-tx-fir-num-fir-coefs = <40>;
+		adi,tx-profile-tx-fir-coefs = /bits/ 16  <(-14) (5) (-9) (6) (-4) (19) (-29) (27) (-30) (46) (-63) (77) (-103) (150) (-218) (337) (-599) (1266) (-2718) (19537) (-2718) (1266) (-599) (337) (-218) (150) (-103) (77) (-63) (46) (-30) (27) (-29) (19) (-4) (6) (-9) (5) (-14) (0)>;
+
+		adi,tx-profile-dac-div = <1>;
+
+		adi,tx-profile-tx-fir-interpolation = <1>;
+		adi,tx-profile-thb1-interpolation = <2>;
+		adi,tx-profile-thb2-interpolation = <2>;
+		adi,tx-profile-thb3-interpolation = <2>;
+		adi,tx-profile-tx-int5-interpolation = <1>;
+		adi,tx-profile-tx-input-rate_khz = <245760>;
+		adi,tx-profile-primary-sig-bandwidth_hz = <100000000>;
+		adi,tx-profile-rf-bandwidth_hz = <225000000>;
+		adi,tx-profile-tx-dac3d-bcorner_khz = <225000>;
+		adi,tx-profile-tx-bbf3d-bcorner_khz = <113000>;
+		adi,tx-profile-loop-back-adc-profile = /bits/ 16 <206 132 168 90 1280 641 1307 53 1359 28 1039 30 48 48 37 210 0 0 0 0 53 0 7 6 42 0 7 6 42 0 25 27 0 0 25 27 0 0 165 44 31 905>;
+
+		adi,tx-settings-deframer-sel = <0>;
+		adi,tx-settings-tx-channels = <3>;
+		adi,tx-settings-tx-atten-step-size = <0>;
+		adi,tx-settings-tx1-atten_md-b = <10000>;
+		adi,tx-settings-tx2-atten_md-b = <10000>;
+		adi,tx-settings-dis-tx-data-if-pll-unlock = <0>;
+
+		/* Clocks */
+
+		adi,dig-clocks-device-clock_khz = <245760>;
+		adi,dig-clocks-clk-pll-vco-freq_khz = <9830400>;
+		adi,dig-clocks-clk-pll-hs-div = <1>;
+		adi,dig-clocks-rf-pll-use-external-lo = <0>;
+		adi,dig-clocks-rf-pll-phase-sync-mode = <0>;
+
+		/* AGC */
+
+		adi,rxagc-peak-agc-under-range-low-interval_ns = <205>;
+		adi,rxagc-peak-agc-under-range-mid-interval = <2>;
+		adi,rxagc-peak-agc-under-range-high-interval = <4>;
+		adi,rxagc-peak-apd-high-thresh = <39>;
+		adi,rxagc-peak-apd-low-gain-mode-high-thresh = <36>;
+		adi,rxagc-peak-apd-low-thresh = <23>;
+		adi,rxagc-peak-apd-low-gain-mode-low-thresh = <19>;
+		adi,rxagc-peak-apd-upper-thresh-peak-exceeded-cnt = <6>;
+		adi,rxagc-peak-apd-lower-thresh-peak-exceeded-cnt = <3>;
+		adi,rxagc-peak-apd-gain-step-attack = <4>;
+		adi,rxagc-peak-apd-gain-step-recovery = <2>;
+		adi,rxagc-peak-enable-hb2-overload = <1>;
+		adi,rxagc-peak-hb2-overload-duration-cnt = <1>;
+		adi,rxagc-peak-hb2-overload-thresh-cnt = <4>;
+		adi,rxagc-peak-hb2-high-thresh = <181>;
+		adi,rxagc-peak-hb2-under-range-low-thresh = <45>;
+		adi,rxagc-peak-hb2-under-range-mid-thresh = <90>;
+		adi,rxagc-peak-hb2-under-range-high-thresh = <128>;
+		adi,rxagc-peak-hb2-upper-thresh-peak-exceeded-cnt = <6>;
+		adi,rxagc-peak-hb2-lower-thresh-peak-exceeded-cnt = <3>;
+		adi,rxagc-peak-hb2-gain-step-high-recovery = <2>;
+		adi,rxagc-peak-hb2-gain-step-low-recovery = <4>;
+		adi,rxagc-peak-hb2-gain-step-mid-recovery = <8>;
+		adi,rxagc-peak-hb2-gain-step-attack = <4>;
+		adi,rxagc-peak-hb2-overload-power-mode = <1>;
+		adi,rxagc-peak-hb2-ovrg-sel = <0>;
+		adi,rxagc-peak-hb2-thresh-config = <3>;
+
+		adi,rxagc-power-power-enable-measurement = <1>;
+		adi,rxagc-power-power-use-rfir-out = <1>;
+		adi,rxagc-power-power-use-bbdc2 = <0>;
+		adi,rxagc-power-under-range-high-power-thresh = <9>;
+		adi,rxagc-power-under-range-low-power-thresh = <2>;
+		adi,rxagc-power-under-range-high-power-gain-step-recovery = <4>;
+		adi,rxagc-power-under-range-low-power-gain-step-recovery = <4>;
+		adi,rxagc-power-power-measurement-duration = <5>;
+		adi,rxagc-power-rx1-tdd-power-meas-duration = <5>;
+		adi,rxagc-power-rx1-tdd-power-meas-delay = <1>;
+		adi,rxagc-power-rx2-tdd-power-meas-duration = <5>;
+		adi,rxagc-power-rx2-tdd-power-meas-delay = <1>;
+		adi,rxagc-power-upper0-power-thresh = <2>;
+		adi,rxagc-power-upper1-power-thresh = <0>;
+		adi,rxagc-power-power-log-shift = <0>;
+
+		adi,rxagc-agc-peak-wait-time = <4>;
+		adi,rxagc-agc-rx1-max-gain-index = <255>;
+		adi,rxagc-agc-rx1-min-gain-index = <195>;
+		adi,rxagc-agc-rx2-max-gain-index = <255>;
+		adi,rxagc-agc-rx2-min-gain-index = <195>;
+		adi,rxagc-agc-gain-update-counter_us = <250>;
+		adi,rxagc-agc-rx1-attack-delay = <10>;
+		adi,rxagc-agc-rx2-attack-delay = <10>;
+		adi,rxagc-agc-slow-loop-settling-delay = <16>;
+		adi,rxagc-agc-low-thresh-prevent-gain = <0>;
+		adi,rxagc-agc-change-gain-if-thresh-high = <1>;
+		adi,rxagc-agc-peak-thresh-gain-control-mode = <1>;
+		adi,rxagc-agc-reset-on-rxon = <0>;
+		adi,rxagc-agc-enable-sync-pulse-for-gain-counter = <0>;
+		adi,rxagc-agc-enable-ip3-optimization-thresh = <0>;
+		adi,rxagc-ip3-over-range-thresh = <31>;
+		adi,rxagc-ip3-over-range-thresh-index = <246>;
+		adi,rxagc-ip3-peak-exceeded-cnt = <4>;
+		adi,rxagc-agc-enable-fast-recovery-loop = <0>;
+
+
+		/* Misc */
+
+		adi,aux-dac-enables = <0x00>; /* Mask */
+
+		adi,aux-dac-vref0 = <3>;
+		adi,aux-dac-resolution0 = <0>;
+		adi,aux-dac-values0 = <0>;
+		adi,aux-dac-vref1 = <3>;
+		adi,aux-dac-resolution1 = <0>;
+		adi,aux-dac-values1 = <0>;
+		adi,aux-dac-vref2 = <3>;
+		adi,aux-dac-resolution2 = <0>;
+		adi,aux-dac-values2 = <0>;
+		adi,aux-dac-vref3 = <3>;
+		adi,aux-dac-resolution3 = <0>;
+		adi,aux-dac-values3 = <0>;
+		adi,aux-dac-vref4 = <3>;
+		adi,aux-dac-resolution4 = <0>;
+		adi,aux-dac-values4 = <0>;
+		adi,aux-dac-vref5 = <3>;
+		adi,aux-dac-resolution5 = <0>;
+		adi,aux-dac-values5 = <0>;
+		adi,aux-dac-vref6 = <3>;
+		adi,aux-dac-resolution6 = <0>;
+		adi,aux-dac-values6 = <0>;
+		adi,aux-dac-vref7 = <3>;
+		adi,aux-dac-resolution7 = <0>;
+		adi,aux-dac-values7 = <0>;
+		adi,aux-dac-vref8 = <3>;
+		adi,aux-dac-resolution8 = <0>;
+		adi,aux-dac-values8 = <0>;
+		adi,aux-dac-vref9 = <3>;
+		adi,aux-dac-resolution9 = <0>;
+		adi,aux-dac-values9 = <0>;
+		adi,aux-dac-vref10 = <3>;
+		adi,aux-dac-resolution10 = <0>;
+		adi,aux-dac-values10 = <0>;
+		adi,aux-dac-vref11 = <3>;
+		adi,aux-dac-resolution11 = <0>;
+		adi,aux-dac-values11 = <0>;
+
+		adi,arm-gpio-config-orx1-tx-sel0-pin-gpio-pin-sel = <0>;
+		adi,arm-gpio-config-orx1-tx-sel0-pin-polarity = <0>;
+		adi,arm-gpio-config-orx1-tx-sel0-pin-enable = <0>;
+
+		adi,arm-gpio-config-orx1-tx-sel1-pin-gpio-pin-sel = <0>;
+		adi,arm-gpio-config-orx1-tx-sel1-pin-polarity = <0>;
+		adi,arm-gpio-config-orx1-tx-sel1-pin-enable = <0>;
+		adi,arm-gpio-config-orx2-tx-sel0-pin-gpio-pin-sel = <0>;
+		adi,arm-gpio-config-orx2-tx-sel0-pin-polarity = <0>;
+		adi,arm-gpio-config-orx2-tx-sel0-pin-enable = <0>;
+
+		adi,arm-gpio-config-orx2-tx-sel1-pin-gpio-pin-sel = <0>;
+		adi,arm-gpio-config-orx2-tx-sel1-pin-polarity = <0>;
+		adi,arm-gpio-config-orx2-tx-sel1-pin-enable = <0>;
+		adi,arm-gpio-config-en-tx-tracking-cals-gpio-pin-sel = <0>;
+		adi,arm-gpio-config-en-tx-tracking-cals-polarity = <0>;
+		adi,arm-gpio-config-en-tx-tracking-cals-enable = <0>;
+
+		adi,orx-lo-cfg-disable-aux-pll-relocking = <0>;
+		adi,orx-lo-cfg-gpio-select = <19>;
+
+		adi,fhm-config-fhm-gpio-pin = <0>;
+		adi,fhm-config-fhm-min-freq_mhz = <100>;
+		adi,fhm-config-fhm-max-freq_mhz = <100>;
+
+		adi,fhm-mode-fhm-enable = <0>;
+		adi,fhm-mode-enable-mcs-sync = <0>;
+		adi,fhm-mode-fhm-trigger-mode = <0>;
+		adi,fhm-mode-fhm-exit-mode = <0>;
+		adi,fhm-mode-fhm-init-frequency_hz = <2450000000>;
+
+		adi,rx1-gain-ctrl-pin-inc-step = <1>;
+		adi,rx1-gain-ctrl-pin-dec-step = <1>;
+		adi,rx1-gain-ctrl-pin-rx-gain-inc-pin = <0>;
+		adi,rx1-gain-ctrl-pin-rx-gain-dec-pin = <1>;
+		adi,rx1-gain-ctrl-pin-enable = <0>;
+
+		adi,rx2-gain-ctrl-pin-inc-step = <1>;
+		adi,rx2-gain-ctrl-pin-dec-step = <1>;
+		adi,rx2-gain-ctrl-pin-rx-gain-inc-pin = <3>;
+		adi,rx2-gain-ctrl-pin-rx-gain-dec-pin = <4>;
+		adi,rx2-gain-ctrl-pin-enable = <0>;
+
+		adi,tx1-atten-ctrl-pin-step-size = <0>;
+		adi,tx1-atten-ctrl-pin-tx-atten-inc-pin = <4>;
+		adi,tx1-atten-ctrl-pin-tx-atten-dec-pin = <5>;
+		adi,tx1-atten-ctrl-pin-enable = <0>;
+
+		adi,tx2-atten-ctrl-pin-step-size = <0>;
+		adi,tx2-atten-ctrl-pin-tx-atten-inc-pin = <6>;
+		adi,tx2-atten-ctrl-pin-tx-atten-dec-pin = <7>;
+		adi,tx2-atten-ctrl-pin-enable = <0>;
+
+		adi,tx-pa-protection-avg-duration = <3>;
+		adi,tx-pa-protection-tx-atten-step = <2>;
+		adi,tx-pa-protection-tx1-power-threshold = <128>;
+		adi,tx-pa-protection-tx2-power-threshold = <128>;
+		adi,tx-pa-protection-peak-count = <4>;
+		adi,tx-pa-protection-tx1-peak-threshold = <16>;
+		adi,tx-pa-protection-tx2-peak-threshold = <16>;
+	};
+};
+
diff --git a/arch/arm/boot/dts/facc-zc706ad9009.dts b/arch/arm/boot/dts/facc-zc706ad9009.dts
new file mode 100644
index 0000000..c88cf7b
--- /dev/null
+++ b/arch/arm/boot/dts/facc-zc706ad9009.dts
@@ -0,0 +1,307 @@
+/dts-v1/;
+
+/include/ "zynq-zc706.dtsi"
+/include/ "zynq-zc706-adv7511.dtsi"
+
+
+
+&i2c_mux {
+	i2c@5 { /* HPC IIC */
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg = <5>;
+
+		eeprom@50 {
+			compatible = "at24,24c02";
+			reg = <0x50>;
+		};
+
+		eeprom@54 {
+			compatible = "at24,24c02";
+			reg = <0x54>;
+		};
+
+		ad7291@2f {
+			compatible = "adi,ad7291";
+			reg = <0x2f>;
+		};
+	};
+};
+
+&fpga_axi {
+	rx_dma: rx-dmac@7c400000 {
+		compatible = "adi,axi-dmac-1.00.a";
+		reg = <0x7c400000 0x10000>;
+		#dma-cells = <1>;
+		interrupts = <0 57 0>;
+		clocks = <&clkc 16>;
+
+		adi,channels {
+			#size-cells = <0>;
+			#address-cells = <1>;
+
+			dma-channel@0 {
+				reg = <0>;
+				adi,source-bus-width = <64>;
+				adi,source-bus-type = <2>;
+				adi,destination-bus-width = <64>;
+				adi,destination-bus-type = <0>;
+			};
+		};
+	};
+
+	rx_obs_dma: rx-obs-dmac@7c440000  {
+		compatible = "adi,axi-dmac-1.00.a";
+		reg = <0x7c440000  0x10000>;
+		#dma-cells = <1>;
+		interrupts = <0 55 0>;
+		clocks = <&clkc 16>;
+
+		adi,channels {
+			#size-cells = <0>;
+			#address-cells = <1>;
+
+			dma-channel@0 {
+				reg = <0>;
+				adi,source-bus-width = <64>;
+				adi,source-bus-type = <2>;
+				adi,destination-bus-width = <64>;
+				adi,destination-bus-type = <0>;
+			};
+		};
+	};
+
+	tx_dma: tx-dmac@7c420000 {
+		compatible = "adi,axi-dmac-1.00.a";
+		reg = <0x7c420000 0x10000>;
+		#dma-cells = <1>;
+		interrupts = <0 56 0>;
+		clocks = <&clkc 16>;
+
+		adi,channels {
+			#size-cells = <0>;
+			#address-cells = <1>;
+
+			dma-channel@0 {
+				reg = <0>;
+				adi,source-bus-width = <128>;
+				adi,source-bus-type = <0>;
+				adi,destination-bus-width = <128>;
+				adi,destination-bus-type = <2>;
+				adi,cyclic;
+			};
+		};
+	};
+
+	axi_adrv9009_core_rx: axi-adrv9009-rx-hpc@44a00000 {
+		compatible = "adi,axi-adrv9009-rx-1.0";
+		reg = <0x44a00000 0x8000>;
+		dmas = <&rx_dma 0>;
+		dma-names = "rx";
+		spibus-connected = <&trx0_adrv9009>;
+	};
+
+	axi_adrv9009_core_rx_obs: axi-adrv9009-rx-obs-hpc@44a08000 {
+		compatible = "adi,axi-adrv9009-obs-1.0";
+		reg = <0x44a08000 0x1000>;
+		dmas = <&rx_obs_dma 0>;
+		dma-names = "rx";
+		clocks = <&trx0_adrv9009 1>;
+		clock-names = "sampl_clk";
+	};
+
+	axi_adrv9009_core_tx: axi-adrv9009-tx-hpc@44a04000 {
+		compatible = "adi,axi-adrv9009-tx-1.0";
+		reg = <0x44a04000 0x4000>;
+		dmas = <&tx_dma 0>;
+		dma-names = "tx";
+		clocks = <&trx0_adrv9009 2>;
+		clock-names = "sampl_clk";
+		spibus-connected = <&trx0_adrv9009>;
+		//adi,axi-pl-fifo-enable;
+	};
+
+	axi_adrv9009_rx_jesd: axi-jesd204-rx@44aa0000 {
+		compatible = "adi,axi-jesd204-rx-1.0";
+		reg = <0x44aa0000 0x1000>;
+
+		interrupts = <0 54 0>;
+
+		clocks = <&clkc 16>, <&axi_rx_clkgen>, <&axi_adrv9009_adxcvr_rx 0>;
+		clock-names = "s_axi_aclk", "device_clk", "lane_clk";
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd_rx_lane_clk";
+
+		adi,octets-per-frame = <4>;
+		adi,frames-per-multiframe = <32>;
+	};
+
+	axi_adrv9009_tx_jesd: axi-jesd204-tx@44a90000 {
+		compatible = "adi,axi-jesd204-tx-1.0";
+		reg = <0x44a90000 0x1000>;
+
+		interrupts = <0 53 0>;
+
+		clocks = <&clkc 16>, <&axi_tx_clkgen>, <&axi_adrv9009_adxcvr_tx 0>;
+		clock-names = "s_axi_aclk", "device_clk", "lane_clk";
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd_tx_lane_clk";
+
+		adi,octets-per-frame = <2>;
+		adi,frames-per-multiframe = <32>;
+		adi,converter-resolution = <16>;
+		adi,bits-per-sample = <16>;
+		adi,converters-per-device = <4>;
+		adi,control-bits-per-sample = <0>;
+	};
+
+	axi_adrv9009_rx_os_jesd: axi-jesd204-rx-os@44ab0000 {
+		compatible = "adi,axi-jesd204-rx-1.0";
+		reg = <0x44ab0000 0x1000>;
+
+		interrupts = <0 52 0>;
+
+		clocks = <&clkc 16>, <&axi_rx_os_clkgen>, <&axi_adrv9009_adxcvr_rx_os 0>;
+		clock-names = "s_axi_aclk", "device_clk", "lane_clk";
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd_rx_os_lane_clk";
+
+		adi,octets-per-frame = <2>;
+		adi,frames-per-multiframe = <32>;
+	};
+
+	axi_tx_clkgen: axi-clkgen@43c00000  {
+		compatible = "adi,axi-clkgen-2.00.a";
+		reg = <0x43c00000 0x10000>;
+		#clock-cells = <0>;
+		clocks = <&clk0_ad9528 1>;
+		clock-output-names = "axi_tx_clkgen";
+	};
+
+	axi_rx_clkgen: axi-clkgen@43c10000  {
+		compatible = "adi,axi-clkgen-2.00.a";
+		reg = <0x43c10000 0x10000>;
+		#clock-cells = <0>;
+		clocks = <&clk0_ad9528 1>;
+		clock-output-names = "axi_rx_clkgen";
+	};
+
+	axi_rx_os_clkgen: axi-clkgen@43c20000  {
+		compatible = "adi,axi-clkgen-2.00.a";
+		reg = <0x43c20000 0x10000>;
+		#clock-cells = <0>;
+		clocks = <&clk0_ad9528 1>;
+		clock-output-names = "axi_rx_os_clkgen";
+	};
+
+	axi_adrv9009_adxcvr_rx: axi-adxcvr-rx@44a60000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "adi,axi-adxcvr-1.0";
+		reg = <0x44a60000 0x1000>;
+
+		clocks = <&clk0_ad9528 1>, <&axi_rx_clkgen 0>;
+		clock-names = "conv", "div40";
+
+		#clock-cells = <1>;
+		clock-output-names = "rx_gt_clk", "rx_out_clk";
+
+		adi,sys-clk-select = <0>;
+		adi,out-clk-select = <3>;
+		adi,use-lpm-enable;
+		adi,use-cpll-enable;
+	};
+
+	axi_adrv9009_adxcvr_rx_os: axi-adxcvr-rx-os@44a50000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "adi,axi-adxcvr-1.0";
+		reg = <0x44a50000 0x1000>;
+
+		clocks = <&clk0_ad9528 1>, <&axi_rx_os_clkgen>;
+		clock-names = "conv", "div40";
+
+		#clock-cells = <1>;
+		clock-output-names = "rx_os_gt_clk", "rx_os_out_clk";
+
+		adi,sys-clk-select = <0>;
+		adi,out-clk-select = <3>;
+		adi,use-lpm-enable;
+		adi,use-cpll-enable;
+	};
+
+	axi_adrv9009_adxcvr_tx: axi-adxcvr-tx@44a80000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "adi,axi-adxcvr-1.0";
+		reg = <0x44a80000 0x1000>;
+
+		clocks = <&clk0_ad9528 1>, <&axi_tx_clkgen>;
+		clock-names = "conv", "div40";
+
+		#clock-cells = <1>;
+		clock-output-names = "tx_gt_clk", "tx_out_clk";
+
+		adi,sys-clk-select = <3>;
+		adi,out-clk-select = <3>;
+	};
+};
+
+&spi0 {
+	status = "okay";
+};
+
+#define fmc_spi spi0
+
+#include "facc-adrv9009.dtsi"
+
+// adrv9009_dac_fifo_bypass_s 60
+// ad9528_reset_b,       // 59
+// ad9528_sysref_req,    // 58
+// adrv9009_tx1_enable,    // 57
+// adrv9009_tx2_enable,    // 56
+// adrv9009_rx1_enable,    // 55
+// adrv9009_rx2_enable,    // 54
+// adrv9009_test,          // 53
+// adrv9009_reset_b,       // 52
+// adrv9009_gpint,         // 51
+// adrv9009_gpio_00,       // 50
+// adrv9009_gpio_01,       // 49
+// adrv9009_gpio_02,       // 48
+// adrv9009_gpio_03,       // 47
+// adrv9009_gpio_04,       // 46
+// adrv9009_gpio_05,       // 45
+// adrv9009_gpio_06,       // 44
+// adrv9009_gpio_07,       // 43
+// adrv9009_gpio_15,       // 42
+// adrv9009_gpio_08,       // 41
+// adrv9009_gpio_09,       // 40
+// adrv9009_gpio_10,       // 39
+// adrv9009_gpio_11,       // 38
+// adrv9009_gpio_12,       // 37
+// adrv9009_gpio_14,       // 36
+// adrv9009_gpio_13,       // 35
+// adrv9009_gpio_17,       // 34
+// adrv9009_gpio_16,       // 33
+// adrv9009_gpio_18}));    // 32 + 54
+
+&trx0_adrv9009 {
+	reset-gpios = <&gpio0 106 0>;
+	test-gpios = <&gpio0 107 0>;
+	sysref-req-gpios = <&gpio0 112 0>;
+	rx2-enable-gpios = <&gpio0 108 0>;
+	rx1-enable-gpios = <&gpio0 109 0>;
+	tx2-enable-gpios = <&gpio0 110 0>;
+	tx1-enable-gpios = <&gpio0 111 0>;
+};
+
+&clk0_ad9528 {
+	reset-gpios = <&gpio0 113 0>;
+};
+
+&axi_adrv9009_core_tx {
+	plddrbypass-gpios = <&gpio0 114 0>;
+};
diff --git a/arch/arm/boot/dts/facc-zc706ad9371.dts b/arch/arm/boot/dts/facc-zc706ad9371.dts
new file mode 100644
index 0000000..b5651af
--- /dev/null
+++ b/arch/arm/boot/dts/facc-zc706ad9371.dts
@@ -0,0 +1,255 @@
+&fpga_axi {
+
+	rx_dma: rx-dmac@7c400000 {
+		compatible = "adi,axi-dmac-1.00.a";
+		reg = <0x7c400000 0x10000>;
+		#dma-cells = <1>;
+		interrupts = <0 57 0>;
+		clocks = <&clkc 16>;
+
+		dma-channel {
+			adi,buswidth = <64>;
+			adi,type = <0>;
+		};
+	};
+
+	rx_obs_dma: rx-obs-dmac@7c440000  {
+		compatible = "adi,axi-dmac-1.00.a";
+		reg = <0x7c440000  0x10000>;
+		#dma-cells = <1>;
+		interrupts = <0 55 0>;
+		clocks = <&clkc 16>;
+
+		dma-channel {
+			adi,buswidth = <64>;
+			adi,type = <0>;
+		};
+	};
+
+	tx_dma: tx-dmac@7c420000 {
+		compatible = "adi,axi-dmac-1.00.a";
+		reg = <0x7c420000 0x10000>;
+		#dma-cells = <1>;
+		interrupts = <0 56 0>;
+		clocks = <&clkc 16>;
+
+		dma-channel {
+			adi,buswidth = <128>;
+			adi,type = <1>;
+			adi,cyclic;
+		};
+	};
+
+	axi_ad9371_core_rx: axi-ad9371-rx-hpc@44a00000 {
+		compatible = "adi,axi-ad9371-rx-1.0";
+		reg = <0x44a00000 0x8000>;
+		dmas = <&rx_dma 0>;
+		dma-names = "rx";
+		spibus-connected = <&trx0_ad9371>;
+	};
+
+	axi_ad9371_core_rx_obs: axi-ad9371-rx-obs-hpc@44a08000 {
+		compatible = "adi,axi-ad9371-obs-1.0";
+		reg = <0x44a08000 0x1000>;
+		dmas = <&rx_obs_dma 0>;
+		dma-names = "rx";
+		clocks = <&trx0_ad9371 1>;
+		clock-names = "sampl_clk";
+	};
+
+	axi_ad9371_core_tx: axi-ad9371-tx-hpc@44a04000 {
+		compatible = "adi,axi-ad9371-tx-1.0";
+		reg = <0x44a04000 0x4000>;
+		dmas = <&tx_dma 0>;
+		dma-names = "tx";
+		clocks = <&trx0_ad9371 2>;
+		clock-names = "sampl_clk";
+		spibus-connected = <&trx0_ad9371>;
+		adi,axi-pl-fifo-enable;
+	};
+
+	axi_ad9371_rx_jesd: axi-jesd204-rx@44aa0000 {
+		compatible = "adi,axi-jesd204-rx-1.0";
+		reg = <0x44aa0000 0x1000>;
+
+		interrupts = <0 54 0>;
+
+		clocks = <&clkc 16>, <&axi_rx_clkgen>, <&axi_ad9371_adxcvr_rx 0>;
+		clock-names = "s_axi_aclk", "device_clk", "lane_clk";
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd_rx_lane_clk";
+
+		adi,octets-per-frame = <4>;
+		adi,frames-per-multiframe = <32>;
+	};
+
+	axi_ad9371_rx_os_jesd: axi-jesd204-rx@44ab0000 {
+		compatible = "adi,axi-jesd204-rx-1.0";
+		reg = <0x44ab0000 0x1000>;
+
+		interrupts = <0 52 0>;
+
+		clocks = <&clkc 16>, <&axi_rx_os_clkgen>, <&axi_ad9371_adxcvr_rx_os 0>;
+		clock-names = "s_axi_aclk", "device_clk", "lane_clk";
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd_rx_os_lane_clk";
+
+		adi,octets-per-frame = <2>;
+		adi,frames-per-multiframe = <32>;
+	};
+
+	axi_ad9371_tx_jesd: axi-jesd204-tx@44a90000 {
+		compatible = "adi,axi-jesd204-tx-1.0";
+		reg = <0x44a90000 0x1000>;
+
+		interrupts = <0 53 0>;
+
+		clocks = <&clkc 16>, <&axi_tx_clkgen>, <&axi_ad9371_adxcvr_tx 0>;
+		clock-names = "s_axi_aclk", "device_clk", "lane_clk";
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd_tx_lane_clk";
+
+		adi,octets-per-frame = <2>;
+		adi,frames-per-multiframe = <32>;
+		adi,converter-resolution = <14>;
+		adi,bits-per-sample = <16>;
+		adi,converters-per-device = <4>;
+		adi,control-bits-per-sample = <2>;
+	};
+
+
+	axi_tx_clkgen: axi-clkgen@43c00000  {
+		compatible = "adi,axi-clkgen-2.00.a";
+		reg = <0x43c00000 0x10000>;
+		#clock-cells = <0>;
+		clocks = <&clk0_ad9528 1>;
+		clock-output-names = "axi_tx_clkgen";
+	};
+
+	axi_rx_clkgen: axi-clkgen@43c10000  {
+		compatible = "adi,axi-clkgen-2.00.a";
+		reg = <0x43c10000 0x10000>;
+		#clock-cells = <0>;
+		clocks = <&clk0_ad9528 1>;
+		clock-output-names = "axi_rx_clkgen";
+	};
+
+	axi_rx_os_clkgen: axi-clkgen@43c20000  {
+		compatible = "adi,axi-clkgen-2.00.a";
+		reg = <0x43c20000 0x10000>;
+		#clock-cells = <0>;
+		clocks = <&clk0_ad9528 1>;
+		clock-output-names = "axi_rx_os_clkgen";
+	};
+
+	axi_ad9371_adxcvr_rx: axi-adxcvr-rx@44a60000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "adi,axi-adxcvr-1.0";
+		reg = <0x44a60000 0x1000>;
+
+		clocks = <&clk0_ad9528 1>, <&axi_rx_clkgen 0>;
+		clock-names = "conv", "div40";
+
+		#clock-cells = <1>;
+		clock-output-names = "rx_gt_clk", "rx_out_clk";
+
+		adi,sys-clk-select = <0>;
+		adi,out-clk-select = <3>;
+		adi,use-lpm-enable;
+		adi,use-cpll-enable;
+	};
+
+	axi_ad9371_adxcvr_rx_os: axi-adxcvr-rx-os@44a50000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "adi,axi-adxcvr-1.0";
+		reg = <0x44a50000 0x1000>;
+
+		clocks = <&clk0_ad9528 1>, <&axi_rx_os_clkgen>;
+		clock-names = "conv", "div40";
+
+		#clock-cells = <1>;
+		clock-output-names = "rx_os_gt_clk", "rx_os_out_clk";
+
+		adi,sys-clk-select = <0>;
+		adi,out-clk-select = <3>;
+		adi,use-lpm-enable;
+		adi,use-cpll-enable;
+	};
+
+	axi_ad9371_adxcvr_tx: axi-adxcvr-tx@44a80000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "adi,axi-adxcvr-1.0";
+		reg = <0x44a80000 0x1000>;
+
+		clocks = <&clk0_ad9528 1>, <&axi_tx_clkgen>;
+		clock-names = "conv", "div40";
+
+		#clock-cells = <1>;
+		clock-output-names = "tx_gt_clk", "tx_out_clk";
+
+		adi,sys-clk-select = <3>;
+		adi,out-clk-select = <3>;
+	};
+};
+
+&spi0 {
+	status = "okay";
+};
+
+#define fmc_spi spi0
+
+#include "adi-adrv9371.dtsi"
+
+// ad9371_dac_fifo_bypass_s 60
+// ad9528_reset_b,       // 59
+// ad9528_sysref_req,    // 58
+// ad9371_tx1_enable,    // 57
+// ad9371_tx2_enable,    // 56
+// ad9371_rx1_enable,    // 55
+// ad9371_rx2_enable,    // 54
+// ad9371_test,          // 53
+// ad9371_reset_b,       // 52
+// ad9371_gpint,         // 51
+// ad9371_gpio_00,       // 50
+// ad9371_gpio_01,       // 49
+// ad9371_gpio_02,       // 48
+// ad9371_gpio_03,       // 47
+// ad9371_gpio_04,       // 46
+// ad9371_gpio_05,       // 45
+// ad9371_gpio_06,       // 44
+// ad9371_gpio_07,       // 43
+// ad9371_gpio_15,       // 42
+// ad9371_gpio_08,       // 41
+// ad9371_gpio_09,       // 40
+// ad9371_gpio_10,       // 39
+// ad9371_gpio_11,       // 38
+// ad9371_gpio_12,       // 37
+// ad9371_gpio_14,       // 36
+// ad9371_gpio_13,       // 35
+// ad9371_gpio_17,       // 34
+// ad9371_gpio_16,       // 33
+// ad9371_gpio_18}));    // 32 + 54
+
+&trx0_ad9371 {
+	reset-gpios = <&gpio0 106 0>;
+	test-gpios = <&gpio0 107 0>;
+	sysref_req-gpios = <&gpio0 112 0>;
+	rx2_enable-gpios = <&gpio0 108 0>;
+	rx1_enable-gpios = <&gpio0 109 0>;
+	tx2_enable-gpios = <&gpio0 110 0>;
+	tx1_enable-gpios = <&gpio0 111 0>;
+};
+
+&clk0_ad9528 {
+	reset-gpios = <&gpio0 113 0>;
+};
+
+&axi_ad9371_core_tx {
+	plddrbypass-gpios = <&gpio0 114 0>;
+};
diff --git a/arch/arm/boot/dts/facc-zc706ad9371n1-new.dtsi b/arch/arm/boot/dts/facc-zc706ad9371n1-new.dtsi
new file mode 100644
index 0000000..50f35a7
--- /dev/null
+++ b/arch/arm/boot/dts/facc-zc706ad9371n1-new.dtsi
@@ -0,0 +1,307 @@
+
+&sys_hps_bridges {
+
+	rx_dma: rx-dmac@0003c000 {
+		compatible = "adi,axi-dmac-1.00.a";
+		reg = <0x0003c000 0x4000>;
+		#dma-cells = <1>;
+		interrupt-parent = <&intc>;
+		interrupts = <0 31 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&dma_clk>;
+
+		dma-channel {
+			adi,buswidth = <64>;
+			adi,type = <0>;
+		};
+	};
+
+	rx_obs_dma: rx-obs-dmac@0004c000 {
+		compatible = "adi,axi-dmac-1.00.a";
+		reg = <0x0004c000 0x4000>;
+		#dma-cells = <1>;
+		interrupt-parent = <&intc>;
+		interrupts = <0 32 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&dma_clk>;
+
+		dma-channel {
+			adi,buswidth = <64>;
+			adi,type = <0>;
+		};
+	};
+
+	tx_dma: tx-dmac@0002c000 {
+		compatible = "adi,axi-dmac-1.00.a";
+		reg = <0x0002c000 0x4000>;
+		#dma-cells = <1>;
+		interrupt-parent = <&intc>;
+		interrupts = <0 30 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&dma_clk>;
+
+		dma-channel {
+			adi,buswidth = <128>;
+			adi,type = <1>;
+			adi,cyclic;
+		};
+	};
+
+	axi_ad9371_core_rx: axi-ad9371-rx-hpc@00050000 {
+		compatible = "adi,axi-ad9371-rx-1.0";
+		reg = <0x00050000 0x8000>;
+		dmas = <&rx_dma 0>;
+		dma-names = "rx";
+		spibus-connected = <&trx0_ad9371>;
+	};
+
+	axi_ad9371_core_rx_obs: axi-ad9371-rx-obs-hpc@00058000 {
+		compatible = "adi,axi-ad9371-obs-1.0";
+		reg = <0x00058000 0x1000>;
+		dmas = <&rx_obs_dma 0>;
+		dma-names = "rx";
+		clocks = <&trx0_ad9371 1>;
+		clock-names = "sampl_clk";
+	};
+
+	axi_ad9371_core_tx: axi-ad9371-tx-hpc@00054000 {
+		compatible = "adi,axi-ad9371-tx-1.0";
+		reg = <0x00054000 0x4000>;
+		dmas = <&tx_dma 0>;
+		dma-names = "tx";
+		clocks = <&trx0_ad9371 2>;
+		clock-names = "sampl_clk";
+		spibus-connected = <&trx0_ad9371>;
+		adi,axi-pl-fifo-enable;//adi,axi-pl-fifo-disable;
+	};
+
+	axi_ad9371_rx_jesd: axi-jesd204-rx@00030000 {
+		compatible = "adi,axi-jesd204-rx-1.0";
+		reg = <0x00030000 0x4000>;
+
+		interrupt-parent = <&intc>;
+		interrupts = <0 27 IRQ_TYPE_NONE>;
+
+		clocks = <&sys_clk>, <&rx_device_clk_pll>, <&axi_ad9371_rx_xcvr>;
+		clock-names = "s_axi_aclk", "device_clk", "lane_clk";
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd_rx_lane_clk";
+
+		adi,octets-per-frame = <4>;
+		adi,frames-per-multiframe = <32>;
+		adi,converter-resolution = <16>;
+		adi,bits-per-sample = <16>;
+		adi,converters-per-device = <4>;
+	};
+
+	axi_ad9371_rx_os_jesd: axi-jesd204-rx@00040000 {
+		compatible = "adi,axi-jesd204-rx-1.0";
+		reg = <0x00040000 0x4000>;
+
+		interrupt-parent = <&intc>;
+		interrupts = <0 29 IRQ_TYPE_NONE>;
+
+		clocks = <&sys_clk>, <&rx_os_device_clk_pll>, <&axi_ad9371_rx_os_xcvr>;
+		clock-names = "s_axi_aclk", "device_clk", "lane_clk";
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd_rx_os_lane_clk";
+
+		adi,octets-per-frame = <2>;
+		adi,frames-per-multiframe = <32>;
+		adi,converter-resolution = <16>;
+		adi,bits-per-sample = <16>;
+		adi,converters-per-device = <4>;
+	};
+
+	axi_ad9371_tx_jesd: axi-jesd204-tx@20000 {
+		compatible = "adi,axi-jesd204-tx-1.0";
+		reg = <0x00020000 0x4000>;
+
+		interrupt-parent = <&intc>;
+		interrupts = <0 28 IRQ_TYPE_NONE>;
+
+		clocks = <&sys_clk>, <&tx_device_clk_pll>, <&axi_ad9371_tx_xcvr>;
+		clock-names = "s_axi_aclk", "device_clk", "lane_clk";
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd_tx_lane_clk";
+
+		adi,octets-per-frame = <2>;
+		adi,frames-per-multiframe = <32>;
+		adi,converter-resolution = <14>;
+		adi,bits-per-sample = <16>;
+		adi,converters-per-device = <4>;
+		adi,control-bits-per-sample = <2>;
+	};
+
+
+	axi_tx_clkgen: a10-fpll-tx@25000 {
+		compatible = "altr,a10-fpll";
+		reg = <0x00025000 0x1000>;
+		#clock-cells = <0>;
+		clocks = <&clk0_ad9528 3>;
+		clock-output-names = "jesd204_tx_link_clock";
+	};
+
+	axi_rx_clkgen: a10-fpll-rx@35000 {
+		compatible = "altr,a10-fpll";
+		reg = <0x00035000 0x1000>;
+		#clock-cells = <0>;
+		clocks = <&clk0_ad9528 3>;
+		clock-output-names = "jesd204_rx_link_clock";
+	};
+
+	axi_rx_obs_clkgen: a10-fpll-rx-obs@45000 {
+		compatible = "altr,a10-fpll";
+		reg = <0x00045000 0x1000>;
+		#clock-cells = <0>;
+		clocks = <&clk0_ad9528 3>;
+		clock-output-names = "jesd204_rx_os_link_clock";
+	};
+
+	axi_adxcvr_rx: altera-adxcvr-rx@00034000 {
+		compatible = "adi,altera-adxcvr-1.00.a";
+		reg = <0x00034000 0x1000>,
+			<0x00038000 0x1000>,
+			<0x00039000 0x1000>;
+		reg-names = "adxcvr", "adxcfg-0", "adxcfg-1";
+
+		clocks = <&clk0_ad9528 3>, <&rx_device_clk_pll>;
+		clock-names = "ref", "link";
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd204_rx_lane_clock";
+
+	};
+
+	axi_adxcvr_rx_obs: altera-adxcvr-rx-obs@00044000 {
+		compatible = "adi,altera-adxcvr-1.00.a";
+		reg = <0x00044000 0x1000>,
+			<0x00048000 0x1000>,
+			<0x00049000 0x1000>;
+		reg-names = "adxcvr", "adxcfg-0", "adxcfg-1";
+
+		clocks = <&clk0_ad9528 3>, <&rx_os_device_clk_pll>;
+		clock-names = "ref", "link";
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd204_rx_os_lane_clock";
+
+	};
+
+	axi_adxcvr_tx: altera-adxcvr-tx@00024000 {
+		compatible = "adi,altera-adxcvr-1.00.a";
+		reg = <0x00024000 0x1000>,
+			<0x00026000 0x1000>,
+			<0x00028000 0x1000>,
+			<0x00029000 0x1000>,
+			<0x0002a000 0x1000>,
+			<0x0002b000 0x1000>;
+		reg-names = "adxcvr", "atx-pll", "adxcfg-0", "adxcfg-1", "adxcfg-2", "adxcfg-3";
+
+		clocks = <&clk0_ad9528 3>, <&tx_device_clk_pll>;
+		clock-names = "ref", "link";
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd204_tx_lane_clock";
+
+	};
+};
+
+&fmc_spi {
+	trx0_ad9371: ad9371-phy@1 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		#clock-cells = <1>;
+		compatible = "ad9371";
+
+		/* SPI Setup */
+		reg = <1>;
+		spi-max-frequency = <25000000>;
+
+		reset-gpios = <&sys_gpio_out 20 0>;
+		test-gpios = <&sys_gpio_out 21 0>;
+		sysref_req-gpios = <&sys_gpio_out 26 0>;
+		rx2_enable-gpios = <&sys_gpio_out 22 0>;
+		rx1_enable-gpios = <&sys_gpio_out 23 0>;
+		tx2_enable-gpios = <&sys_gpio_out 24 0>;
+		tx1_enable-gpios = <&sys_gpio_out 25 0>;
+
+		/* all interrupts in HW design should be reviewed */
+		//interrupt-parent = <&intc>;
+		//interrupts = <0 31 IRQ_TYPE_LEVEL_HIGH>;
+
+		/* Clocks */
+		clocks = <&axi_ad9371_rx_jesd>, <&axi_ad9371_tx_jesd>, <&axi_ad9371_rx_os_jesd>, <&clk0_ad9528 6>, <&clk0_ad9528 3>;
+		clock-names = "jesd_rx_clk", "jesd_tx_clk", "jesd_rx_os_clk", "dev_clk", "fmc_clk";
+		clock-output-names = "rx_sampl_clk", "rx_os_sampl_clk", "tx_sampl_clk";
+
+		adi,clocks-clk-pll-vco-freq_khz = <9830400>;
+		adi,clocks-device-clock_khz = <122880>;
+		adi,clocks-clk-pll-hs-div = <4>;
+		adi,clocks-clk-pll-vco-div = <2>;
+
+		adi,jesd204-obs-framer-over-sample = <0>;
+
+		adi,rx-profile-adc-div = <1>;
+		adi,rx-profile-en-high-rej-dec5 = <1>;
+		adi,rx-profile-iq-rate_khz = <122880>;
+		adi,rx-profile-rf-bandwidth_hz = <100000000>;
+		adi,rx-profile-rhb1-decimation = <1>;
+		adi,rx-profile-rx-bbf-3db-corner_khz = <100000>;
+		adi,rx-profile-rx-dec5-decimation = <5>;
+		adi,rx-profile-rx-fir-decimation = <2>;
+
+		adi,obs-profile-adc-div = <1>;
+		adi,obs-profile-en-high-rej-dec5 = <0>;
+		adi,obs-profile-iq-rate_khz = <245760>;
+		adi,obs-profile-rf-bandwidth_hz = <200000000>;
+		adi,obs-profile-rhb1-decimation = <1>;
+		adi,obs-profile-rx-bbf-3db-corner_khz = <100000>;
+		adi,obs-profile-rx-dec5-decimation = <5>;
+		adi,obs-profile-rx-fir-decimation = <1>;
+
+		adi,tx-profile-dac-div = <1>;
+		adi,tx-profile-iq-rate_khz = <245760>;
+		adi,tx-profile-primary-sig-bandwidth_hz = <75000000>;
+		adi,tx-profile-rf-bandwidth_hz = <200000000>;
+		adi,tx-profile-thb1-interpolation = <2>;
+		adi,tx-profile-thb2-interpolation = <1>;
+		adi,tx-profile-tx-bbf-3db-corner_khz = <100000>;
+		adi,tx-profile-tx-dac-3db-corner_khz = <189477>;
+		adi,tx-profile-tx-fir-interpolation = <1>;
+		adi,tx-profile-tx-input-hb-interpolation = <1>;
+
+		adi,sniffer-profile-adc-div = <1>;
+		adi,sniffer-profile-en-high-rej-dec5 = <0>;
+		adi,sniffer-profile-iq-rate_khz = <30720>;
+		adi,sniffer-profile-rf-bandwidth_hz = <20000000>;
+		adi,sniffer-profile-rhb1-decimation = <2>;
+		adi,sniffer-profile-rx-bbf-3db-corner_khz = <100000>;
+		adi,sniffer-profile-rx-dec5-decimation = <5>;
+		adi,sniffer-profile-rx-fir-decimation = <4>;
+#if 0
+		/* Jacky:2018/07/25: enable pin-mode 
+		   https://wiki.analog.com/resources/tools-software/linux-drivers/iio-transceiver/ad9371-customization */
+		adi,arm-gpio-use-rx2-enable-pin = <1>;	// 0= RX1_ENABLE controls RX1&RX2, 1= separate RX1/RX2_ENABLE pins
+		adi,arm-gpio-use-tx2-enable-pin = <1>;	// 0= TX1_ENABLE controls TX1&TX2, 1= separate TX1/TX2_ENABLE pins
+		adi,arm-gpio-tx-rx-pin-mode = <1>;		// 0= ARM command mode, 1 = Pin mode to power up Tx/Rx chains
+		adi,arm-gpio-orx-pin-mode = <1>;		// 0= ARM command mode, 1 = Pin mode to power up ObsRx receiver
+		// to be tested: enable pin-mode but NOT enable gpio-ack
+		adi,arm-gpio-orx-trigger-pin = <0>;		// Select desired GPIO pin (valid 4-15)
+		adi,arm-gpio-orx-mode2-pin = <0>;		// Select desired GPIO pin (valid 0-18)
+		adi,arm-gpio-orx-mode1-pin = <0>;		// Select desired GPIO pin (valid 0-18)
+		adi,arm-gpio-orx-mode0-pin = <0>;		// Select desired GPIO pin (valid 0-18)
+		adi,arm-gpio-rx1-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-rx2-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-tx1-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-tx2-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-orx1-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-orx2-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-srx-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-tx-obs-select = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable.
+			// When 2 Tx are used with only 1 ORx input, this GPIO tells BBIC which Tx channel is active
+			// for calibrations, so BBIC can route correct RF Tx path into the single ORx input
+		adi,arm-gpio-enable-mask = <0>;
+#endif
+	};
+};
diff --git a/arch/arm/boot/dts/facc-zc706ad9371n1.dtsi b/arch/arm/boot/dts/facc-zc706ad9371n1.dtsi
new file mode 100644
index 0000000..023a65e
--- /dev/null
+++ b/arch/arm/boot/dts/facc-zc706ad9371n1.dtsi
@@ -0,0 +1,262 @@
+&fpga_axi {
+
+	rx_dma: rx-dmac@7c400000 {
+		compatible = "adi,axi-dmac-1.00.a";
+		reg = <0x7c400000 0x10000>;
+		#dma-cells = <1>;
+		interrupts = <0 57 0>;
+		clocks = <&clkc 16>;
+
+		dma-channel {
+			adi,buswidth = <64>;
+			adi,type = <0>;
+		};
+	};
+
+	rx_obs_dma: rx-obs-dmac@7c440000  {
+		compatible = "adi,axi-dmac-1.00.a";
+		reg = <0x7c440000  0x10000>;
+		#dma-cells = <1>;
+		interrupts = <0 55 0>;
+		clocks = <&clkc 16>;
+
+		dma-channel {
+			adi,buswidth = <64>;
+			adi,type = <0>;
+		};
+	};
+
+	tx_dma: tx-dmac@7c420000 {
+		compatible = "adi,axi-dmac-1.00.a";
+		reg = <0x7c420000 0x10000>;
+		#dma-cells = <1>;
+		interrupts = <0 56 0>;
+		clocks = <&clkc 16>;
+
+		dma-channel {
+			adi,buswidth = <128>;
+			adi,type = <1>;
+			adi,cyclic;
+		};
+	};
+
+	axi_ad9371_core_rx: axi-ad9371-rx-hpc@44a00000 {
+		compatible = "adi,axi-ad9371-rx-1.0";
+		reg = <0x44a00000 0x8000>;
+		dmas = <&rx_dma 0>;
+		dma-names = "rx";
+		spibus-connected = <&trx0_ad9371>;
+	};
+
+	axi_ad9371_core_rx_obs: axi-ad9371-rx-obs-hpc@44a08000 {
+		compatible = "adi,axi-ad9371-obs-1.0";
+		reg = <0x44a08000 0x1000>;
+		dmas = <&rx_obs_dma 0>;
+		dma-names = "rx";
+		clocks = <&trx0_ad9371 1>;
+		clock-names = "sampl_clk";
+	};
+
+	axi_ad9371_core_tx: axi-ad9371-tx-hpc@44a04000 {
+		compatible = "adi,axi-ad9371-tx-1.0";
+		reg = <0x44a04000 0x4000>;
+		dmas = <&tx_dma 0>;
+		dma-names = "tx";
+		clocks = <&trx0_ad9371 2>;
+		clock-names = "sampl_clk";
+		spibus-connected = <&trx0_ad9371>;
+		adi,axi-pl-fifo-enable;
+	};
+
+	axi_ad9371_rx_jesd: axi-jesd204-rx@44aa0000 {
+		compatible = "adi,axi-jesd204-rx-1.0";
+		reg = <0x44aa0000 0x1000>;
+
+		interrupts = <0 54 0>;
+
+		clocks = <&clkc 16>, <&axi_rx_clkgen>, <&axi_ad9371_adxcvr_rx 0>;
+		clock-names = "s_axi_aclk", "device_clk", "lane_clk";
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd_rx_lane_clk";
+
+		adi,octets-per-frame = <4>;
+		adi,frames-per-multiframe = <32>;
+	};
+
+	axi_ad9371_rx_os_jesd: axi-jesd204-rx@44ab0000 {
+		compatible = "adi,axi-jesd204-rx-1.0";
+		reg = <0x44ab0000 0x1000>;
+
+		interrupts = <0 52 0>;
+
+		clocks = <&clkc 16>, <&axi_rx_os_clkgen>, <&axi_ad9371_adxcvr_rx_os 0>;
+		clock-names = "s_axi_aclk", "device_clk", "lane_clk";
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd_rx_os_lane_clk";
+
+		adi,octets-per-frame = <2>;
+		adi,frames-per-multiframe = <32>;
+	};
+
+	axi_ad9371_tx_jesd: axi-jesd204-tx@44a90000 {
+		compatible = "adi,axi-jesd204-tx-1.0";
+		reg = <0x44a90000 0x1000>;
+
+		interrupts = <0 53 0>;
+
+		clocks = <&clkc 16>, <&axi_tx_clkgen>, <&axi_ad9371_adxcvr_tx 0>;
+		clock-names = "s_axi_aclk", "device_clk", "lane_clk";
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd_tx_lane_clk";
+
+		adi,octets-per-frame = <2>;
+		adi,frames-per-multiframe = <32>;
+		adi,converter-resolution = <14>;
+		adi,bits-per-sample = <16>;
+		adi,converters-per-device = <4>;
+		adi,control-bits-per-sample = <2>;
+	};
+
+
+	axi_tx_clkgen: axi-clkgen@43c00000  {
+		compatible = "adi,axi-clkgen-2.00.a";
+		reg = <0x43c00000 0x10000>;
+		#clock-cells = <0>;
+		clocks = <&clk0_ad9528 1>;
+		clock-output-names = "axi_tx_clkgen";
+	};
+
+	axi_rx_clkgen: axi-clkgen@43c10000  {
+		compatible = "adi,axi-clkgen-2.00.a";
+		reg = <0x43c10000 0x10000>;
+		#clock-cells = <0>;
+		clocks = <&clk0_ad9528 1>;
+		clock-output-names = "axi_rx_clkgen";
+	};
+
+	axi_rx_obs_clkgen: axi-clkgen@43c20000  {
+		compatible = "adi,axi-clkgen-2.00.a";
+		reg = <0x43c20000 0x10000>;
+		#clock-cells = <0>;
+		clocks = <&clk0_ad9528 1>;
+		clock-output-names = "axi_rx_os_clkgen";
+	};
+
+	axi_adxcvr_rx: axi-adxcvr-rx@44a60000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "adi,axi-adxcvr-1.0";
+		reg = <0x44a60000 0x1000>;
+
+		clocks = <&clk0_ad9528 1>, <&axi_rx_clkgen 0>;
+		clock-names = "conv", "div40";
+
+		#clock-cells = <1>;
+		clock-output-names = "rx_gt_clk", "rx_out_clk";
+
+		adi,sys-clk-select = <0>;
+		adi,out-clk-select = <3>;
+		adi,use-lpm-enable;
+		adi,use-cpll-enable;
+	};
+
+	axi_adxcvr_rx_obs: axi-adxcvr-rx-obs@44a50000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "adi,axi-adxcvr-1.0";
+		reg = <0x44a50000 0x1000>;
+
+		clocks = <&clk0_ad9528 1>, <&axi_rx_os_clkgen>;
+		clock-names = "conv", "div40";
+
+		#clock-cells = <1>;
+		clock-output-names = "rx_os_gt_clk", "rx_os_out_clk";
+
+		adi,sys-clk-select = <0>;
+		adi,out-clk-select = <3>;
+		adi,use-lpm-enable;
+		adi,use-cpll-enable;
+	};
+
+	axi_adxcvr_tx: axi-adxcvr-tx@44a80000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "adi,axi-adxcvr-1.0";
+		reg = <0x44a80000 0x1000>;
+
+		clocks = <&clk0_ad9528 1>, <&axi_tx_clkgen>;
+		clock-names = "conv", "div40";
+
+		#clock-cells = <1>;
+		clock-output-names = "tx_gt_clk", "tx_out_clk";
+
+		adi,sys-clk-select = <3>;
+		adi,out-clk-select = <3>;
+	};
+};
+
+&fmc_spi {
+	trx0_ad9371: ad9371-phy@1 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		#clock-cells = <1>;
+		compatible = "ad9371";
+
+		/* SPI Setup */
+		reg = <1>;
+		spi-max-frequency = <25000000>;
+
+		/* Clocks */
+		clocks = <&axi_ad9371_rx_jesd>, <&axi_ad9371_tx_jesd>, <&axi_ad9371_rx_os_jesd>, <&clk0_ad9528 13>, <&clk0_ad9528 1>;
+		clock-names = "jesd_rx_clk", "jesd_tx_clk", "jesd_rx_os_clk", "dev_clk", "fmc_clk";
+		clock-output-names = "rx_sampl_clk", "rx_os_sampl_clk", "tx_sampl_clk";
+
+		adi,clocks-clk-pll-vco-freq_khz = <9830400>;
+		adi,clocks-device-clock_khz = <122880>;
+		adi,clocks-clk-pll-hs-div = <4>;
+		adi,clocks-clk-pll-vco-div = <2>;
+
+		adi,jesd204-obs-framer-over-sample = <0>;
+
+		adi,rx-profile-adc-div = <1>;
+		adi,rx-profile-en-high-rej-dec5 = <1>;
+		adi,rx-profile-iq-rate_khz = <122880>;
+		adi,rx-profile-rf-bandwidth_hz = <100000000>;
+		adi,rx-profile-rhb1-decimation = <1>;
+		adi,rx-profile-rx-bbf-3db-corner_khz = <100000>;
+		adi,rx-profile-rx-dec5-decimation = <5>;
+		adi,rx-profile-rx-fir-decimation = <2>;
+
+		adi,obs-profile-adc-div = <1>;
+		adi,obs-profile-en-high-rej-dec5 = <0>;
+		adi,obs-profile-iq-rate_khz = <245760>;
+		adi,obs-profile-rf-bandwidth_hz = <200000000>;
+		adi,obs-profile-rhb1-decimation = <1>;
+		adi,obs-profile-rx-bbf-3db-corner_khz = <100000>;
+		adi,obs-profile-rx-dec5-decimation = <5>;
+		adi,obs-profile-rx-fir-decimation = <1>;
+
+		adi,tx-profile-dac-div = <1>;
+		adi,tx-profile-iq-rate_khz = <245760>;
+		adi,tx-profile-primary-sig-bandwidth_hz = <75000000>;
+		adi,tx-profile-rf-bandwidth_hz = <200000000>;
+		adi,tx-profile-thb1-interpolation = <2>;
+		adi,tx-profile-thb2-interpolation = <1>;
+		adi,tx-profile-tx-bbf-3db-corner_khz = <100000>;
+		adi,tx-profile-tx-dac-3db-corner_khz = <189477>;
+		adi,tx-profile-tx-fir-interpolation = <1>;
+		adi,tx-profile-tx-input-hb-interpolation = <1>;
+
+		adi,sniffer-profile-adc-div = <1>;
+		adi,sniffer-profile-en-high-rej-dec5 = <0>;
+		adi,sniffer-profile-iq-rate_khz = <30720>;
+		adi,sniffer-profile-rf-bandwidth_hz = <20000000>;
+		adi,sniffer-profile-rhb1-decimation = <2>;
+		adi,sniffer-profile-rx-bbf-3db-corner_khz = <100000>;
+		adi,sniffer-profile-rx-dec5-decimation = <5>;
+		adi,sniffer-profile-rx-fir-decimation = <4>;
+	};
+};
\ No newline at end of file
diff --git a/arch/arm/boot/dts/facc-zc706ad9371n2-new.dtsi b/arch/arm/boot/dts/facc-zc706ad9371n2-new.dtsi
new file mode 100644
index 0000000..50f35a7
--- /dev/null
+++ b/arch/arm/boot/dts/facc-zc706ad9371n2-new.dtsi
@@ -0,0 +1,307 @@
+
+&sys_hps_bridges {
+
+	rx_dma: rx-dmac@0003c000 {
+		compatible = "adi,axi-dmac-1.00.a";
+		reg = <0x0003c000 0x4000>;
+		#dma-cells = <1>;
+		interrupt-parent = <&intc>;
+		interrupts = <0 31 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&dma_clk>;
+
+		dma-channel {
+			adi,buswidth = <64>;
+			adi,type = <0>;
+		};
+	};
+
+	rx_obs_dma: rx-obs-dmac@0004c000 {
+		compatible = "adi,axi-dmac-1.00.a";
+		reg = <0x0004c000 0x4000>;
+		#dma-cells = <1>;
+		interrupt-parent = <&intc>;
+		interrupts = <0 32 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&dma_clk>;
+
+		dma-channel {
+			adi,buswidth = <64>;
+			adi,type = <0>;
+		};
+	};
+
+	tx_dma: tx-dmac@0002c000 {
+		compatible = "adi,axi-dmac-1.00.a";
+		reg = <0x0002c000 0x4000>;
+		#dma-cells = <1>;
+		interrupt-parent = <&intc>;
+		interrupts = <0 30 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&dma_clk>;
+
+		dma-channel {
+			adi,buswidth = <128>;
+			adi,type = <1>;
+			adi,cyclic;
+		};
+	};
+
+	axi_ad9371_core_rx: axi-ad9371-rx-hpc@00050000 {
+		compatible = "adi,axi-ad9371-rx-1.0";
+		reg = <0x00050000 0x8000>;
+		dmas = <&rx_dma 0>;
+		dma-names = "rx";
+		spibus-connected = <&trx0_ad9371>;
+	};
+
+	axi_ad9371_core_rx_obs: axi-ad9371-rx-obs-hpc@00058000 {
+		compatible = "adi,axi-ad9371-obs-1.0";
+		reg = <0x00058000 0x1000>;
+		dmas = <&rx_obs_dma 0>;
+		dma-names = "rx";
+		clocks = <&trx0_ad9371 1>;
+		clock-names = "sampl_clk";
+	};
+
+	axi_ad9371_core_tx: axi-ad9371-tx-hpc@00054000 {
+		compatible = "adi,axi-ad9371-tx-1.0";
+		reg = <0x00054000 0x4000>;
+		dmas = <&tx_dma 0>;
+		dma-names = "tx";
+		clocks = <&trx0_ad9371 2>;
+		clock-names = "sampl_clk";
+		spibus-connected = <&trx0_ad9371>;
+		adi,axi-pl-fifo-enable;//adi,axi-pl-fifo-disable;
+	};
+
+	axi_ad9371_rx_jesd: axi-jesd204-rx@00030000 {
+		compatible = "adi,axi-jesd204-rx-1.0";
+		reg = <0x00030000 0x4000>;
+
+		interrupt-parent = <&intc>;
+		interrupts = <0 27 IRQ_TYPE_NONE>;
+
+		clocks = <&sys_clk>, <&rx_device_clk_pll>, <&axi_ad9371_rx_xcvr>;
+		clock-names = "s_axi_aclk", "device_clk", "lane_clk";
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd_rx_lane_clk";
+
+		adi,octets-per-frame = <4>;
+		adi,frames-per-multiframe = <32>;
+		adi,converter-resolution = <16>;
+		adi,bits-per-sample = <16>;
+		adi,converters-per-device = <4>;
+	};
+
+	axi_ad9371_rx_os_jesd: axi-jesd204-rx@00040000 {
+		compatible = "adi,axi-jesd204-rx-1.0";
+		reg = <0x00040000 0x4000>;
+
+		interrupt-parent = <&intc>;
+		interrupts = <0 29 IRQ_TYPE_NONE>;
+
+		clocks = <&sys_clk>, <&rx_os_device_clk_pll>, <&axi_ad9371_rx_os_xcvr>;
+		clock-names = "s_axi_aclk", "device_clk", "lane_clk";
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd_rx_os_lane_clk";
+
+		adi,octets-per-frame = <2>;
+		adi,frames-per-multiframe = <32>;
+		adi,converter-resolution = <16>;
+		adi,bits-per-sample = <16>;
+		adi,converters-per-device = <4>;
+	};
+
+	axi_ad9371_tx_jesd: axi-jesd204-tx@20000 {
+		compatible = "adi,axi-jesd204-tx-1.0";
+		reg = <0x00020000 0x4000>;
+
+		interrupt-parent = <&intc>;
+		interrupts = <0 28 IRQ_TYPE_NONE>;
+
+		clocks = <&sys_clk>, <&tx_device_clk_pll>, <&axi_ad9371_tx_xcvr>;
+		clock-names = "s_axi_aclk", "device_clk", "lane_clk";
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd_tx_lane_clk";
+
+		adi,octets-per-frame = <2>;
+		adi,frames-per-multiframe = <32>;
+		adi,converter-resolution = <14>;
+		adi,bits-per-sample = <16>;
+		adi,converters-per-device = <4>;
+		adi,control-bits-per-sample = <2>;
+	};
+
+
+	axi_tx_clkgen: a10-fpll-tx@25000 {
+		compatible = "altr,a10-fpll";
+		reg = <0x00025000 0x1000>;
+		#clock-cells = <0>;
+		clocks = <&clk0_ad9528 3>;
+		clock-output-names = "jesd204_tx_link_clock";
+	};
+
+	axi_rx_clkgen: a10-fpll-rx@35000 {
+		compatible = "altr,a10-fpll";
+		reg = <0x00035000 0x1000>;
+		#clock-cells = <0>;
+		clocks = <&clk0_ad9528 3>;
+		clock-output-names = "jesd204_rx_link_clock";
+	};
+
+	axi_rx_obs_clkgen: a10-fpll-rx-obs@45000 {
+		compatible = "altr,a10-fpll";
+		reg = <0x00045000 0x1000>;
+		#clock-cells = <0>;
+		clocks = <&clk0_ad9528 3>;
+		clock-output-names = "jesd204_rx_os_link_clock";
+	};
+
+	axi_adxcvr_rx: altera-adxcvr-rx@00034000 {
+		compatible = "adi,altera-adxcvr-1.00.a";
+		reg = <0x00034000 0x1000>,
+			<0x00038000 0x1000>,
+			<0x00039000 0x1000>;
+		reg-names = "adxcvr", "adxcfg-0", "adxcfg-1";
+
+		clocks = <&clk0_ad9528 3>, <&rx_device_clk_pll>;
+		clock-names = "ref", "link";
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd204_rx_lane_clock";
+
+	};
+
+	axi_adxcvr_rx_obs: altera-adxcvr-rx-obs@00044000 {
+		compatible = "adi,altera-adxcvr-1.00.a";
+		reg = <0x00044000 0x1000>,
+			<0x00048000 0x1000>,
+			<0x00049000 0x1000>;
+		reg-names = "adxcvr", "adxcfg-0", "adxcfg-1";
+
+		clocks = <&clk0_ad9528 3>, <&rx_os_device_clk_pll>;
+		clock-names = "ref", "link";
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd204_rx_os_lane_clock";
+
+	};
+
+	axi_adxcvr_tx: altera-adxcvr-tx@00024000 {
+		compatible = "adi,altera-adxcvr-1.00.a";
+		reg = <0x00024000 0x1000>,
+			<0x00026000 0x1000>,
+			<0x00028000 0x1000>,
+			<0x00029000 0x1000>,
+			<0x0002a000 0x1000>,
+			<0x0002b000 0x1000>;
+		reg-names = "adxcvr", "atx-pll", "adxcfg-0", "adxcfg-1", "adxcfg-2", "adxcfg-3";
+
+		clocks = <&clk0_ad9528 3>, <&tx_device_clk_pll>;
+		clock-names = "ref", "link";
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd204_tx_lane_clock";
+
+	};
+};
+
+&fmc_spi {
+	trx0_ad9371: ad9371-phy@1 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		#clock-cells = <1>;
+		compatible = "ad9371";
+
+		/* SPI Setup */
+		reg = <1>;
+		spi-max-frequency = <25000000>;
+
+		reset-gpios = <&sys_gpio_out 20 0>;
+		test-gpios = <&sys_gpio_out 21 0>;
+		sysref_req-gpios = <&sys_gpio_out 26 0>;
+		rx2_enable-gpios = <&sys_gpio_out 22 0>;
+		rx1_enable-gpios = <&sys_gpio_out 23 0>;
+		tx2_enable-gpios = <&sys_gpio_out 24 0>;
+		tx1_enable-gpios = <&sys_gpio_out 25 0>;
+
+		/* all interrupts in HW design should be reviewed */
+		//interrupt-parent = <&intc>;
+		//interrupts = <0 31 IRQ_TYPE_LEVEL_HIGH>;
+
+		/* Clocks */
+		clocks = <&axi_ad9371_rx_jesd>, <&axi_ad9371_tx_jesd>, <&axi_ad9371_rx_os_jesd>, <&clk0_ad9528 6>, <&clk0_ad9528 3>;
+		clock-names = "jesd_rx_clk", "jesd_tx_clk", "jesd_rx_os_clk", "dev_clk", "fmc_clk";
+		clock-output-names = "rx_sampl_clk", "rx_os_sampl_clk", "tx_sampl_clk";
+
+		adi,clocks-clk-pll-vco-freq_khz = <9830400>;
+		adi,clocks-device-clock_khz = <122880>;
+		adi,clocks-clk-pll-hs-div = <4>;
+		adi,clocks-clk-pll-vco-div = <2>;
+
+		adi,jesd204-obs-framer-over-sample = <0>;
+
+		adi,rx-profile-adc-div = <1>;
+		adi,rx-profile-en-high-rej-dec5 = <1>;
+		adi,rx-profile-iq-rate_khz = <122880>;
+		adi,rx-profile-rf-bandwidth_hz = <100000000>;
+		adi,rx-profile-rhb1-decimation = <1>;
+		adi,rx-profile-rx-bbf-3db-corner_khz = <100000>;
+		adi,rx-profile-rx-dec5-decimation = <5>;
+		adi,rx-profile-rx-fir-decimation = <2>;
+
+		adi,obs-profile-adc-div = <1>;
+		adi,obs-profile-en-high-rej-dec5 = <0>;
+		adi,obs-profile-iq-rate_khz = <245760>;
+		adi,obs-profile-rf-bandwidth_hz = <200000000>;
+		adi,obs-profile-rhb1-decimation = <1>;
+		adi,obs-profile-rx-bbf-3db-corner_khz = <100000>;
+		adi,obs-profile-rx-dec5-decimation = <5>;
+		adi,obs-profile-rx-fir-decimation = <1>;
+
+		adi,tx-profile-dac-div = <1>;
+		adi,tx-profile-iq-rate_khz = <245760>;
+		adi,tx-profile-primary-sig-bandwidth_hz = <75000000>;
+		adi,tx-profile-rf-bandwidth_hz = <200000000>;
+		adi,tx-profile-thb1-interpolation = <2>;
+		adi,tx-profile-thb2-interpolation = <1>;
+		adi,tx-profile-tx-bbf-3db-corner_khz = <100000>;
+		adi,tx-profile-tx-dac-3db-corner_khz = <189477>;
+		adi,tx-profile-tx-fir-interpolation = <1>;
+		adi,tx-profile-tx-input-hb-interpolation = <1>;
+
+		adi,sniffer-profile-adc-div = <1>;
+		adi,sniffer-profile-en-high-rej-dec5 = <0>;
+		adi,sniffer-profile-iq-rate_khz = <30720>;
+		adi,sniffer-profile-rf-bandwidth_hz = <20000000>;
+		adi,sniffer-profile-rhb1-decimation = <2>;
+		adi,sniffer-profile-rx-bbf-3db-corner_khz = <100000>;
+		adi,sniffer-profile-rx-dec5-decimation = <5>;
+		adi,sniffer-profile-rx-fir-decimation = <4>;
+#if 0
+		/* Jacky:2018/07/25: enable pin-mode 
+		   https://wiki.analog.com/resources/tools-software/linux-drivers/iio-transceiver/ad9371-customization */
+		adi,arm-gpio-use-rx2-enable-pin = <1>;	// 0= RX1_ENABLE controls RX1&RX2, 1= separate RX1/RX2_ENABLE pins
+		adi,arm-gpio-use-tx2-enable-pin = <1>;	// 0= TX1_ENABLE controls TX1&TX2, 1= separate TX1/TX2_ENABLE pins
+		adi,arm-gpio-tx-rx-pin-mode = <1>;		// 0= ARM command mode, 1 = Pin mode to power up Tx/Rx chains
+		adi,arm-gpio-orx-pin-mode = <1>;		// 0= ARM command mode, 1 = Pin mode to power up ObsRx receiver
+		// to be tested: enable pin-mode but NOT enable gpio-ack
+		adi,arm-gpio-orx-trigger-pin = <0>;		// Select desired GPIO pin (valid 4-15)
+		adi,arm-gpio-orx-mode2-pin = <0>;		// Select desired GPIO pin (valid 0-18)
+		adi,arm-gpio-orx-mode1-pin = <0>;		// Select desired GPIO pin (valid 0-18)
+		adi,arm-gpio-orx-mode0-pin = <0>;		// Select desired GPIO pin (valid 0-18)
+		adi,arm-gpio-rx1-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-rx2-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-tx1-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-tx2-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-orx1-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-orx2-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-srx-enable-ack = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable
+		adi,arm-gpio-tx-obs-select = <0>;		// Select desired GPIO pin (0-15), [4] = Output Enable.
+			// When 2 Tx are used with only 1 ORx input, this GPIO tells BBIC which Tx channel is active
+			// for calibrations, so BBIC can route correct RF Tx path into the single ORx input
+		adi,arm-gpio-enable-mask = <0>;
+#endif
+	};
+};
diff --git a/arch/arm/boot/dts/facc-zc706ad9371n2.dtsi b/arch/arm/boot/dts/facc-zc706ad9371n2.dtsi
new file mode 100644
index 0000000..ee40306
--- /dev/null
+++ b/arch/arm/boot/dts/facc-zc706ad9371n2.dtsi
@@ -0,0 +1,262 @@
+&fpga_axi {
+
+	rx_dma: rx-dmac@7c400000 {
+		compatible = "adi,axi-dmac-1.00.a";
+		reg = <0x7c400000 0x10000>;
+		#dma-cells = <1>;
+		interrupts = <0 57 0>;
+		clocks = <&clkc 16>;
+
+		dma-channel {
+			adi,buswidth = <64>;
+			adi,type = <0>;
+		};
+	};
+
+	rx_obs_dma: rx-obs-dmac@7c440000  {
+		compatible = "adi,axi-dmac-1.00.a";
+		reg = <0x7c440000  0x10000>;
+		#dma-cells = <1>;
+		interrupts = <0 55 0>;
+		clocks = <&clkc 16>;
+
+		dma-channel {
+			adi,buswidth = <64>;
+			adi,type = <0>;
+		};
+	};
+
+	tx_dma: tx-dmac@7c420000 {
+		compatible = "adi,axi-dmac-1.00.a";
+		reg = <0x7c420000 0x10000>;
+		#dma-cells = <1>;
+		interrupts = <0 56 0>;
+		clocks = <&clkc 16>;
+
+		dma-channel {
+			adi,buswidth = <128>;
+			adi,type = <1>;
+			adi,cyclic;
+		};
+	};
+
+	axi_ad9371_core_rx: axi-ad9371-rx-hpc@44a00000 {
+		compatible = "adi,axi-ad9371-rx-1.0";
+		reg = <0x44a00000 0x8000>;
+		dmas = <&rx_dma 0>;
+		dma-names = "rx";
+		spibus-connected = <&trx0_ad9371>;
+	};
+
+	axi_ad9371_core_rx_obs: axi-ad9371-rx-obs-hpc@44a08000 {
+		compatible = "adi,axi-ad9371-obs-1.0";
+		reg = <0x44a08000 0x1000>;
+		dmas = <&rx_obs_dma 0>;
+		dma-names = "rx";
+		clocks = <&trx0_ad9371 1>;
+		clock-names = "sampl_clk";
+	};
+
+	axi_ad9371_core_tx: axi-ad9371-tx-hpc@44a04000 {
+		compatible = "adi,axi-ad9371-tx-1.0";
+		reg = <0x44a04000 0x4000>;
+		dmas = <&tx_dma 0>;
+		dma-names = "tx";
+		clocks = <&trx0_ad9371 2>;
+		clock-names = "sampl_clk";
+		spibus-connected = <&trx0_ad9371>;
+		adi,axi-pl-fifo-enable;
+	};
+
+	axi_ad9371_rx_jesd: axi-jesd204-rx@44aa0000 {
+		compatible = "adi,axi-jesd204-rx-1.0";
+		reg = <0x44aa0000 0x1000>;
+
+		interrupts = <0 54 0>;
+
+		clocks = <&clkc 16>, <&axi_rx_clkgen>, <&axi_ad9371_adxcvr_rx 0>;
+		clock-names = "s_axi_aclk", "device_clk", "lane_clk";
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd_rx_lane_clk";
+
+		adi,octets-per-frame = <4>;
+		adi,frames-per-multiframe = <32>;
+	};
+
+	axi_ad9371_rx_os_jesd: axi-jesd204-rx@44ab0000 {
+		compatible = "adi,axi-jesd204-rx-1.0";
+		reg = <0x44ab0000 0x1000>;
+
+		interrupts = <0 52 0>;
+
+		clocks = <&clkc 16>, <&axi_rx_os_clkgen>, <&axi_ad9371_adxcvr_rx_os 0>;
+		clock-names = "s_axi_aclk", "device_clk", "lane_clk";
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd_rx_os_lane_clk";
+
+		adi,octets-per-frame = <2>;
+		adi,frames-per-multiframe = <32>;
+	};
+
+	axi_ad9371_tx_jesd: axi-jesd204-tx@44a90000 {
+		compatible = "adi,axi-jesd204-tx-1.0";
+		reg = <0x44a90000 0x1000>;
+
+		interrupts = <0 53 0>;
+
+		clocks = <&clkc 16>, <&axi_tx_clkgen>, <&axi_ad9371_adxcvr_tx 0>;
+		clock-names = "s_axi_aclk", "device_clk", "lane_clk";
+
+		#clock-cells = <0>;
+		clock-output-names = "jesd_tx_lane_clk";
+
+		adi,octets-per-frame = <2>;
+		adi,frames-per-multiframe = <32>;
+		adi,converter-resolution = <14>;
+		adi,bits-per-sample = <16>;
+		adi,converters-per-device = <4>;
+		adi,control-bits-per-sample = <2>;
+	};
+
+
+	axi_tx_clkgen: axi-clkgen@43c00000  {
+		compatible = "adi,axi-clkgen-2.00.a";
+		reg = <0x43c00000 0x10000>;
+		#clock-cells = <0>;
+		clocks = <&clk0_ad9528 1>;
+		clock-output-names = "axi_tx_clkgen";
+	};
+
+	axi_rx_clkgen: axi-clkgen@43c10000  {
+		compatible = "adi,axi-clkgen-2.00.a";
+		reg = <0x43c10000 0x10000>;
+		#clock-cells = <0>;
+		clocks = <&clk0_ad9528 1>;
+		clock-output-names = "axi_rx_clkgen";
+	};
+
+	axi_rx_os_clkgen: axi-clkgen@43c20000  {
+		compatible = "adi,axi-clkgen-2.00.a";
+		reg = <0x43c20000 0x10000>;
+		#clock-cells = <0>;
+		clocks = <&clk0_ad9528 1>;
+		clock-output-names = "axi_rx_os_clkgen";
+	};
+
+	axi_ad9371_adxcvr_rx: axi-adxcvr-rx@44a60000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "adi,axi-adxcvr-1.0";
+		reg = <0x44a60000 0x1000>;
+
+		clocks = <&clk0_ad9528 1>, <&axi_rx_clkgen 0>;
+		clock-names = "conv", "div40";
+
+		#clock-cells = <1>;
+		clock-output-names = "rx_gt_clk", "rx_out_clk";
+
+		adi,sys-clk-select = <0>;
+		adi,out-clk-select = <3>;
+		adi,use-lpm-enable;
+		adi,use-cpll-enable;
+	};
+
+	axi_ad9371_adxcvr_rx_os: axi-adxcvr-rx-os@44a50000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "adi,axi-adxcvr-1.0";
+		reg = <0x44a50000 0x1000>;
+
+		clocks = <&clk0_ad9528 1>, <&axi_rx_os_clkgen>;
+		clock-names = "conv", "div40";
+
+		#clock-cells = <1>;
+		clock-output-names = "rx_os_gt_clk", "rx_os_out_clk";
+
+		adi,sys-clk-select = <0>;
+		adi,out-clk-select = <3>;
+		adi,use-lpm-enable;
+		adi,use-cpll-enable;
+	};
+
+	axi_ad9371_adxcvr_tx: axi-adxcvr-tx@44a80000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "adi,axi-adxcvr-1.0";
+		reg = <0x44a80000 0x1000>;
+
+		clocks = <&clk0_ad9528 1>, <&axi_tx_clkgen>;
+		clock-names = "conv", "div40";
+
+		#clock-cells = <1>;
+		clock-output-names = "tx_gt_clk", "tx_out_clk";
+
+		adi,sys-clk-select = <3>;
+		adi,out-clk-select = <3>;
+	};
+};
+
+&fmc_spi {
+	trx0_ad9371: ad9371-phy@1 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		#clock-cells = <1>;
+		compatible = "ad9371";
+
+		/* SPI Setup */
+		reg = <1>;
+		spi-max-frequency = <25000000>;
+
+		/* Clocks */
+		clocks = <&axi_ad9371_rx_jesd>, <&axi_ad9371_tx_jesd>, <&axi_ad9371_rx_os_jesd>, <&clk0_ad9528 13>, <&clk0_ad9528 1>;
+		clock-names = "jesd_rx_clk", "jesd_tx_clk", "jesd_rx_os_clk", "dev_clk", "fmc_clk";
+		clock-output-names = "rx_sampl_clk", "rx_os_sampl_clk", "tx_sampl_clk";
+
+		adi,clocks-clk-pll-vco-freq_khz = <9830400>;
+		adi,clocks-device-clock_khz = <122880>;
+		adi,clocks-clk-pll-hs-div = <4>;
+		adi,clocks-clk-pll-vco-div = <2>;
+
+		adi,jesd204-obs-framer-over-sample = <0>;
+
+		adi,rx-profile-adc-div = <1>;
+		adi,rx-profile-en-high-rej-dec5 = <1>;
+		adi,rx-profile-iq-rate_khz = <122880>;
+		adi,rx-profile-rf-bandwidth_hz = <100000000>;
+		adi,rx-profile-rhb1-decimation = <1>;
+		adi,rx-profile-rx-bbf-3db-corner_khz = <100000>;
+		adi,rx-profile-rx-dec5-decimation = <5>;
+		adi,rx-profile-rx-fir-decimation = <2>;
+
+		adi,obs-profile-adc-div = <1>;
+		adi,obs-profile-en-high-rej-dec5 = <0>;
+		adi,obs-profile-iq-rate_khz = <245760>;
+		adi,obs-profile-rf-bandwidth_hz = <200000000>;
+		adi,obs-profile-rhb1-decimation = <1>;
+		adi,obs-profile-rx-bbf-3db-corner_khz = <100000>;
+		adi,obs-profile-rx-dec5-decimation = <5>;
+		adi,obs-profile-rx-fir-decimation = <1>;
+
+		adi,tx-profile-dac-div = <1>;
+		adi,tx-profile-iq-rate_khz = <245760>;
+		adi,tx-profile-primary-sig-bandwidth_hz = <75000000>;
+		adi,tx-profile-rf-bandwidth_hz = <200000000>;
+		adi,tx-profile-thb1-interpolation = <2>;
+		adi,tx-profile-thb2-interpolation = <1>;
+		adi,tx-profile-tx-bbf-3db-corner_khz = <100000>;
+		adi,tx-profile-tx-dac-3db-corner_khz = <189477>;
+		adi,tx-profile-tx-fir-interpolation = <1>;
+		adi,tx-profile-tx-input-hb-interpolation = <1>;
+
+		adi,sniffer-profile-adc-div = <1>;
+		adi,sniffer-profile-en-high-rej-dec5 = <0>;
+		adi,sniffer-profile-iq-rate_khz = <30720>;
+		adi,sniffer-profile-rf-bandwidth_hz = <20000000>;
+		adi,sniffer-profile-rhb1-decimation = <2>;
+		adi,sniffer-profile-rx-bbf-3db-corner_khz = <100000>;
+		adi,sniffer-profile-rx-dec5-decimation = <5>;
+		adi,sniffer-profile-rx-fir-decimation = <4>;
+	};
+};
diff --git a/arch/arm/boot/dts/facc-zc706ad9371x2.dts b/arch/arm/boot/dts/facc-zc706ad9371x2.dts
new file mode 100644
index 0000000..6b73851
--- /dev/null
+++ b/arch/arm/boot/dts/facc-zc706ad9371x2.dts
@@ -0,0 +1,82 @@
+/dts-v1/;
+
+/include/ "zynq-zc706.dtsi"
+/include/ "zynq-zc706-adv7511.dtsi"
+
+&i2c_mux {
+	i2c@5 { /* HPC IIC */
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg = <5>;
+
+		eeprom@50 {
+			compatible = "at24,24c02";
+			reg = <0x50>;
+		};
+
+		eeprom@54 {
+			compatible = "at24,24c02";
+			reg = <0x54>;
+		};
+
+		ad7291@2f {
+			compatible = "adi,ad7291";
+			reg = <0x2f>;
+		};
+	};
+};
+
+&spi0 {
+	status = "okay";
+};
+
+#include "facc-zc706ad9371n1.dtsi"
+#include "facc-zc706ad9371n2.dtsi"
+
+// ad9371_dac_fifo_bypass_s 60
+// ad9528_reset_b,       // 59
+// ad9528_sysref_req,    // 58
+// ad9371_tx1_enable,    // 57
+// ad9371_tx2_enable,    // 56
+// ad9371_rx1_enable,    // 55
+// ad9371_rx2_enable,    // 54
+// ad9371_test,          // 53
+// ad9371_reset_b,       // 52
+// ad9371_gpint,         // 51
+// ad9371_gpio_00,       // 50
+// ad9371_gpio_01,       // 49
+// ad9371_gpio_02,       // 48
+// ad9371_gpio_03,       // 47
+// ad9371_gpio_04,       // 46
+// ad9371_gpio_05,       // 45
+// ad9371_gpio_06,       // 44
+// ad9371_gpio_07,       // 43
+// ad9371_gpio_15,       // 42
+// ad9371_gpio_08,       // 41
+// ad9371_gpio_09,       // 40
+// ad9371_gpio_10,       // 39
+// ad9371_gpio_11,       // 38
+// ad9371_gpio_12,       // 37
+// ad9371_gpio_14,       // 36
+// ad9371_gpio_13,       // 35
+// ad9371_gpio_17,       // 34
+// ad9371_gpio_16,       // 33
+// ad9371_gpio_18}));    // 32 + 54
+
+&trx0_ad9371 {
+	reset-gpios = <&gpio0 106 0>;
+	test-gpios = <&gpio0 107 0>;
+	sysref_req-gpios = <&gpio0 112 0>;
+	rx2_enable-gpios = <&gpio0 108 0>;
+	rx1_enable-gpios = <&gpio0 109 0>;
+	tx2_enable-gpios = <&gpio0 110 0>;
+	tx1_enable-gpios = <&gpio0 111 0>;
+};
+
+&clk0_ad9528 {
+	reset-gpios = <&gpio0 113 0>;
+};
+
+&axi_ad9371_core_tx {
+	plddrbypass-gpios = <&gpio0 114 0>;
+};
diff --git a/arch/arm/boot/dts/facc-zc706ad9528.dtsi b/arch/arm/boot/dts/facc-zc706ad9528.dtsi
new file mode 100644
index 0000000..60753b0
--- /dev/null
+++ b/arch/arm/boot/dts/facc-zc706ad9528.dtsi
@@ -0,0 +1,178 @@
+#define fmc_spi spi0
+
+// ad9528_reset_b,       // 59
+// ad9528_sysref_req,    // 58
+
+&clk0_ad9528 {
+	reset-gpios = <&gpio0 113 0>;
+};
+
+#include <dt-bindings/iio/frequency/ad9528.h>
+
+/ {
+	clocks {
+		ad9371_clkin: clock@0 {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <12288000>;
+			clock-output-names = "ad9371_ext_refclk";
+		};
+	};
+};
+
+&sys_spi {
+	clk0_ad9528: ad9528-1@0 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		#clock-cells = <1>;
+		compatible = "ad9528";
+
+		spi-max-frequency = <10000000>;
+		//adi,spi-3wire-enable;
+		reg = <0>;
+
+		reset-gpios = <&sys_gpio_out 27 0>;
+
+		clock-output-names = "ad9528-1_out0", "ad9528-1_out1", "ad9528-1_out2", "ad9528-1_out3", "ad9528-1_out4", "ad9528-1_out5", "ad9528-1_out6", "ad9528-1_out7", "ad9528-1_out8", "ad9528-1_out9", "ad9528-1_out10", "ad9528-1_out11", "ad9528-1_out12", "ad9528-1_out13";
+		adi,vcxo-freq = <122880000>;
+
+		adi,refa-enable;
+		adi,refa-diff-rcv-enable;
+		adi,refa-r-div = <1>;
+		adi,osc-in-cmos-neg-inp-enable;
+
+		/* PLL1 config */
+		adi,pll1-feedback-div = <1>;/* change from 4 to 1 per RF, 2018/11/01 */
+		adi,pll1-charge-pump-current-nA = <5000>;
+
+		/* PLL2 config */
+		adi,pll2-vco-div-m1 = <3>; /* use 5 for 184320000 output device clock */
+		adi,pll2-n2-div = <10>; /* N / M1 */
+		adi,pll2-r1-div = <1>;
+		adi,pll2-charge-pump-current-nA = <805000>;
+
+		/* SYSREF config */
+		adi,sysref-src = <SYSREF_SRC_INTERNAL>;/* SYSREF Mode3: Internal */
+		adi,sysref-pattern-mode = <SYSREF_PATTERN_CONTINUOUS>;
+		adi,sysref-k-div = <512>;
+		/* [0x0402]bit7: SYSREF request method: 1/hardware(SYSREF_REQ), 0/software(SPI-interface) */
+		//adi,sysref-request-enable;
+		adi,sysref-nshot-mode = <SYSREF_NSHOT_4_PULSES>;
+		adi,sysref-request-trigger-mode = <SYSREF_LEVEL_HIGH>;
+
+		adi,rpole2 = <RPOLE2_900_OHM>;
+		adi,rzero = <RZERO_1850_OHM>;
+		adi,cpole1 = <CPOLE1_16_PF>;
+
+		adi,status-mon-pin0-function-select = <1>; /* PLL1 & PLL2 Locked */
+		adi,status-mon-pin1-function-select = <7>; /* REFA Correct */
+
+		ad9528_0_c6: channel@6 {
+			reg = <6>;
+			adi,extended-name = "DEV_CLK_N1";
+			adi,driver-mode = <DRIVER_MODE_LVDS>;
+			adi,divider-phase = <0>;
+			adi,channel-divider = <10>;
+			adi,signal-source = <SOURCE_VCO>;
+		};
+
+		ad9528_0_c3: channel@3 {
+			reg = <3>;
+			adi,extended-name = "FMC_CLK_M1";
+			adi,driver-mode = <DRIVER_MODE_LVDS>;
+			adi,divider-phase = <0>;
+			adi,channel-divider = <10>;
+			adi,signal-source = <SOURCE_VCO>;
+		};
+
+		ad9528_0_c5: channel@5 {
+			reg = <5>;
+			adi,extended-name = "DEV_SYSREF_N1";
+			adi,driver-mode = <DRIVER_MODE_LVDS>;
+			adi,divider-phase = <0>;
+			adi,channel-divider = <10>;
+			adi,signal-source = <SOURCE_SYSREF_VCO>;
+		};
+
+		ad9528_0_c2: channel@2 {
+			reg = <2>;
+			adi,extended-name = "FMC_SYSREF_M1";
+			adi,driver-mode = <DRIVER_MODE_LVDS>;
+			adi,divider-phase = <0>;
+			adi,channel-divider = <10>;
+			adi,signal-source = <SOURCE_SYSREF_VCO>;
+		};
+
+		ad9528_0_c0: channel@0 {
+			reg = <0>;
+			adi,extended-name = "DEV_SYSREF_N2";
+			adi,driver-mode = <DRIVER_MODE_LVDS>;
+			adi,divider-phase = <0>;
+			adi,channel-divider = <10>;
+			adi,signal-source = <SOURCE_SYSREF_VCO>;
+		};
+
+		ad9528_0_c1: channel@1 {
+			reg = <1>;
+			adi,extended-name = "DEV_CLK_N2";
+			adi,driver-mode = <DRIVER_MODE_LVDS>;
+			adi,divider-phase = <0>;
+			adi,channel-divider = <10>;
+			adi,signal-source = <SOURCE_VCO>;
+		};
+
+		ad9528_0_c7: channel@7 {
+			reg = <7>;
+			adi,extended-name = "DEV_SYSREF_N4";
+			adi,driver-mode = <DRIVER_MODE_LVDS>;
+			adi,divider-phase = <0>;
+			adi,channel-divider = <10>;
+			adi,signal-source = <SOURCE_SYSREF_VCO>;
+		};
+
+		ad9528_0_c8: channel@8 {
+			reg = <8>;
+			adi,extended-name = "DEV_CLK_N4";
+			adi,driver-mode = <DRIVER_MODE_LVDS>;
+			adi,divider-phase = <0>;
+			adi,channel-divider = <10>;
+			adi,signal-source = <SOURCE_VCO>;
+		};
+
+		ad9528_0_c12: channel@12 {
+			reg = <12>;
+			adi,extended-name = "DEV_SYSREF_N3";
+			adi,driver-mode = <DRIVER_MODE_LVDS>;
+			adi,divider-phase = <0>;
+			adi,channel-divider = <10>;
+			adi,signal-source = <SOURCE_SYSREF_VCO>;
+		};
+
+		ad9528_0_c13: channel@13 {
+			reg = <13>;
+			adi,extended-name = "DEV_CLK_N3";
+			adi,driver-mode = <DRIVER_MODE_LVDS>;
+			adi,divider-phase = <0>;
+			adi,channel-divider = <10>;
+			adi,signal-source = <SOURCE_VCO>;
+		};
+
+		ad9528_0_c9: channel@9 {
+			reg = <9>;
+			adi,extended-name = "FMC_SYSREF_M2";
+			adi,driver-mode = <DRIVER_MODE_LVDS>;
+			adi,divider-phase = <0>;
+			adi,channel-divider = <10>;
+			adi,signal-source = <SOURCE_SYSREF_VCO>;
+		};
+
+		ad9528_0_c11: channel@11 {
+			reg = <11>;
+			adi,extended-name = "FMC_CLK_M2";
+			adi,driver-mode = <DRIVER_MODE_LVDS>;
+			adi,divider-phase = <0>;
+			adi,channel-divider = <10>;
+			adi,signal-source = <SOURCE_VCO>;
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/i2c_dev_si5338.dtsi b/arch/arm/boot/dts/i2c_dev_si5338.dtsi
new file mode 100644
index 0000000..7455b9e
--- /dev/null
+++ b/arch/arm/boot/dts/i2c_dev_si5338.dtsi
@@ -0,0 +1,103 @@
+/*
+ * Reference: linux/Documentation/devicetree/bindings/clock/silabs,si5338.txt
+ */
+
+#include <dt-bindings/clock/clk-si5338.h>
+
+/ {
+    clocks {
+    	/* 25MHz reference crystal */
+		si5338_xtal: ref25M_si5338 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <25000000>;
+		};
+
+		si5338_clkin56: ref100M_si5338 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <100000000>;
+		};
+	};
+};
+
+&i2c1 {
+	/* reference:
+	 * https://rocketboards.org/foswiki/Documentation/
+	 * ProgramSi5338QuadClockGeneratorOnArria10SoCDevKit
+	 */
+	//i2c-sda-falling-time-ns = <0>;
+	//i2c-scl-falling-time-ns = <0>;
+	i2c-sda-hold-time-ns = <160>;
+
+	/* reference: "Si5338-RevB-Registers.h" produced
+	 * by SilconLab "CLOCKBUILDER DESKTOP" tool
+	 */
+	si5338: clkgen_si5338@71 {
+		compatible = "silabs,si5338";
+		reg = <0x71>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		#clock-cells = <1>;
+
+		/* connect xtal to 25MHz, in5/in6 to 100MHz */
+		//clocks = <&si5338_xtal>, <0>, <0>, <0>, <&si5338_clkin56>;
+		clocks = <&si5338_xtal>, <0>, <0>, <0>, <0>;
+		clock-names = "xtal", "in12", "in3", "in4", "in56";
+
+		/* connect xtal as source of refclk */
+		silabs,ref-source = <SI5338_REF_SRC_XTAL>;
+
+		/* connect in5/in6 as source of fbclk */
+		//silabs,fb-source = <SI5338_FB_SRC_CLKIN56>;
+		silabs,fb-source = <SI5338_FB_SRC_NOCLK>;
+
+		/* connect divrefclk as source of pll */
+		silabs,pll-source = <SI5338_PFD_IN_REF_XOCLK>;
+
+		/* Choose one MS for pll master */
+		silabs,pll-master = <0>;
+
+		/* Specify pll-vco frequency. pll-master is ignored. */
+		silabs,pll-vco = <2500000000>; /* N=100 */
+		//silabs,pll-vco = <2578125000>; /* N=103.125 */
+
+		/* output */
+		clkout0 {
+			reg = <0>;
+			silabs,drive-config = "2V5_LVDS";
+			silabs,clock-source = <SI5338_OUT_MUX_MS0>;
+			silabs,disable-state = <SI5338_OUT_DIS_HIZ>;
+			/* 125M per Si5338-RevB-Registers.h */
+			clock-frequency = <125000000>;
+			enabled;
+		};
+		clkout1 {
+			reg = <1>;
+			silabs,drive-config = "2V5_LVDS";
+			silabs,clock-source = <SI5338_OUT_MUX_MSN>;
+			silabs,disable-state = <SI5338_OUT_DIS_HIZ>;
+			/* 270M per Si5338-RevB-Registers.h */
+			clock-frequency = <270000000>;
+			enabled;
+		};
+		clkout2 {
+			reg = <2>;
+			silabs,drive-config = "2V5_LVDS";
+			silabs,clock-source = <SI5338_OUT_MUX_MSN>;
+			silabs,disable-state = <SI5338_OUT_DIS_HIZ>;
+			/* 322.265625M per Si5338-RevB-Registers.h */
+			clock-frequency = <322265625>;
+			enabled;
+		};
+		clkout3 {
+			reg = <3>;
+			silabs,drive-config = "2V5_LVDS";
+			silabs,clock-source = <SI5338_OUT_MUX_MSN>;
+			silabs,disable-state = <SI5338_OUT_DIS_HIZ>;
+			/* 125M per Si5338-RevB-Registers.h */
+			clock-frequency = <125000000>;
+			enabled;
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/socfpga_arria10.dtsi b/arch/arm/boot/dts/socfpga_arria10.dtsi
index 41b9f6e..c2c72b2 100644
--- a/arch/arm/boot/dts/socfpga_arria10.dtsi
+++ b/arch/arm/boot/dts/socfpga_arria10.dtsi
@@ -585,7 +585,7 @@
 			#address-cells = <1>;
 			#size-cells = <0>;
 			reg = <0xffda5000 0x100>;
-			interrupts = <0 102 4>;
+			interrupts = <0 102 IRQ_TYPE_LEVEL_HIGH>;
 			num-chipselect = <4>;
 			bus-num = <0>;
 			/*32bit_access;*/
@@ -630,7 +630,7 @@
 			reg = <0xffb90000 0x72000>,
 			      <0xffb80000 0x10000>;
 			reg-names = "nand_data", "denali_reg";
-			interrupts = <0 99 4>;
+			interrupts = <0 99 IRQ_TYPE_LEVEL_HIGH>;
 			dma-mask = <0xffffffff>;
 			clocks = <&nand_clk>;
 			status = "disabled";
diff --git a/arch/arm/boot/dts/socfpga_arria10_socdk.dtsi b/arch/arm/boot/dts/socfpga_arria10_socdk.dtsi
index 21c0eb7..792fe1b 100644
--- a/arch/arm/boot/dts/socfpga_arria10_socdk.dtsi
+++ b/arch/arm/boot/dts/socfpga_arria10_socdk.dtsi
@@ -96,6 +96,7 @@
 	rxdv-skew-ps = <420>; /* 0ps */
 	rxc-skew-ps = <1680>; /* 780ps */
 	max-frame-size = <3800>;
+	//max-frame-size = <5000>; /* iperf performace is worse than 3800 */
 	status = "okay";
 };
 
@@ -136,8 +137,12 @@
 	 * because the LCD module does not work at the standard 100Khz
 	 */
 	clock-frequency = <100000>;
-	i2c-sda-falling-time-ns = <6000>;
-	i2c-scl-falling-time-ns = <6000>;
+	/* to enable si5338, reference:
+	 * https://rocketboards.org/foswiki/Documentation/
+	 * ProgramSi5338QuadClockGeneratorOnArria10SoCDevKit
+	 */
+	//i2c-sda-falling-time-ns = <6000>;
+	//i2c-scl-falling-time-ns = <6000>;
 
 	lcd: lcd@28 {
 		compatible = "newhaven,nhd-0216k3z-nsw-bbw";
diff --git a/arch/arm/configs/facc_a10ad9371_defconfig b/arch/arm/configs/facc_a10ad9371_defconfig
new file mode 100644
index 0000000..d467c6e
--- /dev/null
+++ b/arch/arm/configs/facc_a10ad9371_defconfig
@@ -0,0 +1,201 @@
+CONFIG_SYSVIPC=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_CGROUPS=y
+CONFIG_CPUSETS=y
+CONFIG_NAMESPACES=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_EMBEDDED=y
+CONFIG_PROFILING=y
+CONFIG_OPROFILE=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_IOSCHED_DEADLINE is not set
+# CONFIG_IOSCHED_CFQ is not set
+CONFIG_ARCH_SOCFPGA=y
+CONFIG_ARM_THUMBEE=y
+CONFIG_SMP=y
+CONFIG_NR_CPUS=2
+CONFIG_AEABI=y
+CONFIG_HIGHMEM=y
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_VFP=y
+CONFIG_NEON=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_NET_KEY=y
+CONFIG_NET_KEY_MIGRATE=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+CONFIG_NETWORK_PHY_TIMESTAMPING=y
+CONFIG_VLAN_8021Q=y
+CONFIG_VLAN_8021Q_GVRP=y
+CONFIG_CAN=y
+CONFIG_CAN_C_CAN=y
+CONFIG_CAN_C_CAN_PLATFORM=y
+CONFIG_CAN_DEBUG_DEVICES=y
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_EXTRA_FIRMWARE="Mykonos_M3.bin TaliseStream.bin TaliseTDDArmFirmware.bin"
+CONFIG_MTD=y
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_M25P80=y
+CONFIG_MTD_NAND=y
+CONFIG_MTD_NAND_DENALI_DT=y
+CONFIG_MTD_SPI_NOR=y
+# CONFIG_MTD_SPI_NOR_USE_4K_SECTORS is not set
+CONFIG_SPI_CADENCE_QUADSPI=y
+CONFIG_OF_OVERLAY=y
+CONFIG_OF_CONFIGFS=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=2
+CONFIG_BLK_DEV_RAM_SIZE=8192
+CONFIG_TI_LMK04828=y
+CONFIG_SRAM=y
+CONFIG_ALTERA_SYSID=m
+CONFIG_EEPROM_AT24=y
+CONFIG_SCSI=y
+# CONFIG_SCSI_PROC_FS is not set
+CONFIG_BLK_DEV_SD=y
+# CONFIG_SCSI_LOWLEVEL is not set
+CONFIG_NETDEVICES=y
+CONFIG_ALTERA_TSE=m
+CONFIG_STMMAC_ETH=y
+CONFIG_MARVELL_PHY=y
+CONFIG_MICREL_PHY=y
+CONFIG_INPUT_EVDEV=y
+# CONFIG_SERIO_SERPORT is not set
+CONFIG_SERIO_AMBAKMI=y
+CONFIG_LEGACY_PTY_COUNT=16
+CONFIG_NEWHAVEN_LCD=y
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=2
+CONFIG_SERIAL_8250_RUNTIME_UARTS=2
+CONFIG_SERIAL_8250_DW=y
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_DESIGNWARE_PLATFORM=y
+CONFIG_SPI=y
+CONFIG_SPI_ALTERA=y
+CONFIG_SPI_DESIGNWARE=y
+CONFIG_SPI_DW_MMIO=y
+CONFIG_SPI_SPIDEV=y
+CONFIG_PPS_CLIENT_KTIMER=m
+CONFIG_PPS_CLIENT_GPIO=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_ALTERA=y
+CONFIG_GPIO_DWAPB=y
+CONFIG_GPIO_A10SYCON=y
+CONFIG_SENSORS_A10SYCON=y
+CONFIG_SENSORS_MAX1619=y
+CONFIG_PMBUS=y
+CONFIG_SENSORS_LTC2978=y
+CONFIG_SENSORS_LTC2978_REGULATOR=y
+CONFIG_WATCHDOG=y
+CONFIG_DW_WATCHDOG=y
+CONFIG_MFD_A10SYCON=y
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_FB=y
+CONFIG_FB_ALTERA_VIP=y
+CONFIG_USB=y
+CONFIG_USB_OTG=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_DWC2=y
+CONFIG_NOP_USB_XCEIV=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_CONFIGFS=y
+CONFIG_USB_CONFIGFS_ACM=y
+CONFIG_USB_CONFIGFS_ECM=y
+CONFIG_USB_CONFIGFS_ECM_SUBSET=y
+CONFIG_USB_CONFIGFS_MASS_STORAGE=y
+CONFIG_USB_CONFIGFS_F_FS=y
+CONFIG_USB_CONFIGFS_F_HID=y
+CONFIG_USB_ETH=y
+CONFIG_MMC=y
+CONFIG_MMC_DW=y
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_GPIO=y
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_LEDS_TRIGGER_CPU=y
+CONFIG_RTC_CLASS=y
+# CONFIG_RTC_HCTOSYS is not set
+CONFIG_RTC_DRV_DS1307=y
+CONFIG_DMADEVICES=y
+CONFIG_AXI_DMAC=y
+CONFIG_PL330_DMA=y
+CONFIG_DMATEST=m
+CONFIG_COMMON_CLK_SI5338=m
+CONFIG_COMMON_CLK_SI5338SIMPLE=y
+CONFIG_COMMON_CLK_ALTERA_A10_FPLL=y
+CONFIG_IIO=y
+CONFIG_IIO_TRIGGER=y
+CONFIG_AD7291=y
+CONFIG_AD9361=y
+CONFIG_AD9371=y
+CONFIG_ADRV9009=y
+CONFIG_AD9467=y
+CONFIG_AD9680=y
+CONFIG_ADMC=y
+CONFIG_ALTERA_XCVR=y
+CONFIG_AD9523=y
+CONFIG_AD9528=y
+CONFIG_AD9548=y
+CONFIG_CF_AXI_DDS=y
+CONFIG_CF_AXI_DDS_AD9144=y
+CONFIG_JESD204=y
+CONFIG_ALTERA_ARRIA10_JESD204_PHY=y
+CONFIG_AXI_ADXCVR=y
+CONFIG_AXI_JESD204B=y
+CONFIG_AXI_JESD204_TX=y
+CONFIG_AXI_JESD204_RX=y
+CONFIG_FPGA=y
+CONFIG_FPGA_REGION=y
+CONFIG_FPGA_MGR_SOCFPGA=y
+CONFIG_FPGA_MGR_SOCFPGA_A10=y
+CONFIG_FPGA_BRIDGE=y
+CONFIG_SOCFPGA_FPGA_BRIDGE=y
+CONFIG_ALTERA_FREEZE_BRIDGE=y
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EXT2_FS_POSIX_ACL=y
+CONFIG_EXT3_FS=y
+# CONFIG_DNOTIFY is not set
+CONFIG_AUTOFS4_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_NTFS_FS=y
+CONFIG_NTFS_RW=y
+CONFIG_TMPFS=y
+CONFIG_JFFS2_FS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V4=y
+CONFIG_ROOT_NFS=y
+CONFIG_NFSD=y
+CONFIG_NFSD_V4=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_PRINTK_TIME=y
+CONFIG_DEBUG_INFO=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_DETECT_HUNG_TASK=y
+# CONFIG_SCHED_DEBUG is not set
+CONFIG_FUNCTION_TRACER=y
+CONFIG_DEBUG_USER=y
+CONFIG_DEBUG_LL=y
+CONFIG_DEBUG_SOCFPGA_UART1=y
+CONFIG_EARLY_PRINTK=y
diff --git a/arch/arm/configs/facc_a10ad9371m_defconfig b/arch/arm/configs/facc_a10ad9371m_defconfig
new file mode 100644
index 0000000..93e3f98
--- /dev/null
+++ b/arch/arm/configs/facc_a10ad9371m_defconfig
@@ -0,0 +1,207 @@
+CONFIG_SYSVIPC=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_CGROUPS=y
+CONFIG_CPUSETS=y
+CONFIG_NAMESPACES=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_EMBEDDED=y
+CONFIG_PROFILING=y
+CONFIG_OPROFILE=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_IOSCHED_DEADLINE is not set
+# CONFIG_IOSCHED_CFQ is not set
+CONFIG_ARCH_SOCFPGA=y
+CONFIG_ARM_THUMBEE=y
+CONFIG_SMP=y
+CONFIG_NR_CPUS=2
+CONFIG_AEABI=y
+CONFIG_HIGHMEM=y
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_VFP=y
+CONFIG_NEON=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_NET_KEY=y
+CONFIG_NET_KEY_MIGRATE=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+CONFIG_NETWORK_PHY_TIMESTAMPING=y
+CONFIG_VLAN_8021Q=y
+CONFIG_VLAN_8021Q_GVRP=y
+CONFIG_CAN=y
+CONFIG_CAN_C_CAN=y
+CONFIG_CAN_C_CAN_PLATFORM=y
+CONFIG_CAN_DEBUG_DEVICES=y
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_EXTRA_FIRMWARE="Mykonos_M3.bin TaliseStream.bin TaliseTDDArmFirmware.bin"
+CONFIG_MTD=y
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_M25P80=y
+CONFIG_MTD_NAND=y
+CONFIG_MTD_NAND_DENALI_DT=y
+CONFIG_MTD_SPI_NOR=y
+# CONFIG_MTD_SPI_NOR_USE_4K_SECTORS is not set
+CONFIG_SPI_CADENCE_QUADSPI=y
+CONFIG_OF_OVERLAY=y
+CONFIG_OF_CONFIGFS=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=2
+CONFIG_BLK_DEV_RAM_SIZE=8192
+CONFIG_TI_LMK04828=y
+CONFIG_SRAM=y
+CONFIG_ALTERA_SYSID=m
+CONFIG_EEPROM_AT24=y
+CONFIG_SCSI=y
+# CONFIG_SCSI_PROC_FS is not set
+CONFIG_BLK_DEV_SD=y
+# CONFIG_SCSI_LOWLEVEL is not set
+CONFIG_NETDEVICES=y
+CONFIG_ALTERA_TSE=m
+CONFIG_STMMAC_ETH=y
+CONFIG_MARVELL_PHY=y
+CONFIG_MICREL_PHY=y
+CONFIG_INPUT_EVDEV=y
+# CONFIG_SERIO_SERPORT is not set
+CONFIG_SERIO_AMBAKMI=y
+CONFIG_LEGACY_PTY_COUNT=16
+CONFIG_NEWHAVEN_LCD=y
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=2
+CONFIG_SERIAL_8250_RUNTIME_UARTS=2
+CONFIG_SERIAL_8250_DW=y
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_DESIGNWARE_PLATFORM=y
+CONFIG_SPI=y
+CONFIG_SPI_ALTERA=y
+CONFIG_SPI_DESIGNWARE=y
+CONFIG_SPI_DW_MMIO=y
+CONFIG_SPI_SPIDEV=y
+CONFIG_PPS_CLIENT_KTIMER=m
+CONFIG_PPS_CLIENT_GPIO=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_ALTERA=y
+CONFIG_GPIO_DWAPB=y
+CONFIG_GPIO_A10SYCON=y
+CONFIG_SENSORS_A10SYCON=y
+CONFIG_SENSORS_MAX1619=y
+CONFIG_PMBUS=y
+CONFIG_SENSORS_LTC2978=y
+CONFIG_SENSORS_LTC2978_REGULATOR=y
+CONFIG_WATCHDOG=y
+CONFIG_DW_WATCHDOG=y
+CONFIG_MFD_A10SYCON=y
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_FB=y
+CONFIG_FB_ALTERA_VIP=y
+CONFIG_USB=y
+CONFIG_USB_OTG=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_DWC2=y
+CONFIG_NOP_USB_XCEIV=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_CONFIGFS=y
+CONFIG_USB_CONFIGFS_ACM=y
+CONFIG_USB_CONFIGFS_ECM=y
+CONFIG_USB_CONFIGFS_ECM_SUBSET=y
+CONFIG_USB_CONFIGFS_MASS_STORAGE=y
+CONFIG_USB_CONFIGFS_F_FS=y
+CONFIG_USB_CONFIGFS_F_HID=y
+CONFIG_USB_ETH=y
+CONFIG_MMC=y
+CONFIG_MMC_DW=y
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_GPIO=y
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_LEDS_TRIGGER_CPU=y
+CONFIG_RTC_CLASS=y
+# CONFIG_RTC_HCTOSYS is not set
+CONFIG_RTC_DRV_DS1307=y
+CONFIG_DMADEVICES=y
+CONFIG_DMA_VIRTUAL_CHANNELS=m
+CONFIG_AXI_DMAC=m
+CONFIG_PL330_DMA=y
+CONFIG_DMATEST=m
+CONFIG_COMMON_CLK_SI5338=m
+CONFIG_COMMON_CLK_SI5338SIMPLE=y
+CONFIG_COMMON_CLK_ALTERA_A10_FPLL=m
+CONFIG_IIO=y
+#CONFIG_IIO_BUFFER=y
+#CONFIG_IIO_BUFFER_DMA=y
+#CONFIG_IIO_BUFFER_DMAENGINE=y
+#CONFIG_IIO_HW_CONSUMER=y
+CONFIG_IIO_TRIGGER=y
+CONFIG_AD7291=y
+CONFIG_CF_AXI_ADC=m
+CONFIG_AD9361=m
+CONFIG_AD9371=m
+CONFIG_ADRV9009=y
+CONFIG_AD9467=m
+CONFIG_AD9680=m
+CONFIG_ADMC=m
+CONFIG_ALTERA_XCVR=y
+CONFIG_AD9523=y
+CONFIG_AD9528=m
+CONFIG_AD9548=y
+CONFIG_CF_AXI_DDS=m
+CONFIG_CF_AXI_DDS_AD9144=m
+CONFIG_JESD204=y
+CONFIG_ALTERA_ARRIA10_JESD204_PHY=m
+CONFIG_AXI_ADXCVR=y
+CONFIG_AXI_JESD204B=y
+CONFIG_AXI_JESD204_TX=m
+CONFIG_AXI_JESD204_RX=m
+CONFIG_FPGA=y
+CONFIG_FPGA_REGION=y
+CONFIG_FPGA_MGR_SOCFPGA=y
+CONFIG_FPGA_MGR_SOCFPGA_A10=y
+CONFIG_FPGA_BRIDGE=y
+CONFIG_SOCFPGA_FPGA_BRIDGE=y
+CONFIG_ALTERA_FREEZE_BRIDGE=y
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EXT2_FS_POSIX_ACL=y
+CONFIG_EXT3_FS=y
+# CONFIG_DNOTIFY is not set
+CONFIG_AUTOFS4_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_NTFS_FS=y
+CONFIG_NTFS_RW=y
+CONFIG_TMPFS=y
+CONFIG_JFFS2_FS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V4=y
+CONFIG_ROOT_NFS=y
+CONFIG_NFSD=y
+CONFIG_NFSD_V4=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_PRINTK_TIME=y
+CONFIG_DEBUG_INFO=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_DETECT_HUNG_TASK=y
+# CONFIG_SCHED_DEBUG is not set
+CONFIG_FUNCTION_TRACER=y
+CONFIG_DEBUG_USER=y
+CONFIG_DEBUG_LL=y
+CONFIG_DEBUG_SOCFPGA_UART1=y
+CONFIG_EARLY_PRINTK=y
diff --git a/arch/arm/configs/facc_a10ad9371rt_defconfig b/arch/arm/configs/facc_a10ad9371rt_defconfig
new file mode 100644
index 0000000..1e6f76e
--- /dev/null
+++ b/arch/arm/configs/facc_a10ad9371rt_defconfig
@@ -0,0 +1,203 @@
+CONFIG_SYSVIPC=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_CGROUPS=y
+CONFIG_CPUSETS=y
+CONFIG_NAMESPACES=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_EMBEDDED=y
+CONFIG_PROFILING=y
+CONFIG_OPROFILE=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_IOSCHED_DEADLINE is not set
+# CONFIG_IOSCHED_CFQ is not set
+CONFIG_ARCH_SOCFPGA=y
+CONFIG_ARM_THUMBEE=y
+CONFIG_SMP=y
+CONFIG_NR_CPUS=2
+CONFIG_PREEMPT_RT_FULL=y
+CONFIG_HZ_100=y
+CONFIG_AEABI=y
+CONFIG_HIGHMEM=y
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_VFP=y
+CONFIG_NEON=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_NET_KEY=y
+CONFIG_NET_KEY_MIGRATE=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+CONFIG_NETWORK_PHY_TIMESTAMPING=y
+CONFIG_VLAN_8021Q=y
+CONFIG_VLAN_8021Q_GVRP=y
+CONFIG_CAN=y
+CONFIG_CAN_C_CAN=y
+CONFIG_CAN_C_CAN_PLATFORM=y
+CONFIG_CAN_DEBUG_DEVICES=y
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_EXTRA_FIRMWARE="Mykonos_M3.bin TaliseStream.bin TaliseTDDArmFirmware.bin"
+CONFIG_MTD=y
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_M25P80=y
+CONFIG_MTD_NAND=y
+CONFIG_MTD_NAND_DENALI_DT=y
+CONFIG_MTD_SPI_NOR=y
+# CONFIG_MTD_SPI_NOR_USE_4K_SECTORS is not set
+CONFIG_SPI_CADENCE_QUADSPI=y
+CONFIG_OF_OVERLAY=y
+CONFIG_OF_CONFIGFS=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=2
+CONFIG_BLK_DEV_RAM_SIZE=8192
+CONFIG_TI_LMK04828=y
+CONFIG_SRAM=y
+CONFIG_ALTERA_SYSID=m
+CONFIG_EEPROM_AT24=y
+CONFIG_SCSI=y
+# CONFIG_SCSI_PROC_FS is not set
+CONFIG_BLK_DEV_SD=y
+# CONFIG_SCSI_LOWLEVEL is not set
+CONFIG_NETDEVICES=y
+CONFIG_ALTERA_TSE=m
+CONFIG_STMMAC_ETH=y
+CONFIG_MARVELL_PHY=y
+CONFIG_MICREL_PHY=y
+CONFIG_INPUT_EVDEV=y
+# CONFIG_SERIO_SERPORT is not set
+CONFIG_SERIO_AMBAKMI=y
+CONFIG_LEGACY_PTY_COUNT=16
+CONFIG_NEWHAVEN_LCD=y
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=2
+CONFIG_SERIAL_8250_RUNTIME_UARTS=2
+CONFIG_SERIAL_8250_DW=y
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_DESIGNWARE_PLATFORM=y
+CONFIG_SPI=y
+CONFIG_SPI_ALTERA=y
+CONFIG_SPI_DESIGNWARE=y
+CONFIG_SPI_DW_MMIO=y
+CONFIG_SPI_SPIDEV=y
+CONFIG_PPS_CLIENT_KTIMER=m
+CONFIG_PPS_CLIENT_GPIO=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_ALTERA=y
+CONFIG_GPIO_DWAPB=y
+CONFIG_GPIO_A10SYCON=y
+CONFIG_SENSORS_A10SYCON=y
+CONFIG_SENSORS_MAX1619=y
+CONFIG_PMBUS=y
+CONFIG_SENSORS_LTC2978=y
+CONFIG_SENSORS_LTC2978_REGULATOR=y
+CONFIG_WATCHDOG=y
+CONFIG_DW_WATCHDOG=y
+CONFIG_MFD_A10SYCON=y
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_FB=y
+CONFIG_FB_ALTERA_VIP=y
+CONFIG_USB=y
+CONFIG_USB_OTG=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_DWC2=y
+CONFIG_NOP_USB_XCEIV=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_CONFIGFS=y
+CONFIG_USB_CONFIGFS_ACM=y
+CONFIG_USB_CONFIGFS_ECM=y
+CONFIG_USB_CONFIGFS_ECM_SUBSET=y
+CONFIG_USB_CONFIGFS_MASS_STORAGE=y
+CONFIG_USB_CONFIGFS_F_FS=y
+CONFIG_USB_CONFIGFS_F_HID=y
+CONFIG_USB_ETH=y
+CONFIG_MMC=y
+CONFIG_MMC_DW=y
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_GPIO=y
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_LEDS_TRIGGER_CPU=y
+CONFIG_RTC_CLASS=y
+# CONFIG_RTC_HCTOSYS is not set
+CONFIG_RTC_DRV_DS1307=y
+CONFIG_DMADEVICES=y
+CONFIG_AXI_DMAC=y
+CONFIG_PL330_DMA=y
+CONFIG_DMATEST=m
+CONFIG_COMMON_CLK_SI5338=m
+CONFIG_COMMON_CLK_SI5338SIMPLE=y
+CONFIG_COMMON_CLK_ALTERA_A10_FPLL=y
+CONFIG_IIO=y
+CONFIG_IIO_TRIGGER=y
+CONFIG_AD7291=y
+CONFIG_AD9361=y
+CONFIG_AD9371=y
+CONFIG_ADRV9009=y
+CONFIG_AD9467=y
+CONFIG_AD9680=y
+CONFIG_ADMC=y
+CONFIG_ALTERA_XCVR=y
+CONFIG_AD9523=y
+CONFIG_AD9528=y
+CONFIG_AD9548=y
+CONFIG_CF_AXI_DDS=y
+CONFIG_CF_AXI_DDS_AD9144=y
+CONFIG_JESD204=y
+CONFIG_ALTERA_ARRIA10_JESD204_PHY=y
+CONFIG_AXI_ADXCVR=y
+CONFIG_AXI_JESD204B=y
+CONFIG_AXI_JESD204_TX=y
+CONFIG_AXI_JESD204_RX=y
+CONFIG_FPGA=y
+CONFIG_FPGA_REGION=y
+CONFIG_FPGA_MGR_SOCFPGA=y
+CONFIG_FPGA_MGR_SOCFPGA_A10=y
+CONFIG_FPGA_BRIDGE=y
+CONFIG_SOCFPGA_FPGA_BRIDGE=y
+CONFIG_ALTERA_FREEZE_BRIDGE=y
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EXT2_FS_POSIX_ACL=y
+CONFIG_EXT3_FS=y
+# CONFIG_DNOTIFY is not set
+CONFIG_AUTOFS4_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_NTFS_FS=y
+CONFIG_NTFS_RW=y
+CONFIG_TMPFS=y
+CONFIG_JFFS2_FS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V4=y
+CONFIG_ROOT_NFS=y
+CONFIG_NFSD=y
+CONFIG_NFSD_V4=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_PRINTK_TIME=y
+CONFIG_DEBUG_INFO=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_DETECT_HUNG_TASK=y
+# CONFIG_SCHED_DEBUG is not set
+CONFIG_FUNCTION_TRACER=y
+CONFIG_DEBUG_USER=y
+CONFIG_DEBUG_LL=y
+CONFIG_DEBUG_SOCFPGA_UART1=y
+CONFIG_EARLY_PRINTK=y
diff --git a/arch/arm/configs/facc_a10ad9371rtdbg_defconfig b/arch/arm/configs/facc_a10ad9371rtdbg_defconfig
new file mode 100644
index 0000000..acdc8d0
--- /dev/null
+++ b/arch/arm/configs/facc_a10ad9371rtdbg_defconfig
@@ -0,0 +1,216 @@
+CONFIG_SYSVIPC=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_CGROUPS=y
+CONFIG_CPUSETS=y
+CONFIG_NAMESPACES=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_EMBEDDED=y
+CONFIG_PROFILING=y
+CONFIG_OPROFILE=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_IOSCHED_DEADLINE is not set
+# CONFIG_IOSCHED_CFQ is not set
+CONFIG_ARCH_SOCFPGA=y
+CONFIG_ARM_THUMBEE=y
+CONFIG_SMP=y
+CONFIG_NR_CPUS=2
+CONFIG_PREEMPT_RT_FULL=y
+CONFIG_HZ_100=y
+CONFIG_AEABI=y
+CONFIG_HIGHMEM=y
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_VFP=y
+CONFIG_NEON=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_NET_KEY=y
+CONFIG_NET_KEY_MIGRATE=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+CONFIG_NETWORK_PHY_TIMESTAMPING=y
+CONFIG_VLAN_8021Q=y
+CONFIG_VLAN_8021Q_GVRP=y
+CONFIG_CAN=y
+CONFIG_CAN_C_CAN=y
+CONFIG_CAN_C_CAN_PLATFORM=y
+CONFIG_CAN_DEBUG_DEVICES=y
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_EXTRA_FIRMWARE="Mykonos_M3.bin TaliseStream.bin TaliseTDDArmFirmware.bin"
+CONFIG_MTD=y
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_M25P80=y
+CONFIG_MTD_NAND=y
+CONFIG_MTD_NAND_DENALI_DT=y
+CONFIG_MTD_SPI_NOR=y
+# CONFIG_MTD_SPI_NOR_USE_4K_SECTORS is not set
+CONFIG_SPI_CADENCE_QUADSPI=y
+CONFIG_OF_OVERLAY=y
+CONFIG_OF_CONFIGFS=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=2
+CONFIG_BLK_DEV_RAM_SIZE=8192
+CONFIG_TI_LMK04828=y
+CONFIG_SRAM=y
+CONFIG_ALTERA_SYSID=m
+CONFIG_EEPROM_AT24=y
+CONFIG_SCSI=y
+# CONFIG_SCSI_PROC_FS is not set
+CONFIG_BLK_DEV_SD=y
+# CONFIG_SCSI_LOWLEVEL is not set
+CONFIG_NETDEVICES=y
+CONFIG_ALTERA_TSE=m
+CONFIG_STMMAC_ETH=y
+CONFIG_MARVELL_PHY=y
+CONFIG_MICREL_PHY=y
+CONFIG_INPUT_EVDEV=y
+# CONFIG_SERIO_SERPORT is not set
+CONFIG_SERIO_AMBAKMI=y
+CONFIG_LEGACY_PTY_COUNT=16
+CONFIG_NEWHAVEN_LCD=y
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=2
+CONFIG_SERIAL_8250_RUNTIME_UARTS=2
+CONFIG_SERIAL_8250_DW=y
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_DESIGNWARE_PLATFORM=y
+CONFIG_SPI=y
+CONFIG_SPI_ALTERA=y
+CONFIG_SPI_DESIGNWARE=y
+CONFIG_SPI_DW_MMIO=y
+CONFIG_SPI_SPIDEV=y
+CONFIG_PPS_CLIENT_KTIMER=m
+CONFIG_PPS_CLIENT_GPIO=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_ALTERA=y
+CONFIG_GPIO_DWAPB=y
+CONFIG_GPIO_A10SYCON=y
+CONFIG_SENSORS_A10SYCON=y
+CONFIG_SENSORS_MAX1619=y
+CONFIG_PMBUS=y
+CONFIG_SENSORS_LTC2978=y
+CONFIG_SENSORS_LTC2978_REGULATOR=y
+CONFIG_WATCHDOG=y
+CONFIG_DW_WATCHDOG=y
+CONFIG_MFD_A10SYCON=y
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_FB=y
+CONFIG_FB_ALTERA_VIP=y
+CONFIG_USB=y
+CONFIG_USB_OTG=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_DWC2=y
+CONFIG_NOP_USB_XCEIV=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_CONFIGFS=y
+CONFIG_USB_CONFIGFS_ACM=y
+CONFIG_USB_CONFIGFS_ECM=y
+CONFIG_USB_CONFIGFS_ECM_SUBSET=y
+CONFIG_USB_CONFIGFS_MASS_STORAGE=y
+CONFIG_USB_CONFIGFS_F_FS=y
+CONFIG_USB_CONFIGFS_F_HID=y
+CONFIG_USB_ETH=y
+CONFIG_MMC=y
+CONFIG_MMC_DW=y
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_GPIO=y
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_LEDS_TRIGGER_CPU=y
+CONFIG_RTC_CLASS=y
+# CONFIG_RTC_HCTOSYS is not set
+CONFIG_RTC_DRV_DS1307=y
+CONFIG_DMADEVICES=y
+CONFIG_AXI_DMAC=y
+CONFIG_PL330_DMA=y
+CONFIG_DMATEST=m
+CONFIG_COMMON_CLK_SI5338=m
+CONFIG_COMMON_CLK_SI5338SIMPLE=y
+CONFIG_COMMON_CLK_ALTERA_A10_FPLL=y
+CONFIG_IIO=y
+CONFIG_IIO_TRIGGER=y
+CONFIG_AD7291=y
+CONFIG_AD9361=y
+CONFIG_AD9371=y
+CONFIG_ADRV9009=y
+CONFIG_AD9467=y
+CONFIG_AD9680=y
+CONFIG_ADMC=y
+CONFIG_ALTERA_XCVR=y
+CONFIG_AD9523=y
+CONFIG_AD9528=y
+CONFIG_AD9548=y
+CONFIG_CF_AXI_DDS=y
+CONFIG_CF_AXI_DDS_AD9144=y
+CONFIG_JESD204=y
+CONFIG_ALTERA_ARRIA10_JESD204_PHY=y
+CONFIG_AXI_ADXCVR=y
+CONFIG_AXI_JESD204B=y
+CONFIG_AXI_JESD204_TX=y
+CONFIG_AXI_JESD204_RX=y
+CONFIG_FPGA=y
+CONFIG_FPGA_REGION=y
+CONFIG_FPGA_MGR_SOCFPGA=y
+CONFIG_FPGA_MGR_SOCFPGA_A10=y
+CONFIG_FPGA_BRIDGE=y
+CONFIG_SOCFPGA_FPGA_BRIDGE=y
+CONFIG_ALTERA_FREEZE_BRIDGE=y
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EXT2_FS_POSIX_ACL=y
+CONFIG_EXT3_FS=y
+# CONFIG_DNOTIFY is not set
+CONFIG_AUTOFS4_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_NTFS_FS=y
+CONFIG_NTFS_RW=y
+CONFIG_TMPFS=y
+CONFIG_JFFS2_FS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V4=y
+CONFIG_ROOT_NFS=y
+CONFIG_NFSD=y
+CONFIG_NFSD_V4=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_PRINTK_TIME=y
+CONFIG_DEBUG_INFO=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_DETECT_HUNG_TASK=y
+# CONFIG_SCHED_DEBUG is not set
+CONFIG_STACKTRACE=y
+CONFIG_TRACER_SNAPSHOT=y
+CONFIG_TRACER_SNAPSHOT_PER_CPU_SWAP=y
+CONFIG_FUNCTION_TRACER=y
+CONFIG_IRQSOFF_TRACER=y
+CONFIG_INTERRUPT_OFF_HIST=y
+CONFIG_PREEMPT_TRACER=y
+CONFIG_PREEMPT_OFF_HIST=y
+CONFIG_SCHED_TRACER=y
+CONFIG_HWLAT_TRACER=y
+CONFIG_WAKEUP_LATENCY_HIST=y
+CONFIG_MISSED_TIMER_OFFSETS_HIST=y
+CONFIG_RING_BUFFER_BENCHMARK=y
+CONFIG_RING_BUFFER_STARTUP_TEST=y
+CONFIG_DEBUG_USER=y
+CONFIG_DEBUG_LL=y
+CONFIG_DEBUG_SOCFPGA_UART1=y
+CONFIG_EARLY_PRINTK=y
diff --git a/drivers/clk/Kconfig b/drivers/clk/Kconfig
index 7e6141f..2253c71 100644
--- a/drivers/clk/Kconfig
+++ b/drivers/clk/Kconfig
@@ -70,6 +70,23 @@ config COMMON_CLK_SI5351
 	  This driver supports Silicon Labs 5351A/B/C programmable clock
 	  generators.
 
+config COMMON_CLK_SI5338
+	tristate "Clock driver for SiLabs 5338"
+	depends on I2C
+	select REGMAP_I2C
+	select RATIONAL
+	---help---
+	  This driver supports Silicon Labs 5338 programmable clock
+	  generators.
+config COMMON_CLK_SI5338SIMPLE
+	tristate "Clock driver for SiLabs 5338 based on altera peel script"
+	depends on I2C
+	select REGMAP_I2C
+	select RATIONAL
+	---help---
+	  This driver supports Silicon Labs 5338 programmable clock
+	  generators.
+
 config COMMON_CLK_SI514
 	tristate "Clock driver for SiLabs 514 devices"
 	depends on I2C
diff --git a/drivers/clk/Makefile b/drivers/clk/Makefile
index 0adee96..1c51fda 100644
--- a/drivers/clk/Makefile
+++ b/drivers/clk/Makefile
@@ -42,6 +42,8 @@ obj-$(CONFIG_COMMON_CLK_RK808)		+= clk-rk808.o
 obj-$(CONFIG_COMMON_CLK_S2MPS11)	+= clk-s2mps11.o
 obj-$(CONFIG_COMMON_CLK_SCPI)           += clk-scpi.o
 obj-$(CONFIG_COMMON_CLK_SI5351)		+= clk-si5351.o
+obj-$(CONFIG_COMMON_CLK_SI5338)		+= clk-si5338.o
+obj-$(CONFIG_COMMON_CLK_SI5338SIMPLE)	+= clk-si5338simple.o
 obj-$(CONFIG_COMMON_CLK_SI514)		+= clk-si514.o
 obj-$(CONFIG_COMMON_CLK_SI570)		+= clk-si570.o
 obj-$(CONFIG_ARCH_STM32)		+= clk-stm32f4.o
diff --git a/drivers/clk/clk-si5338.c b/drivers/clk/clk-si5338.c
new file mode 100644
index 0000000..73043a1
--- /dev/null
+++ b/drivers/clk/clk-si5338.c
@@ -0,0 +1,3820 @@
+/*
+ * https://patchwork.kernel.org/patch/9302089/
+ *
+ * clk-si5338.c: Silicon Labs Si5338 I2C Clock Generator
+ *
+ * Copyright 2015 Freescale Semiconductor
+ * York Sun <yorksun@freescale.com>
+ *
+ * Some code is taken from si5338.c by Andrey Filippov  <andrey@elphel.com>
+ * Copyright 2013 Elphel, Inc.
+ *
+ * SI5338 has several blocks, including
+ *   Inputs (IN1/IN2, IN3, IN4, IN5/IN6, XTAL)
+ *   PLL (Synthesis stage 1)
+ *   MultiSynth (Synthesis state 2)
+ *   Outputs (OUT0/1/2/3)
+ * Each block is registered as a clock device to form a tree structure.
+ * See Documentation/devicetree/bindings/clock/silabs,si5338.txt for details.
+ *
+ * This driver uses regmap to cache register values to reduce transactions
+ * on I2C bus. Volatile registers are specified.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#define DEBUG 1
+#include <linux/bsearch.h>
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+#include <linux/clk-provider.h>
+#include <linux/debugfs.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/i2c.h>
+#include <linux/math64.h>
+#include <linux/module.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <dt-bindings/clock/clk-si5338.h>
+#include "si5338.h"
+
+#define REG5338_PAGE			255
+#define REG5338_PAGE_MASK		1
+#define REG5338_DEV_CONFIG2		2
+#define REG5338_DEV_CONFIG2_MASK	0x3f
+#define REG5338_DEV_CONFIG2_VAL		38 /* last 2 digits of part number */
+#define LAST_REG			347
+
+#define FVCOMIN			2200000000LL
+#define FVCOMAX			2840000000LL
+#define XTAL_FREQMIN		8000000LL
+#define XTAL_FREQMAX		30000000LL
+#define INFREQMIN		5000000LL
+#define INFREQMAX		710000000LL
+#define INFREQMAX34		200000000LL
+#define INFREQDIV		40000000LL /* divide input frequency if above */
+
+#define MSINT_MIN		4 /* need to exclude 5, 7 in the code */
+#define MSINT_MAX		567
+
+#define AWE_INT_MASK		0x061d
+
+#define AWE_IN_MUX		0x1d18
+#define AWE_IN_MUX1		0x1c1c
+#define AWE_FB_MUX		0x1e18
+#define AWE_FB_MUX1		0x1c20
+
+#define AWE_XTAL_FREQ		0x1c03
+#define AWE_PFD_REF		0x1de0
+#define AWE_PFD_FB		0x1ee0
+#define AWE_P1DIV		0x1d07
+#define AWE_P2DIV		0x1e07
+#define AWE_DRV0_PDN		0x1f01
+#define AWE_MS0_PDN		0x1f02
+#define AWE_R0DIV		0x1f1c
+#define AWE_R0DIV_IN		0x1fe0
+#define AWE_DRV1_PDN		0x2001
+#define AWE_MS1_PDN		0x2002
+#define AWE_R1DIV		0x201c
+#define AWE_R1DIV_IN		0x20e0
+#define AWE_DRV2_PDN		0x2101
+#define AWE_MS2_PDN		0x2102
+#define AWE_R2DIV		0x211c
+#define AWE_R2DIV_IN		0x21e0
+#define AWE_DRV3_PDN		0x2201
+#define AWE_MS3_PDN		0x2202
+#define AWE_R3DIV		0x221c
+#define AWE_R3DIV_IN		0x22e0
+
+#define AWE_DRV0_VDDO		0x2303
+#define AWE_DRV1_VDDO		0x230c
+#define AWE_DRV2_VDDO		0x2330
+#define AWE_DRV3_VDDO		0x23c0
+#define AWE_DRV0_FMT		0x2407
+#define AWE_DRV0_INV		0x2418
+#define AWE_DRV1_FMT		0x2507
+#define AWE_DRV1_INV		0x2518
+#define AWE_DRV2_FMT		0x2607
+#define AWE_DRV2_INV		0x2618
+#define AWE_DRV3_FMT		0x2707
+#define AWE_DRV3_INV		0x2718
+
+#define AWE_DRV0_TRIM		0x281f
+#define AWE_DRV1_TRIM_A		0x28e0
+#define AWE_DRV1_TRIM_B		0x2903
+#define AWE_DRV2_TRIM		0x297c
+#define AWE_DRV3_TRIM		0x2a1f
+
+#define AWE_FCAL_OVRD_07_00	0x2dff
+#define AWE_FCAL_OVRD_15_08	0x2eff
+#define AWE_FCAL_OVRD_17_15	0x2f03
+#define AWE_REG47_72		0x2ffc
+#define AWE_PFD_EXTFB		0x3080
+#define AWE_PLL_KPHI		0x307f
+#define AWE_FCAL_OVRD_EN	0x3180
+#define AWE_VCO_GAIN		0x3170
+#define AWE_RSEL		0x310c
+#define AWE_BWSEL		0x3103
+#define AWE_VCO_GAIN_RSEL_BWSEL	0x317f
+
+#define AWE_PLL_EN		0x32c0
+#define AWE_MSCAL		0x323f
+#define AWE_MS3_HS		0x3380
+#define AWE_MS2_HS		0x3340
+#define AWE_MS1_HS		0x3320
+#define AWE_MS0_HS		0x3310
+#define AWE_MS_PEC		0x3307
+
+#define AWE_MS0_P1_07_00	0x35ff
+#define AWE_MS0_P1_15_08	0x36ff
+#define AWE_MS0_P1_17_16	0x3703
+#define AWE_MS0_P2_05_00	0x37fc
+#define AWE_MS0_P2_13_06	0x38ff
+#define AWE_MS0_P2_21_14	0x39ff
+#define AWE_MS0_P2_29_22	0x3aff
+#define AWE_MS0_P3_07_00	0x3bff
+#define AWE_MS0_P3_15_08	0x3cff
+#define AWE_MS0_P3_23_16	0x3dff
+#define AWE_MS0_P3_29_24	0x3e3f
+
+#define AWE_MS1_P1_07_00	0x40ff
+#define AWE_MS1_P1_15_08	0x41ff
+#define AWE_MS1_P1_17_16	0x4203
+#define AWE_MS1_P2_05_00	0x42fc
+#define AWE_MS1_P2_13_06	0x43ff
+#define AWE_MS1_P2_21_14	0x44ff
+#define AWE_MS1_P2_29_22	0x45ff
+#define AWE_MS1_P3_07_00	0x46ff
+#define AWE_MS1_P3_15_08	0x47ff
+#define AWE_MS1_P3_23_16	0x48ff
+#define AWE_MS1_P3_29_24	0x493f
+
+#define AWE_MS2_P1_07_00	0x4bff
+#define AWE_MS2_P1_15_08	0x4cff
+#define AWE_MS2_P1_17_16	0x4d03
+#define AWE_MS2_P2_05_00	0x4dfc
+#define AWE_MS2_P2_13_06	0x4eff
+#define AWE_MS2_P2_21_14	0x4fff
+#define AWE_MS2_P2_29_22	0x50ff
+#define AWE_MS2_P3_07_00	0x51ff
+#define AWE_MS2_P3_15_08	0x52ff
+#define AWE_MS2_P3_23_16	0x53ff
+#define AWE_MS2_P3_29_24	0x543f
+
+#define AWE_MS3_P1_07_00	0x56ff
+#define AWE_MS3_P1_15_08	0x57ff
+#define AWE_MS3_P1_17_16	0x5803
+#define AWE_MS3_P2_05_00	0x58fc
+#define AWE_MS3_P2_13_06	0x59ff
+#define AWE_MS3_P2_21_14	0x5aff
+#define AWE_MS3_P2_29_22	0x5bff
+#define AWE_MS3_P3_07_00	0x5cff
+#define AWE_MS3_P3_15_08	0x5dff
+#define AWE_MS3_P3_23_16	0x5eff
+#define AWE_MS3_P3_29_24	0x5f3f
+
+#define AWE_MSN_P1_07_00	0x61ff
+#define AWE_MSN_P1_15_08	0x62ff
+#define AWE_MSN_P1_17_16	0x6303
+#define AWE_MSN_P2_05_00	0x63fc
+#define AWE_MSN_P2_13_06	0x64ff
+#define AWE_MSN_P2_21_14	0x65ff
+#define AWE_MSN_P2_29_22	0x66ff
+#define AWE_MSN_P3_07_00	0x67ff
+#define AWE_MSN_P3_15_08	0x68ff
+#define AWE_MSN_P3_23_16	0x69ff
+#define AWE_MSN_P3_29_24	0x6a3f
+
+#define AWE_OUT0_DIS_STATE	0x6ec0
+#define AWE_OUT1_DIS_STATE	0x72c0
+#define AWE_OUT2_DIS_STATE	0x76c0
+#define AWE_OUT3_DIS_STATE	0x7ac0
+
+#define AWE_STATUS			0xdaff
+#define AWE_STATUS_PLL_LOL		0xda10
+#define AWE_STATUS_PLL_LOS_FDBK		0xda08
+#define AWE_STATUS_PLL_LOS_CLKIN	0xda04
+#define AWE_STATUS_PLL_SYS_CAL		0xda01
+
+#define AWE_MS_RESET		0xe204
+
+#define AWE_OUT0_DIS		0xe601
+#define AWE_OUT1_DIS		0xe602
+#define AWE_OUT2_DIS		0xe604
+#define AWE_OUT3_DIS		0xe608
+#define AWE_OUT_ALL_DIS		0xe610
+
+#define AWE_FCAL_07_00		0xebff
+#define AWE_FCAL_15_08		0xecff
+#define AWE_FCAL_17_16		0xed03
+
+#define AWE_DIS_LOS		0xf180
+#define AWE_REG241		0xf1ff
+
+#define AWE_SOFT_RESET		0xf602
+
+#define AWE_MISC_47		0x2ffc /* write 0x5 */
+#define AWE_MISC_106		0x6a80 /* write 0x1 */
+#define AWE_MISC_116		0x7480 /* write 0x1 */
+#define AWE_MISC_42		0x2a20 /* write 0x1 */
+#define AWE_MISC_06A		0x06e0 /* write 0x0 */
+#define AWE_MISC_06B		0x0602 /* write 0x0 */
+#define AWE_MISC_28		0x1cc0 /* write 0x0 */
+
+#define MS_POWER_DOWN		1
+#define MS_POWER_UP		0
+#define OUT_DISABLE		1
+#define OUT_ENABLE		0
+#define DRV_POWERDOWN		1
+#define DRV_POWERUP		0
+
+struct si5338_drv_t {
+	const char *description;
+	u8 fmt;
+	u8 vdd;
+	u8 trim;
+	/* bits [1:0} data,
+	 * [3:2] - don't care ([3]==1 - [1] - any, [2]==1 - [0] - any
+	 */
+	u8 invert;
+};
+
+#define MAX_NAME_PREFIX 30 /* max 30 characters for the name_prefix */
+#define MAX_NAME_LENGTH 40 /* max 40 charactors for the internal names */
+
+struct si5338_driver_data;
+
+/*
+ * Internal parameters used by PLL and MS
+ * They are used in recalc rate functions before being
+ * written to the device.
+ */
+struct si5338_parameters {
+	u32	p[3];
+	bool	valid;
+};
+
+/*
+ * This structure saves params and num variable for clocks
+ * Internal clocks with parameters of multiple input/output
+ * use this structure.
+ */
+struct si5338_hw_data {
+	struct clk_hw			hw;
+	struct si5338_driver_data	*drvdata;
+	/* params is only used for PLL and multisynth clocks */
+	struct si5338_parameters	params;
+	/*
+	 * For clkin, clkout, multisynth: index of itself
+	 * For refclk, fbclk, pll: index of its source
+	 */
+	u8				num;
+};
+#define HWDATA(x) \
+	((struct si5338_hw_data *)container_of(x, struct si5338_hw_data, hw))
+
+struct si5338_driver_data {
+	struct i2c_client	*client;
+	struct regmap		*regmap;
+	struct clk_onecell_data onecell;
+
+	/*
+	 * The structure of clocks are
+	 * Input clocks:
+	 *       pclkin12 - IN1/2
+	 *		 pclkin3  - IN3
+	 *		 pclkin4  - IN4
+	 *		 pclkin56 - IN5/6
+	 *		 pxtal    - IN1/2 XTAL
+	 * Internal clocks:
+	 *		 xoclk		- from pxtal
+	 *		 refclk		- from one of IN1/2, IN3, XTAL
+	 *		 divrefclk	- from refclk with divider
+	 *		 fbclk		- from IN4 or IN5/6
+	 *		 divfbclk	- from fbclk
+	 *		 MS0/1/2/3	- from one of xoclk, refclk
+	 *				  diverefclk, fbclk, divfbclk
+	 * Output clocks:
+	 *		 clkout0/1/2/3	- from one of internal clocks
+	 */
+	/* parent clocks */
+	struct clk		*pxtal;
+	const char		*pxtal_name;
+	struct clk		*pclkin[4];
+	const char		*pclkin_name[4];
+
+	/* internal and output clocks */
+	char name_prefix[MAX_NAME_PREFIX];
+	struct clk_hw		xtal;
+	struct si5338_hw_data	clkin[4];
+	struct si5338_hw_data	refclk;
+	struct clk_hw		divrefclk;
+	struct si5338_hw_data	fbclk;
+	struct clk_hw		divfbclk;
+	struct si5338_hw_data	pll;
+	struct si5338_hw_data	*msynth;
+	struct si5338_hw_data	*clkout;
+	struct clk_lookup	*lookup[4];
+};
+
+static const char * const si5338_input_names[] = {
+	"in1/in2", "in3", "in4", "in5/in6", "xtal", "noclk"
+};
+
+static const char * const si5338_pll_src_names[] = {
+	"refclk", "fbclk", "divrefclk", "divfbclk", "xtal", "noclk"
+};
+
+static const char * const si5338_msynth_src_names[] = {
+	"pll"
+};
+
+static const char * const si5338_msynth_names[] = {
+	"ms0", "ms1", "ms2", "ms3"
+};
+static const char * const si5338_clkout_names[] = {
+	"clkout0", "clkout1", "clkout2", "clkout3"
+};
+static const char * const si5338_clkout_src_names[] = {
+	"fbclk", "refclk", "divfbclk", "divrefclk", "xtal",
+	"ms0",
+	"msn", /* it is actually ms0, ms1, ms2, ms3 dependings on clkout */
+	"noclk",
+};
+
+/*
+ * This array is used to determine if a register is writable. The mask is
+ * not used in this driver. The data is in format of 0xAAAMM where AAA is
+ * address, MM is bit mask. 1 means the corresponding bit is writable.
+ * Created from SiLabs ClockBuilder output.
+ * Note: Register 226, 230, 241, 246, 255 are not included in header file
+ *	 from ClockBuilder v2.7 or later. Manually added here.
+ */
+static const u32 register_masks[] = {
+	0x61d, 0x1b80, 0x1cff, 0x1dff, 0x1eff, 0x1fff, 0x20ff, 0x21ff,
+	0x22ff, 0x23ff, 0x241f, 0x251f, 0x261f, 0x271f, 0x28ff, 0x297f,
+	0x2a3f, 0x2dff, 0x2eff, 0x2f3f, 0x30ff, 0x31ff, 0x32ff, 0x33ff,
+	0x34ff, 0x35ff, 0x36ff, 0x37ff, 0x38ff, 0x39ff, 0x3aff, 0x3bff,
+	0x3cff, 0x3dff, 0x3e3f, 0x3fff, 0x40ff, 0x41ff, 0x42ff, 0x43ff,
+	0x44ff, 0x45ff, 0x46ff, 0x47ff, 0x48ff, 0x493f, 0x4aff, 0x4bff,
+	0x4cff, 0x4dff, 0x4eff, 0x4fff, 0x50ff, 0x51ff, 0x52ff, 0x53ff,
+	0x543f, 0x55ff, 0x56ff, 0x57ff, 0x58ff, 0x59ff, 0x5aff, 0x5bff,
+	0x5cff, 0x5dff, 0x5eff, 0x5f3f, 0x61ff, 0x62ff, 0x63ff, 0x64ff,
+	0x65ff, 0x66ff, 0x67ff, 0x68ff, 0x69ff, 0x6abf, 0x6bff, 0x6cff,
+	0x6dff, 0x6eff, 0x6fff, 0x70ff, 0x71ff, 0x72ff, 0x73ff, 0x74ff,
+	0x75ff, 0x76ff, 0x77ff, 0x78ff, 0x79ff, 0x7aff, 0x7bff, 0x7cff,
+	0x7dff, 0x7eff, 0x7fff, 0x80ff, 0x810f, 0x820f, 0x83ff, 0x84ff,
+	0x85ff, 0x86ff, 0x87ff, 0x88ff, 0x89ff, 0x8aff, 0x8bff, 0x8cff,
+	0x8dff, 0x8eff, 0x8fff, 0x90ff, 0x98ff, 0x99ff, 0x9aff, 0x9bff,
+	0x9cff, 0x9dff, 0x9e0f, 0x9f0f, 0xa0ff, 0xa1ff, 0xa2ff, 0xa3ff,
+	0xa4ff, 0xa5ff, 0xa6ff, 0xa7ff, 0xa8ff, 0xa9ff, 0xaaff, 0xabff,
+	0xacff, 0xadff, 0xaeff, 0xafff, 0xb0ff, 0xb1ff, 0xb2ff, 0xb3ff,
+	0xb4ff, 0xb50f, 0xb6ff, 0xb7ff, 0xb8ff, 0xb9ff, 0xbaff, 0xbbff,
+	0xbcff, 0xbdff, 0xbeff, 0xbfff, 0xc0ff, 0xc1ff, 0xc2ff, 0xc3ff,
+	0xc4ff, 0xc5ff, 0xc6ff, 0xc7ff, 0xc8ff, 0xc9ff, 0xcaff, 0xcb0f,
+	0xccff, 0xcdff, 0xceff, 0xcfff, 0xd0ff, 0xd1ff, 0xd2ff, 0xd3ff,
+	0xd4ff, 0xd5ff, 0xd6ff, 0xd7ff, 0xd8ff, 0xd9ff, 0xe204, 0xe6ff,
+	0xf1ff, 0xf202, 0xf6ff, 0xffff, 0x11fff,
+	0x120ff, 0x121ff, 0x122ff, 0x123ff, 0x124ff, 0x125ff, 0x126ff, 0x127ff,
+	0x128ff, 0x129ff, 0x12aff, 0x12b0f, 0x12fff, 0x130ff, 0x131ff, 0x132ff,
+	0x133ff, 0x134ff, 0x135ff, 0x136ff, 0x137ff, 0x138ff, 0x139ff, 0x13aff,
+	0x13b0f, 0x13fff, 0x140ff, 0x141ff, 0x142ff, 0x143ff, 0x144ff, 0x145ff,
+	0x146ff, 0x147ff, 0x148ff, 0x149ff, 0x14aff, 0x14b0f, 0x14fff, 0x150ff,
+	0x151ff, 0x152ff, 0x153ff, 0x154ff, 0x155ff, 0x156ff, 0x157ff, 0x158ff,
+	0x159ff, 0x15aff, 0x15b0f
+};
+
+/*
+ * Si5338 i2c regmap
+ */
+static inline u8 si5338_reg_read(struct si5338_driver_data *drvdata,
+				 u16 reg, u8 *data)
+{
+	u32 val;
+	int ret;
+
+	ret = regmap_read(drvdata->regmap, reg, &val);
+	*data = (u8)val;	/* si5338 has u8 value */
+
+	return ret;
+}
+
+static inline int si5338_reg_write(struct si5338_driver_data *drvdata,
+				   u16 reg, u8 val, u8 mask)
+{
+	if (mask != 0xff)
+		return regmap_update_bits(drvdata->regmap, reg, mask, val);
+
+	return regmap_write(drvdata->regmap, reg, val);
+}
+
+static int write_field(struct si5338_driver_data *drvdata, u8 data, u32 awe)
+{
+	int rc, nshift;
+	u8 mask, reg_data;
+	u16 reg;
+
+	reg = awe >> 8;
+	mask = awe & 0xff;
+	if (mask) {
+		nshift = 0;
+		while (!((1 << nshift) & mask))
+			nshift++;
+		reg_data = (data & 0xff) << nshift;
+		rc = si5338_reg_write(drvdata, reg, reg_data, mask);
+		if (rc < 0)
+			return rc;
+	}
+
+	return 0;
+}
+
+static int write_multireg64(struct si5338_driver_data *drvdata,
+				u64 data, const u32 *awe)
+{
+	int i, rc, nshift, nbits;
+	u8 mask, reg_data;
+	u16 reg;
+
+	for (i = 0; awe[i]; i++) {
+		reg = awe[i] >> 8;
+		mask = awe[i] & 0xff;
+		if (mask) {
+			nshift = 0;
+			nbits = 1;
+			while (!((1 << nshift) & mask))
+				nshift++;
+			while ((1 << (nshift + nbits)) & mask)
+				nbits++;
+			/*
+			 * may have some garbage in high bits,
+			 * will be cut of by mask
+			 */
+			reg_data = (data & 0xff) << nshift;
+			data >>= nbits;
+			rc = si5338_reg_write(drvdata, reg, reg_data, mask);
+			if (rc < 0)
+				return rc;
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * The function forms a 64-bit value from multiple registers.
+ * The lastest value used by si5338 is 48-bit.
+ */
+static int read_multireg64(struct si5338_driver_data *drvdata,
+			   const u32 *awe, u64 *data)
+{
+	int i, rc, nshift, nbits, full_shift = 0;
+	u8 val, mask;
+	u16 reg;
+
+	*data = 0;
+
+	for (i = 0; awe[i]; i++) {
+		reg = awe[i] >> 8;
+		mask = awe[i] & 0xff;
+		if (mask) {
+			nshift = 0;
+			nbits = 1;
+			while (!((1 << nshift) & mask))
+				nshift++;
+			while ((1 << (nshift + nbits)) & mask)
+				nbits++;
+			rc = si5338_reg_read(drvdata, reg, &val);
+			if (rc < 0)
+				return rc;
+
+			*data |= (((s64)val & mask) >> nshift) << full_shift;
+			full_shift += nbits;
+		}
+	}
+
+	return 0;
+}
+
+static int read_field(struct si5338_driver_data *drvdata, u32 awe)
+{
+	int rc, nshift;
+	u8 val, mask;
+	u16 reg;
+
+	reg = awe >> 8;
+	mask = awe & 0xff;
+
+	if (mask) {
+		nshift = 0;
+		while (!((1 << nshift) & mask))
+			nshift++;
+		rc = si5338_reg_read(drvdata, reg, &val);
+		if (rc < 0)
+			return rc;
+
+		return (val & mask) >> nshift;
+	}
+
+	return 0;
+}
+
+static int si5338_find_mask(const void *key, const void *elt)
+{
+	const u32 *reg = key;
+	const u32 *register_mask = elt;
+
+	if (*reg > *register_mask >> 8)
+		return 1;
+	if (*reg < *register_mask >> 8)
+		return -1;
+
+	return 0;
+}
+
+static bool si5338_regmap_is_writeable(struct device *dev, unsigned int reg)
+{
+	return bsearch(&reg, register_masks, ARRAY_SIZE(register_masks),
+		       sizeof(u32), si5338_find_mask) != NULL;
+}
+
+static bool si5338_regmap_is_volatile(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case (AWE_STATUS >> 8):
+	case (AWE_SOFT_RESET >> 8):
+	case (AWE_FCAL_07_00 >> 8):
+	case (AWE_FCAL_15_08 >> 8):
+	case (AWE_FCAL_17_16 >> 8):
+		return true;
+	}
+
+	return false;
+}
+static const struct regmap_range_cfg si5338_regmap_range[] = {
+	{
+		.selector_reg = REG5338_PAGE,		/* 255 */
+		.selector_mask  = REG5338_PAGE_MASK,	/* 1 */
+		.selector_shift = 0,
+		.window_start = 0,
+		.window_len = 256,
+		.range_min = 0,
+		.range_max = 347,
+	},
+};
+
+static const struct regmap_config si5338_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.cache_type = REGCACHE_RBTREE,
+	.max_register = 347,
+	.ranges = si5338_regmap_range,
+	.num_ranges = ARRAY_SIZE(si5338_regmap_range),
+	.writeable_reg = si5338_regmap_is_writeable,
+	.volatile_reg = si5338_regmap_is_volatile,
+};
+
+/*
+ * SI5338 register access
+ */
+static int _verify_output_channel(int chn)
+{
+	if (chn < 0 || chn > 3) {
+		pr_err("Invalid output channel: %d (only 0..3 are allowed)\n",
+			chn);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int set_in_mux(struct si5338_driver_data *drvdata, int data)
+{
+	int data1, rc;
+
+	switch (data) {
+	case 0:
+		data1 = 0;
+		break;
+	case 1:
+		data1 = 2;
+		break;
+	case 2:
+		data1 = 5;
+		break;
+	default:
+		dev_err(&drvdata->client->dev,
+			"Invalid value for input multiplexer %d\n", data);
+		return -EINVAL;
+	}
+	rc = write_field(drvdata, data, AWE_IN_MUX);
+	if (rc < 0)
+		return rc;
+
+	rc = write_field(drvdata, data1, AWE_IN_MUX1);
+	if (rc < 0)
+		return rc;
+
+	return 0;
+}
+
+static int set_fb_mux(struct si5338_driver_data *drvdata, int data)
+{
+	int data1, rc;
+
+	switch (data) {
+	case 0:
+		data1 = 0;
+		break;
+	case 1:
+		data1 = 1;
+		break;
+	case 2:
+		data1 = 0;
+		break;
+	default:
+		dev_err(&drvdata->client->dev,
+			"Invalid value for feedback multiplexer %d\n", data);
+		return -EINVAL;
+	}
+	rc = write_field(drvdata, data, AWE_FB_MUX);
+	if (rc < 0)
+		return rc;
+
+	rc = write_field(drvdata, data1, AWE_FB_MUX1);
+	if (rc < 0)
+		return rc;
+
+	return 0;
+}
+
+/*
+ * PLL has two inputs, each has multiple sources
+ * 0 - pfd_in_ref
+ * 1 - pfd_in_fb
+ */
+static int get_in_pfd_ref_fb(struct si5338_driver_data *drvdata, int chn)
+{
+	return read_field(drvdata, chn ? AWE_PFD_FB : AWE_PFD_REF);
+}
+
+static int set_in_pfd_ref_fb(struct si5338_driver_data *drvdata,
+				u8 val, int chn)
+{
+	int rc;
+
+	if (val > SI5338_PFD_IN_REF_NOCLK) {
+		dev_err(&drvdata->client->dev,
+			"Invalid value for input pfd selector: %d\n", val);
+		return -EINVAL;
+	}
+	rc = write_field(drvdata, val, chn ? AWE_PFD_FB : AWE_PFD_REF);
+	if (rc < 0)
+		return rc;
+
+	return 0;
+}
+
+/*
+ * Set div for the two dividers
+ * 0 - p1div
+ * 1 - p2div
+ * The dividers have value of 1, 2, 4, 8, 16, 32
+ */
+static int set_in_pdiv(struct si5338_driver_data *drvdata, int div, int chn)
+{
+	u8 val;
+	u32 awe = chn ? AWE_P2DIV : AWE_P1DIV;
+
+	for (val = 0; val < 6; val++) {
+		if ((1 << val) == div)
+			return write_field(drvdata, val, awe);
+	}
+	dev_err(&drvdata->client->dev,
+		"Invalid value for input divider: %d\n", div);
+
+	return -EINVAL;
+}
+
+/*
+ * Si5338 xtal clock input
+ * The clock needs to be within [8MHz .. 30MHz]
+ */
+static int si5338_xtal_prepare(struct clk_hw *hw)
+{
+	struct si5338_driver_data *drvdata =
+		container_of(hw, struct si5338_driver_data, xtal);
+	unsigned long rate = clk_hw_get_rate(hw);
+	int xtal_mode;
+
+	if (rate < XTAL_FREQMIN) {
+		dev_err(&drvdata->client->dev,
+			"Xtal input frequency too low: %lu < %llu\n",
+			rate, XTAL_FREQMIN);
+		return -EINVAL;
+	}
+	if (rate > XTAL_FREQMAX) {
+		dev_err(&drvdata->client->dev,
+			"Xtal input frequency too high: %lu > %llu\n",
+			rate, XTAL_FREQMAX);
+		return -EINVAL;
+	}
+
+	if (rate > 26000000ll)
+		xtal_mode = 3;
+	else if (rate > 19000000ll)
+		xtal_mode = 2;
+	else if (rate > 11000000ll)
+		xtal_mode = 1;
+	else
+		xtal_mode = 0;
+
+	return write_field(drvdata, xtal_mode, AWE_XTAL_FREQ);
+}
+
+static const struct clk_ops si5338_xtal_ops = {
+	.prepare = si5338_xtal_prepare,
+};
+
+static unsigned long si5338_clkin_recalc_rate(struct clk_hw *hw,
+						unsigned long parent_rate)
+{
+	struct si5338_hw_data *hwdata = HWDATA(hw);
+	struct si5338_driver_data *drvdata = hwdata->drvdata;
+	unsigned long max_rate;
+
+	max_rate = (hwdata->num == SI5338_INPUT_CLK12 ||
+		    hwdata->num == SI5338_INPUT_CLK56) ?
+			INFREQMAX : INFREQMAX34;
+	if (parent_rate  < INFREQMIN) {
+		dev_err(&drvdata->client->dev,
+			"Input frequency too low: %lu < %llu\n",
+			parent_rate, INFREQMIN);
+		return -EINVAL;
+	}
+	if (parent_rate > max_rate) {
+		dev_err(&drvdata->client->dev,
+			"Input frequency too high: %lu > %lu\n",
+			parent_rate, max_rate);
+		return -EINVAL;
+	}
+
+	return parent_rate;
+}
+
+static const struct clk_ops si5338_clkin_ops = {
+	.recalc_rate = si5338_clkin_recalc_rate,
+};
+
+/*
+ * Si5338 refclk inputs
+ * Input frequency range
+ *	IN1/IN2 differential clock [5MHz..710MHz]
+ *	IN3 single-ended clock [5MHz..200MHz]
+ * Enforced by si5338_clkin_recalc_rate
+ */
+static int si5338_refclk_reparent(struct si5338_driver_data *drvdata, u8 index)
+{
+	struct si5338_hw_data *hwdata = &drvdata->refclk;
+
+	hwdata->num = SI5338_FB_SRC_NOCLK;
+	switch (index) {
+	case SI5338_REF_SRC_XTAL:
+		/* in mux to XO */
+		hwdata->num = 2;
+		return set_in_mux(drvdata, 2);
+	case SI5338_REF_SRC_CLKIN12:
+		/* in mux to IN12 */
+		hwdata->num = 0;
+		return set_in_mux(drvdata, 0);
+	case SI5338_REF_SRC_CLKIN3:
+		hwdata->num = 1;
+		return set_in_mux(drvdata, 1);
+	}
+	dev_err(&drvdata->client->dev,
+		"Invalid parent (%d) for refclk\n", index);
+
+	return -EINVAL;
+}
+
+/*
+ * refclk's parent
+ * 0 - IN1/IN2
+ * 1 - IN3
+ * 2 - XTAL
+ */
+static int si5338_refclk_set_parent(struct clk_hw *hw, u8 index)
+{
+	struct si5338_hw_data *hwdata = HWDATA(hw);
+	struct si5338_driver_data *drvdata = hwdata->drvdata;
+
+	switch (index) {
+	case 0:
+		return si5338_refclk_reparent(drvdata, SI5338_REF_SRC_CLKIN12);
+	case 1:
+		return si5338_refclk_reparent(drvdata, SI5338_REF_SRC_CLKIN3);
+	case 2:
+		return si5338_refclk_reparent(drvdata, SI5338_REF_SRC_XTAL);
+	}
+	dev_err(&drvdata->client->dev,
+		"Invalid parent index for refclk: %d\n", index);
+
+	return -EINVAL;
+}
+
+static u8 si5338_refclk_get_parent(struct clk_hw *hw)
+{
+	struct si5338_hw_data *hwdata = HWDATA(hw);
+	struct si5338_driver_data *drvdata = hwdata->drvdata;
+
+	/* get input mux */
+	return read_field(drvdata, AWE_IN_MUX);
+}
+
+static const struct clk_ops si5338_refclk_ops = {
+	.set_parent = si5338_refclk_set_parent,
+	.get_parent = si5338_refclk_get_parent,
+};
+
+/*
+ * divrefclk's parent is refclk
+ */
+static int si5338_divrefclk_prepare(struct clk_hw *hw)
+{
+	struct si5338_driver_data *drvdata =
+		container_of(hw, struct si5338_driver_data, divrefclk);
+	int idiv;
+	unsigned long parent_rate = clk_hw_get_rate(clk_hw_get_parent(hw));
+
+	/*
+	 * Calculate the lowest ratio to divide the input frequency to 40MHz
+	 * or less
+	 */
+	for (idiv = 0; idiv < 5; idiv++) {
+		if ((parent_rate >> idiv) <= INFREQDIV)
+			break;
+	}
+
+	return set_in_pdiv(drvdata, 1 << idiv, 0);
+}
+
+static unsigned long si5338_divrefclk_recalc_rate(struct clk_hw *hw,
+					   unsigned long parent_rate)
+{
+	int idiv;
+
+	/*
+	 * Calculate the lowest ratio to divide the input frequency to 40MHz
+	 * or less
+	 */
+	for (idiv = 0; idiv < 5; idiv++) {
+		if ((parent_rate >> idiv) <= INFREQDIV)
+			break;
+	}
+
+	return parent_rate >> idiv;
+}
+
+static const struct clk_ops si5338_divrefclk_ops = {
+	.recalc_rate = si5338_divrefclk_recalc_rate,
+	.prepare = si5338_divrefclk_prepare,
+};
+
+/*
+ * Si5338 fbclk inputs
+ * Input frequency range
+ *	IN4 single-ended clock [5MHz..200MHz]
+ *	IN5/IN6 differential clock [5MHz..710MHz]
+ * Enforced by si5338_clkin_recalc_rate
+ */
+static int si5338_fbclk_reparent(struct si5338_driver_data *drvdata, u8 index)
+{
+	struct si5338_hw_data *hwdata = &drvdata->fbclk;
+
+	hwdata->num = SI5338_FB_SRC_NOCLK;
+	switch (index) {
+	case SI5338_FB_SRC_CLKIN4:
+		/* in mux to IN4 */
+		hwdata->num = 0;
+		return set_fb_mux(drvdata, 1);
+	case SI5338_FB_SRC_CLKIN56:
+		/* in mux to IN56 */
+		hwdata->num = 1;
+		return set_fb_mux(drvdata, 0);
+	case SI5338_FB_SRC_NOCLK:
+		hwdata->num = 2;
+		return set_fb_mux(drvdata, 2);
+	}
+	dev_err(&drvdata->client->dev,
+		"Invalid parent (%d) for fbclk\n", index);
+
+	return -EINVAL;
+}
+
+/*
+ * fbclk's parent can be
+ * 0 - IN4
+ * 1 - IN5/IN6
+ * 2 - NOCLK
+ */
+static int si5338_fbclk_set_parent(struct clk_hw *hw, u8 index)
+{
+	struct si5338_hw_data *hwdata = HWDATA(hw);
+	struct si5338_driver_data *drvdata = hwdata->drvdata;
+
+	switch (index) {
+	case 0:
+		return si5338_fbclk_reparent(drvdata, SI5338_FB_SRC_CLKIN4);
+	case 1:
+		return si5338_fbclk_reparent(drvdata, SI5338_FB_SRC_CLKIN56);
+	case 2:
+		return si5338_fbclk_reparent(drvdata, SI5338_FB_SRC_NOCLK);
+	}
+	dev_err(&drvdata->client->dev,
+		"Invalid parent index for fbclk\n");
+
+	return -EINVAL;
+}
+
+static u8 si5338_fbclk_get_parent(struct clk_hw *hw)
+{
+	struct si5338_hw_data *hwdata = HWDATA(hw);
+	struct si5338_driver_data *drvdata = hwdata->drvdata;
+	int rc;
+
+	/* Return value 0: IN5/IN6
+	 *		1: IN4
+	 *		2: noclk
+	 */
+	rc = read_field(drvdata, AWE_FB_MUX);
+	switch (rc) {
+	case 0:
+		return 1;
+	case 1:
+		return 0;
+	case 2:
+		return 2;
+	default:
+		break;
+	}
+
+	return rc;
+}
+
+static const struct clk_ops si5338_fbclk_ops = {
+	.set_parent = si5338_fbclk_set_parent,
+	.get_parent = si5338_fbclk_get_parent,
+};
+
+/*
+ * divfbclk's parent is fbclk
+ */
+static int si5338_divfbclk_prepare(struct clk_hw *hw)
+{
+	struct si5338_driver_data *drvdata =
+		container_of(hw, struct si5338_driver_data, divfbclk);
+	int idiv;
+	unsigned long parent_rate = clk_hw_get_rate(clk_hw_get_parent(hw));
+
+	for (idiv = 0; idiv < 5; idiv++) {
+		if ((parent_rate >> idiv) <= INFREQDIV)
+			break;
+	}
+
+	return set_in_pdiv(drvdata, 1 << idiv, 1);
+}
+
+static unsigned long si5338_divfbclk_recalc_rate(struct clk_hw *hw,
+					   unsigned long parent_rate)
+{
+	int idiv;
+
+	for (idiv = 0; idiv < 5; idiv++) {
+		if ((parent_rate >> idiv) <= INFREQDIV)
+			break;
+	}
+
+	return parent_rate >> idiv;
+}
+
+static const struct clk_ops si5338_divfbclk_ops = {
+	.recalc_rate = si5338_divfbclk_recalc_rate,
+	.prepare = si5338_divfbclk_prepare,
+};
+
+/*
+ * PLL and MultiSynth
+ */
+static int remove_common_factor(u64 *num_denom)
+{
+	u64 a, b, r;
+
+	if (!num_denom[1])
+		return -1; /* zero denominator */
+
+	if (!num_denom[0]) {
+		num_denom[1] = 1;
+		return 1;
+	}
+
+	a = max(num_denom[0], num_denom[1]);
+	b = min(num_denom[0], num_denom[1]);
+	r = b;
+	while (r > 1) {
+		r = a - b * div64_u64(a, b);
+		if (!r) {
+			num_denom[0] = div64_u64(num_denom[0], b);
+			num_denom[1] = div64_u64(num_denom[1], b);
+			return 1;
+		}
+		a = b;
+		b = r;
+	}
+
+	return 0; /* nothing done */
+}
+
+static const u32 awe_msx[5][3][5] = {
+	{
+		{
+			AWE_MS0_P1_07_00,
+			AWE_MS0_P1_15_08,
+			AWE_MS0_P1_17_16,
+			0,
+			0
+		},
+		{
+			AWE_MS0_P2_05_00,
+			AWE_MS0_P2_13_06,
+			AWE_MS0_P2_21_14,
+			AWE_MS0_P2_29_22,
+			0
+		},
+		{
+			AWE_MS0_P3_07_00,
+			AWE_MS0_P3_15_08,
+			AWE_MS0_P3_23_16,
+			AWE_MS0_P3_29_24,
+			0
+		}
+	},
+	{
+		{
+			AWE_MS1_P1_07_00,
+			AWE_MS1_P1_15_08,
+			AWE_MS1_P1_17_16,
+			0,
+			0
+		},
+		{
+			AWE_MS1_P2_05_00,
+			AWE_MS1_P2_13_06,
+			AWE_MS1_P2_21_14,
+			AWE_MS1_P2_29_22,
+			0
+		},
+		{
+			AWE_MS1_P3_07_00,
+			AWE_MS1_P3_15_08,
+			AWE_MS1_P3_23_16,
+			AWE_MS1_P3_29_24,
+			0
+		}
+	},
+	{
+		{
+			AWE_MS2_P1_07_00,
+			AWE_MS2_P1_15_08,
+			AWE_MS2_P1_17_16,
+			0,
+			0
+		},
+		{
+			AWE_MS2_P2_05_00,
+			AWE_MS2_P2_13_06,
+			AWE_MS2_P2_21_14,
+			AWE_MS2_P2_29_22,
+			0
+		},
+		{
+			AWE_MS2_P3_07_00,
+			AWE_MS2_P3_15_08,
+			AWE_MS2_P3_23_16,
+			AWE_MS2_P3_29_24,
+			0
+		}
+	},
+	{
+		{
+			AWE_MS3_P1_07_00,
+			AWE_MS3_P1_15_08,
+			AWE_MS3_P1_17_16,
+			0,
+			0
+		},
+		{
+			AWE_MS3_P2_05_00,
+			AWE_MS3_P2_13_06,
+			AWE_MS3_P2_21_14,
+			AWE_MS3_P2_29_22,
+			0
+		},
+		{
+			AWE_MS3_P3_07_00,
+			AWE_MS3_P3_15_08,
+			AWE_MS3_P3_23_16,
+			AWE_MS3_P3_29_24,
+			0
+		}
+	},
+	{
+		{
+			AWE_MSN_P1_07_00,
+			AWE_MSN_P1_15_08,
+			AWE_MSN_P1_17_16,
+			0,
+			0
+		},
+		{
+			AWE_MSN_P2_05_00,
+			AWE_MSN_P2_13_06,
+			AWE_MSN_P2_21_14,
+			AWE_MSN_P2_29_22,
+			0
+		},
+		{
+			AWE_MSN_P3_07_00,
+			AWE_MSN_P3_15_08,
+			AWE_MSN_P3_23_16,
+			AWE_MSN_P3_29_24,
+			0
+		}
+	}
+};
+
+static int _verify_ms_channel(struct device *dev, int chn)
+{
+	if (chn < 0 || chn > 4) {
+		dev_err(dev,
+			"Invalid channel %d. Only 0,1,2,3 and 4 (for MSN) are supported\n",
+			chn);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/*
+ * Read parameters of
+ * 0 - MS0
+ * 1 - MS1
+ * 2 - MS2
+ * 3 - MS3
+ * 4 - MSN (PLL)
+ */
+static int get_ms_p(struct si5338_driver_data *drvdata, u32 *p, int chn)
+{
+	int i, rc;
+	u64 data;
+
+	rc = _verify_ms_channel(&drvdata->client->dev, chn);
+	if (rc < 0)
+		return rc;
+
+	for (i = 0; i < 3; i++) {
+		rc = read_multireg64(drvdata, awe_msx[chn][i], &data);
+		if (rc < 0)
+			return rc;
+
+		p[i] = (u32)data;	/* only use up to 30 bit here */
+	}
+
+	return 0;
+}
+
+/*
+ * Calculte MS ratio from parameters
+ * ms = a + b / c, where
+ *	a = ms[0], b = ms[1], c = ms[2]
+ * SI5338 RM states the formula of parameters as:
+ *	p1 = floor(((a * c + b) * 128) / c - 512)
+ *	p2 = mod((b * 128), c)
+ *	p3 = c
+ * To reverse the formula, we have
+ *	b * 128 = k * c + p2; k < 128, p2 < c
+ *	p1 = floor(((a * c + b) * 128) / c - 512)
+ *	   = a * 128 + floor((b * 128) / c) - 512
+ *	   = a * 128 + k - 512
+ *	k = mod(p1, 128) = p1 & 0x7f
+ *	c = p3
+ *	b = (k * c + p2) / 128 = ((p1 & 0x7f) * p3 + p2) >> 7
+ *	a = (p1 + 512) >> 7 = (p1 >> 7) + 4
+ */
+static int p_to_ms(u64 *ms, u32 *p)
+{
+	if (!p[0] && !p[1] && !p[2]) {
+		/* uninitialized parameters in device */
+		ms[0] = 0;
+		ms[1] = 0;
+		ms[2] = 1;
+	} else {
+		/* c = p3 */
+		ms[2] = p[2];
+		/* b = (c * (p1 & 0x7f) + p2) >> 7 */
+		ms[1] = (ms[2] * (p[0] & 0x7f) + p[1]) >> 7;
+		/* a = (p1 >> 7) + 4 */
+		ms[0] = (p[0] >> 7) + 4;
+	}
+	pr_debug("ms[]=%llu + %llu/%llu, p=%u %u %u\n",
+		 ms[0], ms[1], ms[2], p[0], p[1], p[2]);
+
+	return 0;
+}
+
+static const u32 awe_ms_hs[] = {
+	AWE_MS0_HS,
+	AWE_MS1_HS,
+	AWE_MS2_HS,
+	AWE_MS3_HS
+};
+
+/*
+ * Read parameters of
+ * 0 - MS0
+ * 1 - MS1
+ * 2 - MS2
+ * 3 - MS3
+ * 4 - MSN (PLL)
+ */
+static int set_ms_p(struct si5338_driver_data *drvdata,
+			u32 *p, int chn)
+{
+	int i, rc, hs = 0;
+
+	rc = _verify_ms_channel(&drvdata->client->dev, chn);
+	if (rc < 0)
+		return rc;
+
+	/* high speed bit programming */
+	if (p[0] < 512) { /* div less than 8 */
+		if (p[0] < 128)
+			p[0] = 0;
+		else
+			p[0] = 256;
+		p[1] = 0;
+		p[2] = 1;
+		hs = 1;
+		dev_dbg(&drvdata->client->dev,
+			"Using high speed divider option on ms%d",
+			chn);
+	}
+
+	rc = write_field(drvdata, hs, awe_ms_hs[chn]);
+	if (rc < 0)
+		return rc;
+
+	for (i = 0; i < 3; i++) {
+		rc = write_multireg64(drvdata, (u64)p[i],
+				      awe_msx[chn][i]);
+		if (rc < 0)
+			return rc;
+	}
+
+	return 0;
+}
+
+/*
+ * Calculate parameters
+ * ms = ms[0] + ms[1] / ms[2]
+ *
+ * SI5338 RM stats the fomula of parameters as
+ *	p[0] = floor(((ms[0] * ms[2] + ms[1]) * 128) / ms[2] - 512)
+ *	p[1] = mod((ms[1] * 128), ms[2])
+ *	p[2] = ms[2]
+ */
+static int ms_to_p(u64 *ms, u32 *p)
+{
+	u64 d;
+	u64 ms_denom = ms[2], ms_num = ms[1], ms_int = ms[0];
+
+	while (ms_denom >= (1 << 30) || !((ms_denom | ms_num) & 1)) {
+		ms_denom >>= 1;
+		ms_num >>= 1;
+	}
+	if (!ms_num || !ms_denom) {
+		ms_denom = 1;
+		ms_num = 0;
+	}
+	d = (ms_int * ms_denom + ms_num) << 7;
+	p[0] = (u32)(div64_u64(d, ms_denom) - 512);
+	d = div64_u64((ms_num << 7), ms_denom);
+	p[1] = (u32)((ms_num << 7) - d * ms_denom);
+	p[2] = ms_denom;
+	pr_debug("ms[]=%llu + %llu/%llu Hz, ms_int=%llu, ms_num=%llu, ms_denom=%llu p=%u %u %u\n",
+		 ms[0], ms[1], ms[2], ms_int, ms_num, ms_denom,
+		 p[0], p[1], p[2]);
+
+	return 0;
+}
+
+/*
+ * Calculate MultiSynth divider (MS0..MS3) for specified output frequency
+ */
+static void cal_ms_p(unsigned long numerator,
+			unsigned long denominator,
+			u32 *p)
+{
+	u64 ms[3];
+
+	ms[1] = numerator;
+	ms[2] = denominator;
+	ms[0] = div64_u64(ms[1], ms[2]);
+	ms[1] -= ms[0] * ms[2];
+	while (ms[2] >= (1 << 30)) { /* trim */
+		ms[2] >>= 1;
+		ms[1] >>= 1;
+	}
+	remove_common_factor(&ms[1]);
+
+	if (ms[0] < MSINT_MIN) {
+		pr_warn("Calculated MSN ratio is too low: %llu < %u\n",
+			ms[0], MSINT_MIN);
+		ms[0] = MSINT_MIN;
+	} else if (ms[0] == 5 || ms[0] == 7) {
+		pr_warn("MSN ratio %llu is invalid\n", ms[0]);
+		ms[0] += 1;
+	} else if (ms[0] > MSINT_MAX) {
+		pr_warn("Calculated MSN ratio is too high: %llu > %u\n",
+			ms[0], MSINT_MAX);
+		ms[0] = MSINT_MAX;
+	}
+	pr_debug("MS divider: %llu+%llu/%llu\n", ms[0], ms[1], ms[2]);
+
+	ms_to_p(ms, p);
+}
+
+/*
+ * Si5338 pll section
+ */
+static int si5338_pll_prepare(struct clk_hw *hw)
+{
+	struct si5338_hw_data *hwdata = HWDATA(hw);
+	struct si5338_driver_data *drvdata = hwdata->drvdata;
+	int rc;
+	s64 pll_in_freq;
+	s64 K, Q, kphi_num, kphi_denom, fvco_mhz, fpfd_mhz;
+	int rsel, bwsel, vco_gain, pll_kphi, mscal, ms_pec;
+	u8 vco_gain_rsel_bwsel;
+
+	pll_in_freq = clk_hw_get_rate(clk_hw_get_parent(hw));
+	if (!pll_in_freq) {
+		dev_err(&drvdata->client->dev, "Invalid input clock for pll\n");
+		return -EINVAL;
+	}
+	if (!clk_get_rate(hw->clk)) {
+		dev_err(&drvdata->client->dev, "Invalid clock rate for pll\n");
+		return -EINVAL;
+	}
+
+	fvco_mhz = div64_u64(clk_hw_get_rate(hw), 1000000ll);
+	fpfd_mhz = div64_u64(pll_in_freq, 1000000ll);
+	if (fpfd_mhz >= 15) {
+		K = 925;
+		rsel = 0;
+		bwsel = 0;
+	} else if (fpfd_mhz >= 8) {
+		K = 325;
+		rsel = 1;
+		bwsel = 1;
+	} else {
+		K = 185;
+		rsel = 3;
+		bwsel = 2;
+	}
+	if (fvco_mhz > 2425) {
+		Q = 3;
+		vco_gain = 0;
+	} else {
+		Q = 4;
+		vco_gain = 1;
+	}
+	kphi_num = K * 2500LL * 2500LL * 2500LL;
+	kphi_denom = 533LL * Q * fpfd_mhz * fvco_mhz * fvco_mhz;
+	pll_kphi = (int)div64_u64(kphi_num + (kphi_denom >> 1), kphi_denom);
+	if (pll_kphi < 1 || pll_kphi > 127) {
+		dev_warn(&drvdata->client->dev,
+			"Calculated PLL_KPHI does not fit 1<=%d<=127\n",
+			pll_kphi);
+		if (pll_kphi < 1)
+			pll_kphi = 1;
+		else if (pll_kphi > 127)
+			pll_kphi = 127;
+	}
+	mscal = (int)div64_u64(2067000 - 667 * fvco_mhz + 50000, 100000ll);
+	if (mscal < 0 || mscal > 63) {
+		dev_warn(&drvdata->client->dev,
+			"Calculated MSCAL does not fit 0<=%d<=63\n",
+			mscal);
+		if (mscal < 0)
+			mscal = 0;
+		else if (mscal > 63)
+			mscal = 63;
+	}
+	ms_pec = 7;
+	dev_dbg(&drvdata->client->dev,
+		"Calculated values: PLL_KPHI=%d K=%lld RSEL=%d BWSEL=%d VCO_GAIN=%d MSCAL=%d MS_PEC=%d\n",
+		pll_kphi, K, rsel, bwsel, vco_gain, mscal, ms_pec);
+
+	/* setting actual registers */
+	rc = write_field(drvdata, pll_kphi, AWE_PLL_KPHI);
+	if (rc < 0)
+		return rc;
+
+	vco_gain_rsel_bwsel = (vco_gain & 7) << 4;
+	vco_gain_rsel_bwsel |= (rsel & 3) << 2;
+	vco_gain_rsel_bwsel |= bwsel & 3;
+	rc = write_field(drvdata, vco_gain_rsel_bwsel, AWE_VCO_GAIN_RSEL_BWSEL);
+	if (rc < 0)
+		return rc;
+
+	rc = write_field(drvdata, mscal, AWE_MSCAL);
+	if (rc < 0)
+		return rc;
+
+	rc = write_field(drvdata, ms_pec, AWE_MS_PEC);
+	if (rc < 0)
+		return rc;
+
+	rc = write_field(drvdata, 3, AWE_PLL_EN);
+	if (rc < 0)
+		return rc; /* enable PLL */
+
+	return 0;
+}
+
+static int si5338_pll_reparent(struct si5338_driver_data *drvdata,
+				u8 index)
+{
+	struct si5338_hw_data *hwdata = &drvdata->pll;
+	int rc = -EINVAL;
+
+	hwdata->num = SI5338_PFD_IN_REF_NOCLK;
+	switch (index) {
+	case SI5338_PFD_IN_REF_REFCLK:
+	case SI5338_PFD_IN_REF_FBCLK:
+	case SI5338_PFD_IN_REF_DIVREFCLK:
+	case SI5338_PFD_IN_REF_DIVFBCLK:
+	case SI5338_PFD_IN_REF_XOCLK:
+	case SI5338_PFD_IN_REF_NOCLK:
+		/* pfd_in_ref mux */
+		rc = set_in_pfd_ref_fb(drvdata, index, 0);
+		break;
+	default:
+		dev_err(&drvdata->client->dev,
+			"Invalid pfd_in_ref mux selection %d\n",
+			index);
+		break;
+	}
+
+	if (!rc)
+		hwdata->num = index;	/* record the source of pll */
+
+	return rc;
+}
+
+static unsigned char si5338_pll_get_parent(struct clk_hw *hw)
+{
+	struct si5338_hw_data *hwdata = HWDATA(hw);
+	struct si5338_driver_data *drvdata = hwdata->drvdata;
+	int pfd_in_ref;
+
+	/* Get pfd_in_ref mux value */
+	pfd_in_ref = get_in_pfd_ref_fb(drvdata, 0);
+	if (pfd_in_ref < 0) {
+		dev_err(&drvdata->client->dev,
+			"Error getting pfd_in_ref mux\n");
+		/* In case reading register fails, set to 0 */
+		pfd_in_ref = 0;
+	}
+	hwdata->num = pfd_in_ref;
+
+	return pfd_in_ref;
+}
+
+static int si5338_pll_set_parent(struct clk_hw *hw, u8 index)
+{
+	struct si5338_hw_data *hwdata = HWDATA(hw);
+
+	return si5338_pll_reparent(hwdata->drvdata, index);
+}
+
+static unsigned long si5338_pll_recalc_rate(struct clk_hw *hw,
+					    unsigned long parent_rate)
+{
+	struct si5338_hw_data *hwdata = HWDATA(hw);
+	struct si5338_driver_data *drvdata = hwdata->drvdata;
+	int rc;
+	u64 rate[3], ms[3], ms_scaled;
+
+	if (!hwdata->params.valid) {
+		rc = get_ms_p(drvdata, hwdata->params.p, 4);
+		if (rc < 0) {
+			dev_err(&drvdata->client->dev,
+				"Error reading ms register\n");
+			return 0;
+		}
+		hwdata->params.valid = true;
+	}
+
+	p_to_ms(ms, hwdata->params.p);
+	if (unlikely(!ms[2])) {
+		/*
+		 * This should not happen. Instead of crashing the system,
+		 * set divisor to 1 and let the calculation continue.
+		 */
+		dev_warn(&drvdata->client->dev,
+			"Error %s calculating pll\n", __func__);
+		ms[2] = 1;
+	}
+	ms_scaled = ms[0] * ms[2] + ms[1];
+	if (!ms_scaled)	/* uninitialzied */
+		return 0;
+
+	rate[2] = ms[2];
+	rate[1] = parent_rate * ms_scaled;
+	rate[0] = div64_u64(rate[1], rate[2]);
+	rate[1] -= rate[0] * rate[2];
+	remove_common_factor(&rate[1]);
+	dev_dbg(&drvdata->client->dev,
+		"PLL output frequency: %llu+%llu/%llu Hz\n",
+		rate[0], rate[1], rate[2]);
+
+	return rate[0];
+}
+
+static long si5338_pll_round_rate(struct clk_hw *hw, unsigned long rate,
+				  unsigned long *parent_rate)
+{
+	struct si5338_hw_data *hwdata = HWDATA(hw);
+	struct si5338_driver_data *drvdata = hwdata->drvdata;
+	u64 ms[] = {0, 0, 1};
+	u64 new_rate[3], ms_scaled;
+
+	if (unlikely(rate < FVCOMIN))
+		rate = FVCOMIN;
+	else if (unlikely(rate > FVCOMAX))
+		rate = FVCOMAX;
+
+	cal_ms_p(rate, *parent_rate, hwdata->params.p);
+	hwdata->params.valid = true;
+
+	p_to_ms(ms, hwdata->params.p);
+	ms_scaled = ms[0] * ms[2] + ms[1];
+
+	new_rate[2] = ms[2];
+	new_rate[1] = *parent_rate * ms_scaled;
+	new_rate[0] = div64_u64(new_rate[1], new_rate[2]);
+	new_rate[1] -= new_rate[0] * new_rate[2];
+	remove_common_factor(&new_rate[1]);
+	dev_dbg(&drvdata->client->dev,
+		"PLL output frequency: %llu+%llu/%llu Hz\n",
+		new_rate[0], new_rate[1], new_rate[2]);
+
+	return new_rate[0];
+}
+
+static int si5338_pll_set_rate(struct clk_hw *hw, unsigned long rate,
+				unsigned long parent_rate)
+{
+	struct si5338_hw_data *hwdata = HWDATA(hw);
+	struct si5338_driver_data *drvdata = hwdata->drvdata;
+
+	if (unlikely(rate < FVCOMIN))
+		rate = FVCOMIN;
+	else if (unlikely(rate > FVCOMAX))
+		rate = FVCOMAX;
+	cal_ms_p(rate, parent_rate, hwdata->params.p);
+	hwdata->params.valid = true;
+
+	return set_ms_p(drvdata, hwdata->params.p, 4);
+}
+
+static const struct clk_ops si5338_pll_ops = {
+	.prepare = si5338_pll_prepare,
+	.set_parent = si5338_pll_set_parent,
+	.get_parent = si5338_pll_get_parent,
+	.recalc_rate = si5338_pll_recalc_rate,
+	.round_rate = si5338_pll_round_rate,
+	.set_rate = si5338_pll_set_rate,
+};
+
+/*
+ * Si5338 multisynth divider
+ */
+
+static const u32 awe_ms_powerdown[] = {
+	AWE_MS0_PDN,
+	AWE_MS1_PDN,
+	AWE_MS2_PDN,
+	AWE_MS3_PDN
+};
+
+static int set_ms_powerdown(struct si5338_driver_data *drvdata,
+			     int down, int chn)
+{
+	if (chn < 0 || chn > 3)
+		return -EINVAL;
+
+	return write_field(drvdata, down, awe_ms_powerdown[chn]);
+}
+
+static int si5338_msynth_prepare(struct clk_hw *hw)
+{
+	struct si5338_hw_data *hwdata = HWDATA(hw);
+	struct si5338_driver_data *drvdata = hwdata->drvdata;
+
+	return set_ms_powerdown(drvdata, MS_POWER_UP, hwdata->num);
+}
+
+static void si5338_msynth_unprepare(struct clk_hw *hw)
+{
+	struct si5338_hw_data *hwdata = HWDATA(hw);
+	struct si5338_driver_data *drvdata = hwdata->drvdata;
+
+	set_ms_powerdown(drvdata, MS_POWER_DOWN, hwdata->num);
+}
+
+static unsigned long si5338_msynth_recalc_rate(struct clk_hw *hw,
+					       unsigned long parent_rate)
+{
+	struct si5338_hw_data *hwdata = HWDATA(hw);
+	struct si5338_driver_data *drvdata = hwdata->drvdata;
+	int rc;
+	u64 rate[3], ms[3], ms_scaled;
+
+	if (!hwdata->params.valid) {
+		rc = get_ms_p(drvdata, hwdata->params.p, hwdata->num);
+		if (rc < 0)
+			return 0;
+		hwdata->params.valid = true;
+	}
+
+	p_to_ms(ms, hwdata->params.p);
+	if (unlikely(!ms[2])) {
+		/* This should not happen */
+		dev_warn(&drvdata->client->dev,
+			"Error %s calculating MS%d\n", __func__, hwdata->num);
+		ms[2] = 1;
+	}
+	/* trim MS divider fraction */
+	while (ms[2] >= 0x1000) {
+		ms[1] >>= 1;
+		ms[2] >>= 1;
+	}
+	ms_scaled = ms[0] * ms[2] + ms[1];
+	if (!ms_scaled)	/* uninitialized */
+		return 0;
+
+	rate[2] = ms_scaled;
+	rate[1] = parent_rate * ms[2];
+	rate[0] = div64_u64(rate[1], rate[2]);
+	rate[1] -= rate[0] * rate[2];
+	remove_common_factor(&rate[1]);
+	dev_dbg(&drvdata->client->dev,
+		"MS%d output frequency: %llu+%llu/%llu Hz\n",
+		hwdata->num, rate[0], rate[1], rate[2]);
+
+	return rate[0];
+}
+
+/*
+ * Based on PLL input clock, estimate best ratio for desired output
+ * if pll vco is not specified.
+ */
+static long si5338_msynth_round_rate(struct clk_hw *hw, unsigned long rate,
+				     unsigned long *parent_rate)
+{
+	struct si5338_hw_data *hwdata = HWDATA(hw);
+	struct si5338_driver_data *drvdata = hwdata->drvdata;
+	s64 rate_scaled, pll_in_freq;
+	s64 center, center_diff, best_center_diff = 0;
+	s64 out_div, best_out_div = 1;
+	s64 d, in_div, best_in_div;
+	s64 err, best_err = 0;
+	s64 synth_out;
+	u64 ms[3];
+
+	if (__clk_get_flags(hw->clk) & CLK_SET_RATE_PARENT) {
+		/*
+		 * Get rate of the parent of PLL
+		 * (could be refclk, fbclk, etc.)
+		 */
+		pll_in_freq = clk_hw_get_rate(
+				clk_hw_get_parent(clk_hw_get_parent(hw)));
+		if (!pll_in_freq) {
+			dev_err(&drvdata->client->dev,
+				"Invalid input clock for MS%d\n",
+				hwdata->num);
+			return -EINVAL;
+		}
+
+		center = (FVCOMAX + FVCOMIN) >> 1;
+
+		best_in_div = 0;
+		for (out_div = 4; out_div <= MSINT_MAX; out_div++) {
+			if (out_div == 5 || out_div == 7)
+				continue;
+
+			/* here scaled by denominator */
+			rate_scaled = rate * out_div;
+			if (rate_scaled < FVCOMIN || rate_scaled > FVCOMAX)
+				continue;
+
+			in_div = div64_u64(rate_scaled +
+					   (pll_in_freq >> 1),
+					   pll_in_freq); /* round */
+
+			/* actual pll frequency scaled by out_denom */
+			d = pll_in_freq * in_div;
+			synth_out = div64_u64(d + (out_div >> 1), out_div);
+			center_diff = d - center;
+			if (center_diff < 0)
+				center_diff = -center_diff;
+			err = synth_out - rate;
+			if (err < 0)
+				err = -err;
+			if (!best_in_div || err < best_err ||
+			    (err == best_err &&
+			     center_diff < best_center_diff)) {
+				dev_dbg(&drvdata->client->dev,
+					"synth_out: %lld center: %lld rate:%lu err: %lld (%lld) center_diff:%lld(%lld)\n",
+					synth_out, center, rate, err, best_err,
+					center_diff, best_center_diff);
+				best_err = err;
+				best_in_div = in_div;
+				best_out_div = out_div;
+				best_center_diff = center_diff;
+			}
+		}
+		if (!best_in_div) {
+			dev_warn(&drvdata->client->dev,
+				 "Failed to find suitable integer coefficients for pll input %lld Hz\n",
+				 pll_in_freq);
+		}
+		*parent_rate = pll_in_freq * best_in_div;
+		rate = *parent_rate / (unsigned long)best_out_div;
+		dev_dbg(&drvdata->client->dev,
+			"Best MS output frequency: %lu Hz, MS input divider: %lld, MS output divider: %lld\n",
+			rate, best_in_div, best_out_div);
+	} else {
+		ms[1] = *parent_rate;
+		ms[2] = rate;
+		if (!rate) {
+			dev_err(&drvdata->client->dev,
+				"Invalid rate for MS%d\n", hwdata->num);
+			return -EINVAL;
+		}
+		ms[0] = div64_u64(ms[1], ms[2]);
+		ms[1] -= ms[0] * ms[2];
+		remove_common_factor(&ms[1]);
+		if (ms[0]  == 5 || ms[0] == 7)
+			out_div++;
+		rate = div64_u64(*parent_rate * ms[2], ms[1] + ms[0] * ms[2]);
+		dev_dbg(&drvdata->client->dev,
+			"Cloest MS output frequency: %lu Hz, output divider %llu+%llu/%llu\n",
+			rate, ms[0], ms[1], ms[2]);
+	}
+
+	cal_ms_p(*parent_rate, rate, hwdata->params.p);
+	hwdata->params.valid = true;
+
+	return rate;
+}
+
+/*
+ * multisynth's parent is PLL
+ */
+static int si5338_msynth_set_rate(struct clk_hw *hw, unsigned long rate,
+				  unsigned long parent_rate)
+{
+	struct si5338_hw_data *hwdata = HWDATA(hw);
+	struct si5338_driver_data *drvdata = hwdata->drvdata;
+
+	if (!rate)
+		rate = div64_u64(parent_rate + MSINT_MAX - 1, MSINT_MAX);
+
+	cal_ms_p(parent_rate, rate, hwdata->params.p);
+	hwdata->params.valid = true;
+
+	return set_ms_p(drvdata, hwdata->params.p, hwdata->num);
+}
+
+static const struct clk_ops si5338_msynth_ops = {
+	.prepare = si5338_msynth_prepare,
+	.unprepare = si5338_msynth_unprepare,
+	.recalc_rate = si5338_msynth_recalc_rate,
+	.round_rate = si5338_msynth_round_rate,
+	.set_rate = si5338_msynth_set_rate,
+};
+
+/*
+ * Si5338 clkout
+ */
+
+static const u32 awe_out_disable[] = {
+	AWE_OUT0_DIS,
+	AWE_OUT1_DIS,
+	AWE_OUT2_DIS,
+	AWE_OUT3_DIS,
+	AWE_OUT_ALL_DIS
+};
+
+static int set_out_disable(struct si5338_driver_data *drvdata,
+			   int dis, int chn)
+{
+	int rc;
+
+	rc = _verify_output_channel(chn);
+	if (rc < 0)
+		return rc;
+
+	return write_field(drvdata, dis, awe_out_disable[chn]);
+}
+
+static const u32 awe_drv_dis_state[] = {
+	AWE_OUT0_DIS_STATE,
+	AWE_OUT1_DIS_STATE,
+	AWE_OUT2_DIS_STATE,
+	AWE_OUT3_DIS_STATE
+};
+
+static int si5338_clkout_set_disable_state(struct si5338_driver_data *drvdata,
+					   int chn, int typ)
+{
+	int rc;
+
+	rc = _verify_output_channel(chn);
+	if (rc < 0)
+		return rc;
+
+	if (typ < 0 || typ > 3) {
+		dev_err(&drvdata->client->dev,
+			"Invalid disabled state %d. Only 0..3 are supported\n",
+			typ);
+		return -EINVAL;
+	}
+
+	return write_field(drvdata, typ, awe_drv_dis_state[chn]);
+}
+
+static const u32 awe_rdiv_in[] = {
+	AWE_R0DIV_IN,
+	AWE_R1DIV_IN,
+	AWE_R2DIV_IN,
+	AWE_R3DIV_IN
+};
+
+/*
+ * src	0: fbclk
+ *	1: refclk
+ *	2: divfbclk
+ *	3: divrefclk
+ *	4: xoclk
+ *	5: MS0
+ *	6: MS1/2/3 respetivelly
+ */
+static int set_out_mux(struct si5338_driver_data *drvdata, int chn, int src)
+{
+	int rc;
+
+	rc = _verify_output_channel(chn);
+	if (rc < 0)
+		return rc;
+
+	if (src < 0 || src > 7) {
+		dev_err(&drvdata->client->dev,
+			"Invalid source %d. Only 0...7 are supported\n",
+			src);
+		return -EINVAL;
+	}
+
+	return write_field(drvdata, src, awe_rdiv_in[chn]);
+}
+
+static int get_out_mux(struct si5338_driver_data *drvdata, int chn)
+{
+	int rc;
+
+	rc = _verify_output_channel(chn);
+	if (rc < 0)
+		return rc;
+
+	return read_field(drvdata, awe_rdiv_in[chn]);
+}
+
+static const u32 awe_drv_fmt[] = {
+	AWE_DRV0_FMT,
+	AWE_DRV1_FMT,
+	AWE_DRV2_FMT,
+	AWE_DRV3_FMT
+};
+
+static int set_drv_type(struct si5338_driver_data *drvdata, int typ, int chn)
+{
+	int rc;
+
+	rc = _verify_output_channel(chn);
+	if (rc < 0)
+		return rc;
+
+	if (typ < 0 || typ > 7) {
+		dev_err(&drvdata->client->dev,
+			"Invalid output type %d. Only 0..7 are supported\n",
+			typ);
+		return -EINVAL;
+	}
+
+	return write_field(drvdata, typ, awe_drv_fmt[chn]);
+}
+
+static const u32 awe_drv_vddo[] = {
+	AWE_DRV0_VDDO,
+	AWE_DRV1_VDDO,
+	AWE_DRV2_VDDO,
+	AWE_DRV3_VDDO
+};
+
+static int set_drv_vdd(struct si5338_driver_data *drvdata, int vdd, int chn)
+{
+	int rc;
+
+	rc = _verify_output_channel(chn);
+	if (rc < 0)
+		return rc;
+
+	if (vdd < 0 || vdd > 7) {
+		dev_err(&drvdata->client->dev,
+			"Invalid output type %d. Only 0..3 are supported\n",
+			vdd);
+		return -EINVAL;
+	}
+
+	return write_field(drvdata, vdd, awe_drv_vddo[chn]);
+}
+
+static const u32 awe_drv_trim[][3] = {
+	{ AWE_DRV0_TRIM, 0, 0 },
+	{ AWE_DRV1_TRIM_A, AWE_DRV1_TRIM_B, 0},
+	{ AWE_DRV2_TRIM, 0, 0},
+	{ AWE_DRV3_TRIM, 0, 0}
+};
+
+static int set_drv_trim_any(struct si5338_driver_data *drvdata,
+			    int trim, int chn)
+{
+	int rc;
+
+	rc = _verify_output_channel(chn);
+	if (rc < 0)
+		return rc;
+
+	if (trim < 0 || trim > 31) {
+		dev_err(&drvdata->client->dev,
+			"Invalid output type %d. Only 0..31 are supported\n",
+			trim);
+		return -EINVAL;
+	}
+
+	return write_multireg64(drvdata, trim, awe_drv_trim[chn]);
+}
+
+static const u32 awe_drv_invert[] = {
+	AWE_DRV0_INV,
+	AWE_DRV1_INV,
+	AWE_DRV2_INV,
+	AWE_DRV3_INV
+};
+
+static int set_drv_invert(struct si5338_driver_data *drvdata, int typ, int chn)
+{
+	int rc;
+
+	rc = _verify_output_channel(chn);
+	if (rc < 0)
+		return rc;
+
+	if (typ < 0 || typ > 3) {
+		dev_err(&drvdata->client->dev,
+			"Invalid invert drivers %d. Only 0..3 are supported\n",
+			typ);
+		return -EINVAL;
+	}
+
+	return write_field(drvdata, typ, awe_drv_invert[chn]);
+}
+
+static const u32 awe_drv_powerdown[] = {
+	AWE_DRV0_PDN,
+	AWE_DRV1_PDN,
+	AWE_DRV2_PDN,
+	AWE_DRV3_PDN
+};
+
+static int set_drv_powerdown(struct si5338_driver_data *drvdata,
+			     int typ, int chn)
+{
+	int rc;
+
+	rc = _verify_output_channel(chn);
+	if (rc < 0)
+		return rc;
+
+	return write_field(drvdata, typ, awe_drv_powerdown[chn]);
+}
+
+static const struct si5338_drv_t drv_configs[] = {
+	{"3V3_CMOS_A+",	0x1, 0x0, 0x17, 0x8}, /* bX0 */
+	{"3V3_CMOS_A-",	0x1, 0x0, 0x17, 0x9}, /* bX1 */
+	{"3V3_CMOS_B+",	0x2, 0x0, 0x17, 0x4}, /* b0X */
+	{"3V3_CMOS_B-",	0x2, 0x0, 0x17, 0x6}, /* b1X */
+	{"3V3_CMOS_A+B+", 0x3, 0x0, 0x17, 0x8},
+	{"3V3_CMOS_A-B+", 0x3, 0x0, 0x17, 0x9},
+	{"3V3_CMOS_A+B-", 0x3, 0x0, 0x17, 0x4},
+	{"3V3_CMOS_A-B-", 0x3, 0x0, 0x17, 0x6},
+
+	{"2V5_CMOS_A+",	0x1, 0x1, 0x13, 0x8},
+	{"2V5_CMOS_A-",	0x1, 0x1, 0x13, 0x9},
+	{"2V5_CMOS_B+",	0x2, 0x1, 0x13, 0x4},
+	{"2V5_CMOS_B-",	0x2, 0x1, 0x13, 0x6},
+	{"2V5_CMOS_A+B+", 0x3, 0x1, 0x13, 0x8},
+	{"2V5_CMOS_A-B+", 0x3, 0x1, 0x13, 0x9},
+	{"2V5_CMOS_A+B-", 0x3, 0x1, 0x13, 0x4},
+	{"2V5_CMOS_A-B-", 0x3, 0x1, 0x13, 0x6},
+
+	{"1V8_CMOS_A+",	0x1, 0x2, 0x15, 0x8},
+	{"1V8_CMOS_A-",	0x1, 0x2, 0x15, 0x9},
+	{"1V8_CMOS_B+",	0x2, 0x2, 0x15, 0x4},
+	{"1V8_CMOS_B-",	0x2, 0x2, 0x15, 0x6},
+	{"1V8_CMOS_A+B+", 0x3, 0x2, 0x15, 0x8},
+	{"1V8_CMOS_A-B+", 0x3, 0x2, 0x15, 0x9},
+	{"1V8_CMOS_A+B-", 0x3, 0x2, 0x15, 0x4},
+	{"1V8_CMOS_A-B-", 0x3, 0x2, 0x15, 0x6},
+
+	{"1V5_HSTL_A+",	0x1, 0x3, 0x1f, 0x8},
+	{"1V5_HSTL_A-",	0x1, 0x3, 0x1f, 0x9},
+	{"1V5_HSTL_B+",	0x2, 0x3, 0x1f, 0x4},
+	{"1V5_HSTL_B-",	0x2, 0x3, 0x1f, 0x6},
+	{"1V5_HSTL_A+B+", 0x3, 0x3, 0x1f, 0x8},
+	{"1V5_HSTL_A-B+", 0x3, 0x3, 0x1f, 0x9},
+	{"1V5_HSTL_A+B-", 0x3, 0x3, 0x1f, 0x4},
+	{"1V5_HSTL_A-B-", 0x3, 0x3, 0x1f, 0x6},
+
+	{"3V3_SSTL_A+",	0x1, 0x0, 0x04, 0x8},
+	{"3V3_SSTL_A-",	0x1, 0x0, 0x04, 0x9},
+	{"3V3_SSTL_B+",	0x2, 0x0, 0x04, 0x4},
+	{"3V3_SSTL_B-",	0x2, 0x0, 0x04, 0x6},
+	{"3V3_SSTL_A+B+", 0x3, 0x0, 0x04, 0x8},
+	{"3V3_SSTL_A-B+", 0x3, 0x0, 0x04, 0x9},
+	{"3V3_SSTL_A+B-", 0x3, 0x0, 0x04, 0x5},
+	{"3V3_SSTL_A-B-", 0x3, 0x0, 0x04, 0x6},
+
+	{"2V5_SSTL_A+",	0x1, 0x1, 0x0d, 0x8},
+	{"2V5_SSTL_A-",	0x1, 0x1, 0x0d, 0x9},
+	{"2V5_SSTL_B+",	0x2, 0x1, 0x0d, 0x4},
+	{"2V5_SSTL_B-",	0x2, 0x1, 0x0d, 0x6},
+	{"2V5_SSTL_A+B+", 0x3, 0x1, 0x0d, 0x8},
+	{"2V5_SSTL_A-B+", 0x3, 0x1, 0x0d, 0x9},
+	{"2V5_SSTL_A+B-", 0x3, 0x1, 0x0d, 0x5},
+	{"2V5_SSTL_A-B-", 0x3, 0x1, 0x0d, 0x6},
+
+	{"1V8_SSTL_A+",	0x1, 0x2, 0x17, 0x8},
+	{"1V8_SSTL_A-",	0x1, 0x2, 0x17, 0x9},
+	{"1V8_SSTL_B+",	0x2, 0x2, 0x17, 0x4},
+	{"1V8_SSTL_B-",	0x2, 0x2, 0x17, 0x6},
+	{"1V8_SSTL_A+B+", 0x3, 0x2, 0x17, 0x8},
+	{"1V8_SSTL_A-B+", 0x3, 0x2, 0x17, 0x9},
+	{"1V8_SSTL_A+B-", 0x3, 0x2, 0x17, 0x4},
+	{"1V8_SSTL_A-B-", 0x3, 0x2, 0x17, 0x6},
+
+	{"3V3_LVPECL",	0x4, 0x0, 0x0f, 0xc},
+	{"2V5_LVPECL",	0x4, 0x1, 0x10, 0xc},
+	{"3V3_LVDS",	0x6, 0x0, 0x03, 0xc},
+	{"2V5_LVDS",	0x6, 0x1, 0x04, 0xc},
+	{"1V8_LVDS",	0x6, 0x2, 0x04, 0xc},
+
+	{},
+};
+
+static int find_drive_config(const char *name)
+{
+	int i;
+
+	for (i = 0; drv_configs[i].description; i++) {
+		if (!strcmp(name, drv_configs[i].description))
+			return i;
+	}
+
+	return -EINVAL;
+}
+
+static int si5338_clkout_set_drive_config(struct si5338_driver_data *drvdata,
+				   int chn, const char *name)
+{
+	int i, rc;
+
+	rc = _verify_output_channel(chn);
+	if (rc < 0)
+		return rc;
+
+	i = find_drive_config(name);
+	if (i < 0) {
+		dev_err(&drvdata->client->dev,
+			"Invalid driver configuration\n");
+		return -EINVAL;
+	}
+
+	rc = set_drv_type(drvdata, drv_configs[i].fmt, chn);
+	if (rc < 0)
+		return rc;
+
+	rc = set_drv_vdd(drvdata, drv_configs[i].vdd, chn);
+	if (rc < 0)
+		return rc;
+
+	rc = set_drv_trim_any(drvdata, drv_configs[i].trim, chn);
+	if (rc < 0)
+		return rc;
+
+	rc = set_drv_invert(drvdata,
+			    drv_configs[i].invert & 3, chn);
+	if (rc < 0)
+		return rc;
+
+	return 0;
+}
+
+static const u32 awe_rdiv_k[] = {
+	AWE_R0DIV,
+	AWE_R1DIV,
+	AWE_R2DIV,
+	AWE_R3DIV
+};
+
+static const u8 out_div_values[] = {
+	1, 2, 4, 8, 16, 32
+};
+
+static int get_out_div(struct si5338_driver_data *drvdata, int chn)
+{
+	int rc;
+
+	rc = _verify_output_channel(chn);
+	if (rc < 0)
+		return rc;
+
+	rc = read_field(drvdata, awe_rdiv_k[chn]);
+	if (rc < 0)
+		return rc;
+
+	if (rc >= ARRAY_SIZE(out_div_values)) {
+		dev_err(&drvdata->client->dev,
+			"Invalid value for output divider: %d\n",
+			rc);
+		return -EINVAL;
+	}
+
+	return out_div_values[rc];
+}
+
+static int set_out_div(struct si5338_driver_data *drvdata, int div, int chn)
+{
+	int rc;
+	u8 val;
+
+	rc = _verify_output_channel(chn);
+	if (rc < 0)
+		return rc;
+
+	for (val = 0; val < ARRAY_SIZE(out_div_values); val++) {
+		if (out_div_values[val] == div) {
+			rc = write_field(drvdata, val, awe_rdiv_k[chn]);
+			if (rc < 0)
+				return rc;
+
+			return 0;
+		}
+	}
+	dev_err(&drvdata->client->dev,
+		"Invalid value for output divider: %d\n",
+		div);
+
+	return -EINVAL;
+}
+
+static int get_status(struct si5338_driver_data *drvdata)
+{
+	return read_field(drvdata, AWE_STATUS);
+}
+
+static int power_up_down_needed_ms(struct si5338_driver_data *drvdata)
+{
+	int rc, chn, out_src;
+	int ms_used = 0;
+
+	for (chn = 0; chn < 4; chn++) {
+		out_src = get_out_mux(drvdata, chn);
+		if (out_src < 0)
+			return out_src;
+
+		switch (out_src) {
+		case 5:
+			ms_used |= 1;
+			break;
+		case 6:
+			ms_used |= (1 << chn);
+			break;
+		}
+	}
+	for (chn = 0; chn < 4; chn++) {
+		rc = set_ms_powerdown(drvdata,
+				      (ms_used & (1 << chn)) ? MS_POWER_UP :
+							       MS_POWER_DOWN,
+				      chn);
+		if (rc < 0)
+			return rc;
+	}
+
+	return 0;
+}
+
+static const u32 awe_fcal[] = {
+	AWE_FCAL_07_00,
+	AWE_FCAL_15_08,
+	AWE_FCAL_17_16,
+	0
+};
+
+static const u32 awe_fcal_ovrd[] = {
+	AWE_FCAL_OVRD_07_00,
+	AWE_FCAL_OVRD_15_08,
+	AWE_FCAL_OVRD_17_15,
+	0
+};
+
+static int reset_ms(struct si5338_driver_data *drvdata)
+{
+	int rc;
+
+	dev_dbg(&drvdata->client->dev, "Resetting MS dividers");
+	/* SET MS RESET = 1 */
+	rc = write_field(drvdata, 1, AWE_MS_RESET);
+	if (rc)
+		return rc;
+
+	/* Wait for 20ms */
+	msleep(20);
+
+	/* SET MS RESET = 0 */
+	rc = write_field(drvdata, 0, AWE_MS_RESET);
+	if (rc)
+		return rc;
+
+	return 0;
+}
+
+static int set_misc_registers(struct si5338_driver_data *drvdata)
+{
+	/* ST52238 Reference Manual R1.2 p.28 */
+	int rc;
+
+	rc = write_field(drvdata, 0x5, AWE_MISC_47);
+	if (rc)
+		return rc;
+
+	rc = write_field(drvdata, 0x1, AWE_MISC_106);
+	if (rc)
+		return rc;
+
+	rc = write_field(drvdata, 0x1, AWE_MISC_116);
+	if (rc)
+		return rc;
+
+	rc = write_field(drvdata, 0x1, AWE_MISC_42);
+	if (rc)
+		return rc;
+
+	rc = write_field(drvdata, 0x0, AWE_MISC_06A);
+	if (rc)
+		return rc;
+
+	rc = write_field(drvdata, 0x0, AWE_MISC_06B);
+	if (rc)
+		return rc;
+
+	rc = write_field(drvdata, 0x0, AWE_MISC_28);
+	if (rc)
+		return rc;
+
+	return 0;
+}
+
+/* Disable interrupt, all outputs */
+static int pre_init(struct si5338_driver_data *drvdata)
+{
+	int rc, chn;
+
+	/* Disable interrupts */
+	rc = write_field(drvdata, 0x1d, AWE_INT_MASK);
+	if (rc)
+		return rc;
+
+	/* setup miscelalneous registers */
+	rc = set_misc_registers(drvdata);
+	if (rc)
+		return rc;
+
+	/* disable all outputs */
+	rc = write_field(drvdata, 1, AWE_OUT_ALL_DIS);
+	if (rc)
+		return rc;
+
+	/* pause LOL */
+	rc = write_field(drvdata, 1, AWE_DIS_LOS);
+	if (rc)
+		return rc;
+
+	/* clears outputs pll input/fb muxes to be set later */
+	for (chn = 0; chn < 4; chn++) {
+		rc = set_ms_powerdown(drvdata, MS_POWER_DOWN, chn);
+		if (rc)
+			return rc;
+		rc = set_out_disable(drvdata, OUT_DISABLE, chn);
+		if (rc)
+			return rc;
+	}
+	/* to be explicitly enabled if needed */
+	rc = set_in_pfd_ref_fb(drvdata, 5, 0);	/* noclk */
+	if (rc)
+		return rc;
+
+	rc = set_in_pfd_ref_fb(drvdata, 5, 1);	/* noclk */
+	if (rc)
+		return rc;
+
+	return 0;
+}
+
+#define INIT_TIMEOUT		10	/* max 10 loops */
+
+/* See SI5338 RM for programming procedure */
+static int post_init(struct si5338_driver_data *drvdata)
+{
+	int rc = 0, i, in_src, fb_src, ext_fb, check_los = 0;
+	int timeout = INIT_TIMEOUT;
+	u64 fcal;
+
+	/* validate input clock status */
+	in_src = get_in_pfd_ref_fb(drvdata, 0);
+	if (in_src < 0)
+		return in_src;
+
+	switch (in_src) {
+	case SI5338_PFD_IN_REF_REFCLK:
+	case SI5338_PFD_IN_REF_DIVREFCLK:
+	case SI5338_PFD_IN_REF_XOCLK:
+		check_los |= AWE_STATUS_PLL_LOS_CLKIN;
+		break;
+	case SI5338_PFD_IN_REF_FBCLK:
+	case SI5338_PFD_IN_REF_DIVFBCLK:
+		check_los |= AWE_STATUS_PLL_LOS_FDBK;
+		break;
+	}
+	ext_fb = read_field(drvdata, AWE_PFD_EXTFB);
+	if (ext_fb < 0)
+		return ext_fb;
+
+	if (ext_fb) {
+		fb_src = get_in_pfd_ref_fb(drvdata, 1);
+		if (fb_src < 0)
+			return fb_src;
+
+		switch (in_src) {
+		case SI5338_PFD_IN_FB_REFCLK:
+		case SI5338_PFD_IN_FB_DIVREFCLK:
+			check_los |= AWE_STATUS_PLL_LOS_CLKIN;
+			break;
+		case SI5338_PFD_IN_FB_FBCLK:
+		case SI5338_PFD_IN_FB_DIVFBCLK:
+			check_los |= AWE_STATUS_PLL_LOS_FDBK;
+			break;
+		}
+	}
+	check_los &= 0xf;
+	for (i = 0; i < timeout; i++) {
+		rc = get_status(drvdata);
+		if (rc < 0)
+			return rc;
+
+		if (!(rc & check_los))
+			break; /* inputs OK */
+		msleep(100);	/* wait for 100ms before polling */
+	}
+
+	if (i >= timeout) {
+		dev_err(&drvdata->client->dev,
+			"Timeout waiting for input clocks, status=0x%x, mask=0x%x\n",
+			rc, check_los);
+		return -ETIMEDOUT;
+	}
+	dev_dbg(&drvdata->client->dev,
+		"Validated input clocks, t=%d cycles (timeout= %d cycles), status =0x%x, mask=0x%x\n",
+		i, timeout, rc, check_los);
+
+	/* Configure PLL for locking, set FCAL_OVRD_EN = 0 */
+	rc = write_field(drvdata, 0, AWE_FCAL_OVRD_EN);
+	if (rc < 0)
+		return rc;
+
+	/* Configure PLL for locking, set SOFT_RESET = 1 (ignore i2c error) */
+	write_field(drvdata, 1, AWE_SOFT_RESET);
+	msleep(25);
+
+	/* re-enable LOL, set reg 241 = 0x65 */
+	rc = write_field(drvdata, 0x65, AWE_REG241);
+	if (rc < 0)
+		return rc;
+
+	check_los |= AWE_STATUS_PLL_LOL | AWE_STATUS_PLL_SYS_CAL;
+	check_los &= 0xf;
+	for (i = 0; i < timeout; i++) {
+		rc = get_status(drvdata);
+		if (rc < 0)
+			return rc;
+
+		if (!(rc & check_los))
+			break; /* alarms not set OK */
+		msleep(100);	/* wait for 100ms before polling */
+	}
+	if (i >= timeout) {
+		dev_err(&drvdata->client->dev,
+			"Timeout (%d) waiting for PLL lock, status=0x%x, mask=0x%x\n",
+			i, rc, check_los);
+		return -ETIMEDOUT;
+	}
+	dev_dbg(&drvdata->client->dev,
+		"Validated PLL locked, t=%d cycles (timeout= %d cycles), status =0x%x, mask=0x%x\n",
+		i, timeout, rc, check_los);
+
+	/* copy FCAL values to active registers */
+	rc = read_multireg64(drvdata, awe_fcal, &fcal);
+	if (rc)
+		return rc;
+
+	rc = write_multireg64(drvdata, fcal, awe_fcal_ovrd);
+	if (rc)
+		return rc;
+
+	dev_dbg(&drvdata->client->dev, "Copied FCAL data 0x%llx\n", fcal);
+	/* Set 47[7:2] to 000101b */
+	rc = write_field(drvdata, 5, AWE_REG47_72);
+	if (rc)
+		return rc;
+
+	/* SET PLL to use FCAL values, set FCAL_OVRD_EN=1 */
+	rc = write_field(drvdata, 1, AWE_FCAL_OVRD_EN);
+	if (rc)
+		return rc;
+
+	/* only needed if using down-spread. Won't hurt to do anyway */
+	rc = reset_ms(drvdata);
+	if (rc)
+		return rc;
+
+	/* Enable all (enabled individually) outputs */
+	rc = write_field(drvdata, 0, AWE_OUT_ALL_DIS);
+	if (rc)
+		return rc;
+
+	/* Clearing */
+	write_field(drvdata, 0, AWE_SOFT_RESET);
+
+	/* Power up MS if used, otherwise power down */
+	rc = power_up_down_needed_ms(drvdata);
+	if (rc)
+		return rc;
+
+	return 0;
+}
+
+static int si5338_clkout_prepare(struct clk_hw *hw)
+{
+	struct si5338_hw_data *hwdata = HWDATA(hw);
+	struct si5338_driver_data *drvdata = hwdata->drvdata;
+	int rc;
+
+	rc = set_drv_powerdown(drvdata, DRV_POWERUP, hwdata->num);
+	if (rc) {
+		dev_err(&drvdata->client->dev,
+			"Error power up clkout%d\n", hwdata->num);
+	}
+	dev_dbg(&drvdata->client->dev, "Clkout%d prepared\n", hwdata->num);
+
+	return rc;
+}
+
+static int si5338_clkout_enable(struct clk_hw *hw)
+{
+
+	struct si5338_hw_data *hwdata = HWDATA(hw);
+	struct si5338_driver_data *drvdata = hwdata->drvdata;
+	int rc;
+
+	rc = set_out_disable(drvdata, OUT_ENABLE, hwdata->num);
+	if (rc) {
+		dev_err(&drvdata->client->dev,
+			"Error enabling clkout%d\n", hwdata->num);
+	}
+	dev_dbg(&drvdata->client->dev, "Clkout%d enabled\n", hwdata->num);
+
+	return rc;
+}
+
+static void si5338_clkout_disable(struct clk_hw *hw)
+{
+	struct si5338_hw_data *hwdata = HWDATA(hw);
+	struct si5338_driver_data *drvdata = hwdata->drvdata;
+
+	set_out_disable(drvdata, OUT_DISABLE, hwdata->num);
+	dev_dbg(&drvdata->client->dev, "Clkout%d disable\n", hwdata->num);
+}
+
+static void si5338_clkout_unprepare(struct clk_hw *hw)
+{
+	struct si5338_hw_data *hwdata = HWDATA(hw);
+	struct si5338_driver_data *drvdata = hwdata->drvdata;
+
+	set_drv_powerdown(drvdata, DRV_POWERDOWN, hwdata->num);
+	dev_dbg(&drvdata->client->dev, "Clkout%d unprepared\n", hwdata->num);
+}
+
+static int si5338_clkout_reparent(struct si5338_driver_data *drvdata,
+				   int num, u8 parent)
+{
+	return set_out_mux(drvdata, num, parent);
+}
+
+static u8 si5338_clkout_get_parent(struct clk_hw *hw)
+{
+	struct si5338_hw_data *hwdata = HWDATA(hw);
+	struct si5338_driver_data *drvdata = hwdata->drvdata;
+
+	return get_out_mux(drvdata, hwdata->num);
+}
+
+static int si5338_clkout_set_parent(struct clk_hw *hw, u8 index)
+{
+	struct si5338_hw_data *hwdata = HWDATA(hw);
+	struct si5338_driver_data *drvdata = hwdata->drvdata;
+
+	return si5338_clkout_reparent(drvdata, hwdata->num, index);
+}
+
+static unsigned long si5338_clkout_recalc_rate(struct clk_hw *hw,
+					       unsigned long parent_rate)
+{
+	struct si5338_hw_data *hwdata = HWDATA(hw);
+	struct si5338_driver_data *drvdata = hwdata->drvdata;
+	unsigned long rate = parent_rate;
+	int rc;
+
+	rc = get_out_div(drvdata, hwdata->num);
+	if (rc <= 0) {
+		rate = 0;
+		dev_warn(&drvdata->client->dev,
+			"Error recalculating rate for clk%d\n", hwdata->num);
+	} else {
+		rate /= rc;
+	}
+	dev_dbg(&drvdata->client->dev, "Recalculated clkout%d rate %lu\n",
+		hwdata->num, rate);
+
+	return rate;
+}
+
+static long si5338_clkout_round_rate(struct clk_hw *hw, unsigned long rate,
+				     unsigned long *parent_rate)
+{
+	struct si5338_hw_data *hwdata = HWDATA(hw);
+	struct si5338_driver_data *drvdata = hwdata->drvdata;
+	u64 out_freq_scaled, scaled_max;
+	unsigned long err, new_rate, new_err;
+	u8 r_div = 1;
+
+	out_freq_scaled = rate;
+	/* Request frequency if multisynth master */
+	if (__clk_get_flags(hw->clk) & CLK_SET_RATE_PARENT) {
+		scaled_max = div64_u64(FVCOMAX,  MSINT_MAX);
+		while (r_div < 32 && out_freq_scaled < scaled_max) {
+			out_freq_scaled <<= 1;
+			r_div <<= 1;
+		}
+		if (out_freq_scaled < scaled_max) {
+			dev_warn(&drvdata->client->dev,
+				 "Specified output frequency is too low: %lu < %lld\n",
+				 rate, scaled_max >> 5);
+			r_div = 32;
+			*parent_rate = scaled_max;
+		} else {
+			*parent_rate = out_freq_scaled;
+		}
+	} else {
+		/* round to closest r_div */
+		new_rate = *parent_rate;
+		new_err = abs(new_rate - rate);
+		do {
+			err = new_err;
+			new_rate >>= 1;
+			r_div <<= 1;
+			new_err = abs(new_rate - rate);
+		} while (new_err < err && r_div < 32);
+		r_div >>= 1;
+	}
+	rate = *parent_rate / r_div;
+
+	dev_dbg(&drvdata->client->dev,
+		"%s - %s: r_div = %u, rate = %lu, requesting parent_rate = %lu\n",
+		__func__, __clk_get_name(hwdata->hw.clk), r_div,
+		rate, *parent_rate);
+
+	return rate;
+}
+
+static int si5338_clkout_set_rate(struct clk_hw *hw, unsigned long rate,
+				  unsigned long parent_rate)
+{
+	struct si5338_hw_data *hwdata = HWDATA(hw);
+	struct si5338_driver_data *drvdata = hwdata->drvdata;
+	unsigned long err, new_rate, new_err;
+	int r_div = 1;
+
+	/* round to closest r_div */
+	new_rate = parent_rate;
+	new_err = abs(new_rate - rate);
+	do {
+		err = new_err;
+		new_rate >>= 1;
+		r_div <<= 1;
+		new_err = abs(new_rate - rate);
+	} while (new_err < err && r_div < 32);
+	r_div >>= 1;
+
+	dev_dbg(&drvdata->client->dev,
+		"%s - %s: r_div = %u, parent_rate = %lu, rate = %lu\n",
+		__func__, __clk_get_name(hwdata->hw.clk), r_div,
+		parent_rate, rate);
+
+	return set_out_div(drvdata, r_div, hwdata->num);
+}
+
+static const struct clk_ops si5338_clkout_ops = {
+	.prepare = si5338_clkout_prepare,
+	.unprepare = si5338_clkout_unprepare,
+	.enable = si5338_clkout_enable,
+	.disable = si5338_clkout_disable,
+	.set_parent = si5338_clkout_set_parent,
+	.get_parent = si5338_clkout_get_parent,
+	.recalc_rate = si5338_clkout_recalc_rate,
+	.round_rate = si5338_clkout_round_rate,
+	.set_rate = si5338_clkout_set_rate,
+};
+
+#ifdef CONFIG_DEBUG_FS
+
+static int get_ms_powerdown(struct si5338_driver_data *drvdata, int chn)
+{
+	int rc;
+
+	rc = _verify_output_channel(chn);
+	if (rc < 0)
+		return rc;
+
+	return read_field(drvdata, awe_ms_powerdown[chn]);
+}
+
+static int get_out_disable(struct si5338_driver_data *drvdata, int chn)
+{
+	int rc;
+
+	rc = _verify_output_channel(chn);
+	if (chn != 4 && rc < 0)
+		return rc;
+
+	return read_field(drvdata, awe_out_disable[chn]);
+}
+
+static int get_drv_disabled_state(struct si5338_driver_data *drvdata, int chn)
+{
+	int rc;
+
+	rc = _verify_output_channel(chn);
+	if (rc < 0)
+		return rc;
+
+	return read_field(drvdata, awe_drv_dis_state[chn]);
+}
+
+static int get_drv_type(struct si5338_driver_data *drvdata, int chn)
+{
+	int rc;
+
+	rc = _verify_output_channel(chn);
+	if (rc < 0)
+		return rc;
+
+	return read_field(drvdata, awe_drv_fmt[chn]);
+}
+
+static int get_drv_vdd(struct si5338_driver_data *drvdata, int chn)
+{
+	int rc;
+
+	rc = _verify_output_channel(chn);
+	if (rc < 0)
+		return rc;
+
+	return read_field(drvdata, awe_drv_vddo[chn]);
+}
+
+static int get_drv_trim(struct si5338_driver_data *drvdata, int chn)
+{
+	int rc;
+	u64 data;
+
+	rc = _verify_output_channel(chn);
+	if (rc < 0)
+		return rc;
+
+	rc = read_multireg64(drvdata, awe_drv_trim[chn], &data);
+	if (rc < 0)
+		return rc;
+
+	return data;	/* 5-bit data */
+}
+
+static int get_drv_invert(struct si5338_driver_data *drvdata, int chn)
+{
+	int rc;
+
+	rc = _verify_output_channel(chn);
+	if (rc < 0)
+		return rc;
+
+	return read_field(drvdata, awe_drv_invert[chn]);
+}
+
+static int get_drv_powerdown(struct si5338_driver_data *drvdata, int chn)
+{
+	int rc;
+
+	rc = _verify_output_channel(chn);
+	if (rc < 0)
+		return rc;
+
+	return read_field(drvdata, awe_drv_powerdown[chn]);
+}
+
+/*
+ * Create debugfs files for status for each si5338 clkout
+ */
+
+static int clkout_status_show(struct seq_file *s, void *data)
+{
+	struct si5338_hw_data *clkout = s->private;
+	struct si5338_driver_data *drvdata = clkout->drvdata;
+	struct si5338_drv_t const *config;
+	int i, j, match = 0;
+	int drv_type, drv_vdd, drv_trim, drv_invert;
+	int out_src, src_group = 0, src = 0;
+	const int in_numbers[] = {
+		12, 3, 4, 56
+	};
+
+	i = clkout->num;
+	seq_printf(s, "%d: ", i);
+	if (get_out_disable(drvdata, i)) {
+		seq_puts(s, "disabled");
+		switch (get_drv_disabled_state(drvdata, i)) {
+		case SI5338_OUT_DIS_HIZ:
+			seq_puts(s, " (high-Z)\n");
+			break;
+		case SI5338_OUT_DIS_LOW:
+			seq_puts(s, " (low)\n");
+			break;
+		case SI5338_OUT_DIS_HI:
+			seq_puts(s, " (high)\n");
+			break;
+		case SI5338_OUT_DIS_ALWAYS_ON:
+			seq_puts(s, " (always on)\n");
+			break;
+		}
+		return 0;
+	}
+
+	seq_puts(s, "enabled ");
+	drv_type = get_drv_type(drvdata, i);
+	if (drv_type < 0)
+		return drv_type;
+
+	drv_vdd =  get_drv_vdd(drvdata, i);
+	if (drv_vdd < 0)
+		return drv_vdd;
+
+	drv_trim = get_drv_trim(drvdata, i);
+	if (drv_trim < 0)
+		return drv_trim;
+
+	drv_invert = get_drv_invert(drvdata, i);
+	if (drv_invert < 0)
+		return drv_invert;
+
+	for (j = 0; drv_configs[j].description; j++) {
+		config = &drv_configs[j];
+		if (config->fmt != drv_type)
+			continue;
+		if (config->vdd != drv_vdd)
+			continue;
+		if (config->trim != drv_trim)
+			continue;
+		if (((config->invert >> 2) | drv_invert) !=
+		    ((config->invert >> 2) | (config->invert & 3)))
+			continue;
+
+		seq_puts(s, drv_configs[j].description);
+		match = 1;
+		break;
+	}
+
+	if (!match) {
+		seq_printf(s, "Invalid output configuration: type = %d, vdd=%d, trim=%d, invert=%d\n",
+			   drv_type, drv_vdd, drv_trim, drv_invert);
+	}
+
+	seq_printf(s, ", R%d and out %d power %s", i, i,
+		  get_drv_powerdown(drvdata, i) ? "down" : "up");
+	seq_puts(s, ", Output route ");
+
+	out_src = get_out_mux(drvdata, i);
+	if (out_src < 0)
+		return out_src;
+
+	switch (out_src) {
+	case 0: /* p2div in */
+	case 2: /* p2div out */
+		src = read_field(drvdata, AWE_FB_MUX);
+		if (src < 0)
+			return src;
+
+		src_group = 0;
+		src = src ? 2 : 3; /* mod src: 0 - IN56, 1 - IN4 */
+		break;
+	case 1: /* p1div in */
+	case 3: /* p1div out */
+		src = read_field(drvdata, AWE_IN_MUX);
+		if (src < 0)
+			return src;
+
+		if (src == 2) {
+			src_group = 1;
+			src = 0;
+		} else {
+			src_group = 0; /* keep src: 0 - IN12, 1 - IN3 */
+		}
+		break;
+	case 4:
+		src_group = 1;
+		break;
+	case 5:
+		src_group = 2;
+		src = 0;
+		break;
+	case 6:
+		src_group = 2;
+		src = i;
+		break;
+	case 7:
+		src_group = 3;
+		break;
+	}
+	switch (src_group) {
+	case 0:
+		seq_printf(s, "IN%d", in_numbers[src]);
+		break;
+	case 1:
+		seq_puts(s, "XO");
+		break;
+	case 2:
+		seq_printf(s, "MS%d", src);
+		break;
+	case 3:
+		seq_puts(s, "No clock");
+		break;
+	}
+
+	if (out_src == 5 || out_src == 6) {
+		seq_printf(s, " power %s",
+			   get_ms_powerdown(drvdata, i) ? "down" : "up");
+	}
+
+	seq_puts(s, "\n");
+
+	return 0;
+}
+
+static int clkout_status_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, clkout_status_show, inode->i_private);
+}
+
+static const struct file_operations clkout_status_fops = {
+	.open		= clkout_status_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static int register_debugfs_status(struct si5338_hw_data *clkout)
+{
+	struct dentry *d;
+
+	d = clk_debugfs_add_file(&clkout->hw, "output_status", S_IRUGO,
+				clkout, &clkout_status_fops);
+	if (!d)
+		return -ENOMEM;
+
+	return 0;
+}
+
+#else
+static int register_debugfs_status(struct si5338_hw_data *clkout)
+{
+	return 0;
+}
+#endif /* CONFIG_DEBUG_FS */
+
+/*
+ * Si5351 i2c probe and device tree parsing
+ */
+#ifdef CONFIG_OF
+static const struct of_device_id si5338_dt_ids[] = {
+	{ .compatible = "silabs,si5338" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, si5338_dt_ids);
+
+static int si5338_dt_parse(struct i2c_client *client)
+{
+	struct device_node *child, *np = client->dev.of_node;
+	struct si5338_platform_data *pdata;
+	u32 val, num;
+
+	if (np == NULL)
+		return 0;
+
+	pdata = devm_kzalloc(&client->dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		return -ENOMEM;
+
+	/* property silabs,name-prefix */
+	of_property_read_string(np, "silabs,name-prefix", &pdata->name_prefix);
+
+	/* property silabs,ref-source */
+	if (!of_property_read_u32(np, "silabs,ref-source", &val)) {
+		switch (val) {
+		case SI5338_REF_SRC_CLKIN12:
+		case SI5338_REF_SRC_CLKIN3:
+		case SI5338_REF_SRC_XTAL:
+			pdata->ref_src = val;
+			dev_dbg(&client->dev, "ref-source = %d\n", val);
+			break;
+		default:
+			dev_err(&client->dev,
+				"Invalid source for refclk %u\n", val);
+			return -EINVAL;
+		}
+	}
+
+	/* property silabs,fb-source */
+	if (!of_property_read_u32(np, "silabs,fb-source", &val)) {
+		switch (val) {
+		case SI5338_FB_SRC_CLKIN4:
+		case SI5338_FB_SRC_CLKIN56:
+		case SI5338_FB_SRC_NOCLK:
+			pdata->fb_src = val;
+			dev_dbg(&client->dev, "fb-source = %d\n", val);
+			break;
+		default:
+			dev_err(&client->dev,
+				"Invalid source for fbclk %u\n", val);
+			return -EINVAL;
+		}
+	}
+
+	/* property silabs,pll-source */
+	if (!of_property_read_u32(np, "silabs,pll-source", &val)) {
+		switch (val) {
+		case SI5338_PFD_IN_REF_REFCLK:
+		case SI5338_PFD_IN_REF_FBCLK:
+		case SI5338_PFD_IN_REF_DIVREFCLK:
+		case SI5338_PFD_IN_REF_DIVFBCLK:
+		case SI5338_PFD_IN_REF_XOCLK:
+		case SI5338_PFD_IN_REF_NOCLK:
+			pdata->pll_src = val;
+			dev_dbg(&client->dev, "pll-source = %d\n", val);
+			break;
+		default:
+			dev_err(&client->dev,
+				"Invalid source for pll %u\n", val);
+			return -EINVAL;
+		}
+	}
+
+	/* property silabs,pll-vco */
+	if (!of_property_read_u32(np, "silabs,pll-vco", &val)) {
+		if (val < FVCOMIN || val > FVCOMAX) {
+			dev_err(&client->dev,
+				"pll-vco out of range [%lldu..%lldu]\n",
+				FVCOMIN, FVCOMAX);
+			return -EINVAL;
+		}
+		pdata->pll_vco = val;
+		dev_dbg(&client->dev, "pll-vco = %u M\n", val/1000000);
+	}
+
+	if (!of_property_read_u32(np, "silabs,pll-master", &val)) {
+		if (val > 3) {
+			dev_err(&client->dev,
+				"Invalid pll-master %u\n", val);
+			return -EINVAL;
+		}
+		pdata->pll_master = val;
+		dev_dbg(&client->dev, "pll-master = %d\n", val);
+	}
+
+	/* per clock out */
+	for_each_child_of_node(np, child) {
+		if (of_property_read_u32(child, "reg", &num)) {
+			dev_err(&client->dev, "Missing reg property of %s\n",
+				child->name);
+			return -EINVAL;
+		}
+		if (num > 4) {
+			dev_err(&client->dev, "Invalid clkout %u\n", num);
+			return -EINVAL;
+		}
+
+		of_property_read_string(child, "name",
+					&pdata->clkout[num].name);
+
+		if (!of_property_read_u32(child, "silabs,clock-source", &val)) {
+			switch (val) {
+			case SI5338_OUT_MUX_FBCLK:
+			case SI5338_OUT_MUX_REFCLK:
+			case SI5338_OUT_MUX_DIVFBCLK:
+			case SI5338_OUT_MUX_DIVREFCLK:
+			case SI5338_OUT_MUX_XOCLK:
+			case SI5338_OUT_MUX_MS0:
+			case SI5338_OUT_MUX_MSN:
+			case SI5338_OUT_MUX_NOCLK:
+				pdata->clkout[num].clkout_src = val;
+				dev_dbg(&client->dev, "clkout_src = %d\n", val);
+				break;
+			default:
+				dev_err(&client->dev,
+					"Invalid source for output %u\n", num);
+				return -EINVAL;
+			}
+		}
+		if (!of_property_read_string(child, "silabs,drive-config",
+					     &pdata->clkout[num].drive)) {
+			if (find_drive_config(pdata->clkout[num].drive) < 0) {
+				dev_err(&client->dev,
+					"Invalid drive config for output %u\n",
+					num);
+				return -EINVAL;
+			}
+			dev_dbg(&client->dev, "drive-config = %s\n",
+				pdata->clkout[num].drive);
+		}
+		if (!of_property_read_u32(child,
+					  "silabs,disable-state",
+					  &val)) {
+			switch (val) {
+			case SI5338_OUT_DIS_HIZ:
+			case SI5338_OUT_DIS_LOW:
+			case SI5338_OUT_DIS_HI:
+			case SI5338_OUT_DIS_ALWAYS_ON:
+				pdata->clkout[num].disable_state = val;
+				dev_dbg(&client->dev,
+					"disable-state = %d\n", val);
+				break;
+			default:
+				dev_err(&client->dev,
+					"Invalid disable state for output %u\n",
+					num);
+				return -EINVAL;
+			}
+		}
+		if (!of_property_read_u32(child, "clock-frequency", &val)) {
+			pdata->clkout[num].rate = val;
+			dev_dbg(&client->dev, "clock-frequency = %u M\n", val/1000000);
+		}
+		if (of_find_property(child, "enabled", NULL))
+			pdata->clkout[num].enabled = true;
+	}
+	/* Replace platform data with device tree */
+	client->dev.platform_data = pdata;
+
+	return 0;
+}
+#else
+static int si5338_dt_parse(struct i2c_client *client)
+{
+	return 0;
+}
+#endif /* CONFIG_OF */
+
+/*
+ * Returns the clk registered, or an error code. If successful, the clk pointer
+ * is also save in hw->clk.
+ */
+static struct clk *si5338_register_clock(struct device *dev,
+			      struct clk_hw *hw,
+			      const char *name,
+			      const char **parent_names,
+			      u8 num_parents,
+			      const struct clk_ops *ops,
+			      unsigned long flags)
+{
+	struct clk *clk;
+	struct clk_init_data init;
+
+	memset(&init, 0, sizeof(init));
+	init.name = name;
+	init.ops = ops;
+	init.flags = flags;
+	init.parent_names = parent_names;
+	init.num_parents = num_parents;
+	hw->init = &init;
+	dev_dbg(dev, "Registering %s\n", name);
+	clk = devm_clk_register(dev, hw);
+
+	if (IS_ERR(clk))
+		dev_err(dev, "unable to register %s\n", name);
+
+	return clk;
+}
+
+#define STRNCAT_LENGTH (MAX_NAME_LENGTH - name_prefix_length)
+static int si5338_i2c_probe(struct i2c_client *client,
+			    const struct i2c_device_id *id)
+{
+	struct si5338_platform_data *pdata;
+	struct si5338_driver_data *drvdata;
+	struct clk *clk = NULL;
+	char name_buf[8][MAX_NAME_LENGTH];
+	char register_name[MAX_NAME_LENGTH];
+	const char *pclkin[4] = {"in12", "in3", "in4", "in56"};
+	const char *parent_names[8] = {
+		name_buf[0], name_buf[1], name_buf[2], name_buf[3],
+		name_buf[4], name_buf[5], name_buf[6], name_buf[7]
+	};
+	int ret, n, name_prefix_length;
+	bool require_xtal = false;
+	bool require_ref = false;
+	bool require_fb = false;
+	bool require_pll = false;
+	unsigned long flags;
+
+    dev_info(&client->dev, "%s: enter\n", __func__);
+
+	ret = si5338_dt_parse(client);
+	if (ret)
+		return ret;
+
+	pdata = client->dev.platform_data;
+	if (!pdata)
+		return -EINVAL;
+
+	drvdata = devm_kzalloc(&client->dev, sizeof(*drvdata), GFP_KERNEL);
+	if (drvdata == NULL)
+		return -ENOMEM;
+
+	i2c_set_clientdata(client, drvdata);
+	drvdata->client = client;
+	if (!pdata->name_prefix) {
+		strlcpy(drvdata->name_prefix,
+			dev_name(&client->dev), MAX_NAME_PREFIX - 2);
+		strncat(drvdata->name_prefix, "-", 1);
+	} else {
+		strlcpy(drvdata->name_prefix,
+			pdata->name_prefix, MAX_NAME_PREFIX);
+	}
+	name_prefix_length = strlen(drvdata->name_prefix);
+
+	/* Check if clkout config is valid */
+	for (n = 0; n < 4; n++) {
+		/* check clkout source config */
+		switch (pdata->clkout[n].clkout_src) {
+		case SI5338_OUT_MUX_NOCLK:
+			if (pdata->clkout[n].rate)
+				pdata->clkout[n].rate = 0;
+			break;
+		case SI5338_OUT_MUX_REFCLK:
+		case SI5338_OUT_MUX_DIVREFCLK:
+			require_ref = true;
+			break;
+		case SI5338_OUT_MUX_FBCLK:
+		case SI5338_OUT_MUX_DIVFBCLK:
+			require_fb = true;
+			break;
+		case SI5338_OUT_MUX_XOCLK:
+			require_xtal = true;
+			break;
+		case SI5338_OUT_MUX_MS0:
+		case SI5338_OUT_MUX_MSN:
+			require_pll = true;
+			break;
+		default:
+			dev_err(&client->dev, "Invalid clkout source\n");
+			return -EINVAL;
+		}
+
+		/* check clkout drive config */
+		if (find_drive_config(pdata->clkout[n].drive) < 0) {
+			dev_err(&client->dev,
+				"Invalid drive config for output %u\n", n);
+			return -EINVAL;
+		}
+
+		/* check clkout disable state config */
+		switch (pdata->clkout[n].disable_state) {
+		case SI5338_OUT_DIS_HIZ:
+		case SI5338_OUT_DIS_LOW:
+		case SI5338_OUT_DIS_HI:
+		case SI5338_OUT_DIS_ALWAYS_ON:
+			break;
+		default:
+			dev_err(&client->dev,
+				"Invalid disable state for output %u\n", n);
+			return -EINVAL;
+		}
+
+	}
+	/* check pll source */
+	if (require_pll) {
+		switch (pdata->pll_src) {
+		case SI5338_PFD_IN_REF_XOCLK:
+			require_xtal = true;
+			break;
+		case SI5338_PFD_IN_REF_REFCLK:
+		case SI5338_PFD_IN_REF_DIVREFCLK:
+			require_ref = true;
+			break;
+		case SI5338_PFD_IN_REF_FBCLK:
+		case SI5338_PFD_IN_REF_DIVFBCLK:
+			require_fb = true;
+			break;
+		case SI5338_PFD_IN_REF_NOCLK:
+		default:
+			dev_err(&client->dev, "Invalid pll source\n");
+			return -EINVAL;
+		}
+	}
+	/* check refclk source */
+	if (require_ref) {
+		switch (pdata->ref_src) {
+		case SI5338_REF_SRC_CLKIN12:
+			if (require_xtal) {
+				dev_err(&client->dev,
+					"Error in configuration: IN1/IN2 and XTAL are mutually exclusive\n");
+				return -EINVAL;
+			}
+			drvdata->pclkin[0] = devm_clk_get(&client->dev,
+							  pclkin[0]);
+			if (PTR_ERR(drvdata->pclkin[0]) == -EPROBE_DEFER)
+				return -EPROBE_DEFER;
+			if (IS_ERR_OR_NULL(drvdata->pclkin[0])) {
+				dev_err(&client->dev,
+					"IN1/IN2 doesn't a have source\n");
+				return -EINVAL;
+			}
+			break;
+		case SI5338_REF_SRC_CLKIN3:
+			drvdata->pclkin[1] = devm_clk_get(&client->dev,
+							  pclkin[1]);
+			if (PTR_ERR(drvdata->pclkin[1]) == -EPROBE_DEFER)
+				return -EPROBE_DEFER;
+			if (IS_ERR_OR_NULL(drvdata->pclkin[1])) {
+				dev_err(&client->dev,
+					"IN3 doesn't have a source\n");
+				return -EINVAL;
+			}
+			break;
+		default:
+			dev_err(&client->dev,
+				"Invalid source for refclk\n"\
+				"Notice: SI5338_REF_SRC_XTAL means SI5338_PFD_IN_REF_XOCLK as well\n");
+			return -EINVAL;
+		}
+	}
+	/* check fbclk source */
+	if (require_fb) {
+		switch (pdata->fb_src) {
+		case SI5338_FB_SRC_CLKIN4:
+			drvdata->pclkin[2] = devm_clk_get(&client->dev,
+							  pclkin[2]);
+			if (PTR_ERR(drvdata->pclkin[2]) == -EPROBE_DEFER)
+				return -EPROBE_DEFER;
+			if (IS_ERR_OR_NULL(drvdata->pclkin[2])) {
+				dev_err(&client->dev,
+					"IN4 doesn't have a source\n");
+				return -EINVAL;
+			}
+			break;
+		case SI5338_FB_SRC_CLKIN56:
+			drvdata->pclkin[3] = devm_clk_get(&client->dev,
+							  pclkin[3]);
+			if (PTR_ERR(drvdata->pclkin[3]) == -EPROBE_DEFER)
+				return -EPROBE_DEFER;
+			if (IS_ERR_OR_NULL(drvdata->pclkin[3])) {
+				dev_err(&client->dev,
+					"IN5/IN6 doesn't have a source\n");
+				return -EINVAL;
+			}
+			break;
+		case SI5338_FB_SRC_NOCLK:
+		default:
+			dev_err(&client->dev,
+				"Invalid source for fbclk\n");
+			return -EINVAL;
+		}
+	}
+	/* check xtal */
+	if (require_xtal) {
+		drvdata->pxtal = devm_clk_get(&client->dev, "xtal");
+		if (PTR_ERR(drvdata->pxtal) == -EPROBE_DEFER)
+			return -EPROBE_DEFER;
+		if (IS_ERR_OR_NULL(drvdata->pxtal)) {
+			dev_err(&client->dev,
+				"XTAL doesn't have a source\n");
+			return -EINVAL;
+		}
+	}
+
+	/* Register regmap */
+	drvdata->regmap = devm_regmap_init_i2c(client, &si5338_regmap_config);
+	if (IS_ERR(drvdata->regmap)) {
+		dev_err(&client->dev, "failed to allocate register map\n");
+		return PTR_ERR(drvdata->regmap);
+	}
+
+	ret = regmap_read(drvdata->regmap, REG5338_DEV_CONFIG2, &n);
+	if (ret) {
+		dev_err(&client->dev, "Failed to access regmap\n");
+		return ret;
+	}
+
+	/* Check if si5338 exists */
+	if ((n & REG5338_DEV_CONFIG2_MASK) != REG5338_DEV_CONFIG2_VAL) {
+		dev_err(&client->dev,
+			"Chip returned unexpected value from reg 0x%x: 0x%x, expected 0x%x. It is not %s\n",
+			REG5338_DEV_CONFIG2, n, REG5338_DEV_CONFIG2_VAL,
+			id->name);
+		return -ENODEV;
+	}
+
+	dev_dbg(&client->dev, "Chip %s is found\n", id->name);
+
+	ret = pre_init(drvdata);		/* Disable all */
+	if (ret)
+		return ret;
+
+	/*
+	 * Set up clock structure
+	 * These clocks have fixed parent
+	 *	xtal => xoclk
+	 *	refclk => divrefclk
+	 *	fbclk => divfbclk
+	 *	pll => multisynth
+	 */
+
+	/* setup refclk parent */
+	ret = si5338_refclk_reparent(drvdata, pdata->ref_src);
+	if (ret) {
+		dev_err(&client->dev,
+			"failed to reparent refclk to %d\n", pdata->ref_src);
+		return ret;
+	}
+
+	/* setup fbclk parent */
+	ret = si5338_fbclk_reparent(drvdata, pdata->fb_src);
+	if (ret) {
+		dev_err(&client->dev,
+			"failed to reparent fbclk to %d\n", pdata->fb_src);
+		return ret;
+	}
+
+	/* setup pll parent */
+	ret = si5338_pll_reparent(drvdata, pdata->pll_src);
+	if (ret) {
+		dev_err(&client->dev,
+			"failed to reparent pll %d to %d\n",
+			n, pdata->pll_src);
+		return ret;
+	}
+
+	for (n = 0; n < 4; n++) {
+		ret = si5338_clkout_reparent(drvdata, n,
+					      pdata->clkout[n].clkout_src);
+		if (ret) {
+			dev_err(&client->dev,
+				"failed to reparent clkout %d to %d\n",
+				n, pdata->clkout[n].clkout_src);
+			return ret;
+		}
+
+		ret = si5338_clkout_set_drive_config(drvdata, n,
+					      pdata->clkout[n].drive);
+		if (ret) {
+			dev_err(&client->dev,
+				"failed set drive config of clkout%d to %s\n",
+				n, pdata->clkout[n].drive);
+			return ret;
+		}
+
+		ret = si5338_clkout_set_disable_state(drvdata, n,
+						pdata->clkout[n].disable_state);
+		if (ret) {
+			dev_err(&client->dev,
+				"failed set disable state of clkout%d to %d\n",
+				n, pdata->clkout[n].disable_state);
+			return ret;
+		}
+	}
+
+	/*
+	 * To form clock names, concatentate name prefix with each name.
+	 * The result string is up to MAX_NAME_LENGTH including termination.
+	 */
+
+	/* Register xtal input clock */
+	if (!IS_ERR_OR_NULL(drvdata->pxtal)) {
+		strlcpy(register_name, drvdata->name_prefix, MAX_NAME_PREFIX);
+		strncat(register_name, si5338_input_names[4], STRNCAT_LENGTH);
+		drvdata->pxtal_name = __clk_get_name(drvdata->pxtal);
+		clk = si5338_register_clock(&client->dev, &drvdata->xtal,
+					 register_name, &drvdata->pxtal_name, 1,
+					 &si5338_xtal_ops, 0);
+		if (IS_ERR(clk))
+			return PTR_ERR(clk);
+	}
+
+	/* Register clkin input clock */
+	for (n = 0; n < 4; n++) {
+		if (IS_ERR_OR_NULL(drvdata->pclkin[n]))
+			continue;
+
+		drvdata->clkin[n].drvdata = drvdata;
+		drvdata->clkin[n].num = n;
+		strlcpy(register_name, drvdata->name_prefix, MAX_NAME_PREFIX);
+		strncat(register_name, si5338_input_names[n], STRNCAT_LENGTH);
+		drvdata->pclkin_name[n] = __clk_get_name(drvdata->pclkin[n]);
+
+		clk = si5338_register_clock(&client->dev,
+					    &drvdata->clkin[n].hw,
+					    register_name,
+					    &drvdata->pclkin_name[n],
+					    1,
+					    &si5338_clkin_ops,
+					    0);
+		if (IS_ERR(clk))
+			return PTR_ERR(clk);
+	}
+
+	/*
+	 * Create unique internal names in case multiple devices exist
+	 *
+	 * Register refclk, parents can be in1/in2, in3, xtal, noclk
+	 */
+	drvdata->refclk.drvdata = drvdata;
+	strlcpy(name_buf[0], drvdata->name_prefix, MAX_NAME_PREFIX);
+	strlcpy(name_buf[1], drvdata->name_prefix, MAX_NAME_PREFIX);
+	strlcpy(name_buf[2], drvdata->name_prefix, MAX_NAME_PREFIX);
+	strlcpy(name_buf[3], drvdata->name_prefix, MAX_NAME_PREFIX);
+	strncat(name_buf[0], si5338_input_names[0], STRNCAT_LENGTH);
+	strncat(name_buf[1], si5338_input_names[1], STRNCAT_LENGTH);
+	strncat(name_buf[2], si5338_input_names[4], STRNCAT_LENGTH);
+	strncat(name_buf[3], si5338_input_names[5], STRNCAT_LENGTH);
+	strlcpy(register_name, drvdata->name_prefix, MAX_NAME_PREFIX);
+	strncat(register_name, si5338_pll_src_names[0], STRNCAT_LENGTH);
+
+	clk = si5338_register_clock(&client->dev, &drvdata->refclk.hw,
+				 register_name, parent_names, 4,
+				 &si5338_refclk_ops, 0);
+	if (IS_ERR(clk))
+		return PTR_ERR(clk);
+
+	/* Register divrefclk, parent is refclk */
+	strlcpy(name_buf[0], drvdata->name_prefix, MAX_NAME_PREFIX);
+	strncat(name_buf[0], si5338_pll_src_names[0], STRNCAT_LENGTH);
+	strlcpy(register_name, drvdata->name_prefix, MAX_NAME_PREFIX);
+	strncat(register_name, si5338_pll_src_names[2], STRNCAT_LENGTH);
+
+	clk = si5338_register_clock(&client->dev, &drvdata->divrefclk,
+				 register_name, parent_names, 1,
+				 &si5338_divrefclk_ops, 0);
+	if (IS_ERR(clk))
+		return PTR_ERR(clk);
+
+	/* Register fbclk, parents can be in4, in5/in6, noclk */
+	drvdata->fbclk.drvdata = drvdata;
+	strlcpy(name_buf[0], drvdata->name_prefix, MAX_NAME_PREFIX);
+	strlcpy(name_buf[1], drvdata->name_prefix, MAX_NAME_PREFIX);
+	strlcpy(name_buf[2], drvdata->name_prefix, MAX_NAME_PREFIX);
+	strncat(name_buf[0], si5338_input_names[2], STRNCAT_LENGTH);
+	strncat(name_buf[1], si5338_input_names[3], STRNCAT_LENGTH);
+	strncat(name_buf[2], si5338_input_names[5], STRNCAT_LENGTH);
+	strlcpy(register_name, drvdata->name_prefix, MAX_NAME_PREFIX);
+	strncat(register_name, si5338_pll_src_names[1], STRNCAT_LENGTH);
+
+	clk = si5338_register_clock(&client->dev, &drvdata->fbclk.hw,
+				 register_name, parent_names, 3,
+				 &si5338_fbclk_ops, 0);
+	if (IS_ERR(clk))
+		return PTR_ERR(clk);
+
+	/* Register divfbclk, parent is fbclk */
+	strlcpy(name_buf[0], drvdata->name_prefix, MAX_NAME_PREFIX);
+	strncat(name_buf[0], si5338_pll_src_names[1], STRNCAT_LENGTH);
+	strlcpy(register_name, drvdata->name_prefix, MAX_NAME_PREFIX);
+	strncat(register_name, si5338_pll_src_names[3], STRNCAT_LENGTH);
+
+	clk = si5338_register_clock(&client->dev, &drvdata->divfbclk,
+				 register_name, parent_names, 1,
+				 &si5338_divfbclk_ops, 0);
+	if (IS_ERR(clk))
+		return PTR_ERR(clk);
+
+	/* register PLL */
+	drvdata->pll.drvdata = drvdata;
+	for (n = 0; n < ARRAY_SIZE(si5338_pll_src_names); n++) {
+		strlcpy(name_buf[n], drvdata->name_prefix, MAX_NAME_PREFIX);
+		strncat(name_buf[n], si5338_pll_src_names[n], STRNCAT_LENGTH);
+	}
+	strlcpy(register_name, drvdata->name_prefix, MAX_NAME_PREFIX);
+	strncat(register_name, si5338_msynth_src_names[0], STRNCAT_LENGTH);
+	clk = si5338_register_clock(&client->dev, &drvdata->pll.hw,
+				 register_name, parent_names, 5,
+				 &si5338_pll_ops, 0);
+	if (IS_ERR(clk))
+		return PTR_ERR(clk);
+
+	/* If pll_vco is specified, always use it to set pll clock */
+	if (require_pll && pdata->pll_vco) {
+		if (pdata->pll_vco > FVCOMIN && pdata->pll_vco < FVCOMAX) {
+			dev_dbg(&client->dev, "Setting pll vco rate to %u\n",
+				pdata->pll_vco);
+			ret = clk_set_rate(clk, pdata->pll_vco);
+			if (ret) {
+				dev_err(&client->dev, "Cannot set pll vco rate : %d\n",
+					ret);
+				return ret;
+			}
+		} else {
+			pdata->pll_vco = 0;
+		}
+	}
+
+	/* register clk multisync and clk out divider */
+	drvdata->msynth = devm_kzalloc(&client->dev, 4 *
+				       sizeof(*drvdata->msynth), GFP_KERNEL);
+	if (!drvdata->msynth)
+		return -ENOMEM;
+
+	drvdata->clkout = devm_kzalloc(&client->dev, 4 *
+				       sizeof(*drvdata->clkout), GFP_KERNEL);
+	if (!drvdata->clkout)
+		return -ENOMEM;
+
+	drvdata->onecell.clk_num = 4;
+	drvdata->onecell.clks = devm_kzalloc(&client->dev,
+		4 * sizeof(*drvdata->onecell.clks), GFP_KERNEL);
+
+	if (!drvdata->onecell.clks)
+		return -ENOMEM;
+
+	for (n = 0; n < 4; n++) {
+		drvdata->msynth[n].num = n;
+		drvdata->msynth[n].drvdata = drvdata;
+		strlcpy(name_buf[0], drvdata->name_prefix, MAX_NAME_PREFIX);
+		strncat(name_buf[0], si5338_msynth_src_names[0],
+			STRNCAT_LENGTH);
+		strlcpy(register_name, drvdata->name_prefix, MAX_NAME_PREFIX);
+		strncat(register_name, si5338_msynth_names[n], STRNCAT_LENGTH);
+		flags = (!pdata->pll_vco && n == pdata->pll_master) ?
+			CLK_SET_RATE_PARENT : 0;
+
+		clk = si5338_register_clock(&client->dev,
+					    &drvdata->msynth[n].hw,
+					    register_name,
+					    parent_names,
+					    1,
+					    &si5338_msynth_ops,
+					    flags);
+		if (IS_ERR(clk))
+			return PTR_ERR(clk);
+
+	}
+
+	/*
+	 * ms0 is available for all clkout
+	 * ms0/ms1/ms2/ms3 is available for each clkout respectivelly
+	 */
+	for (n = 0; n < 8; n++) {
+		strlcpy(name_buf[n], drvdata->name_prefix, MAX_NAME_PREFIX);
+		strncat(name_buf[n], si5338_clkout_src_names[n],
+			STRNCAT_LENGTH);
+	}
+
+	for (n = 0; n < 4; n++) {
+		drvdata->clkout[n].num = n;
+		drvdata->clkout[n].drvdata = drvdata;
+		/*
+		 * Update source
+		 * ms0 for clkout0
+		 * ms1 for clkout1
+		 * ms2 for clkout2
+		 * ms3 for clkout3
+		 */
+		strlcpy(name_buf[6], drvdata->name_prefix, MAX_NAME_PREFIX);
+		strncat(name_buf[6], si5338_msynth_names[n], STRNCAT_LENGTH);
+		/*
+		 * Use clkout_name from device tree or platform data ignoring
+		 * name_prefix. The clkout_name must be unique for each clock.
+		 */
+		if (pdata->clkout[n].name) {
+			if (strlen(pdata->clkout[n].name) >= MAX_NAME_LENGTH) {
+				dev_warn(&client->dev,
+					 "clkout[%d] name %s too long\n",
+					 n, pdata->clkout[n].name);
+			}
+			strlcpy(register_name, pdata->clkout[n].name,
+				MAX_NAME_LENGTH);
+		} else {
+			strlcpy(register_name, drvdata->name_prefix,
+				MAX_NAME_PREFIX);
+			strncat(register_name, si5338_clkout_names[n],
+				STRNCAT_LENGTH);
+		}
+
+		clk = si5338_register_clock(&client->dev,
+					    &drvdata->clkout[n].hw,
+					    register_name,
+					    parent_names,
+					    8,
+					    &si5338_clkout_ops,
+					    CLK_SET_RATE_PARENT);
+		if (IS_ERR(clk))
+			return PTR_ERR(clk);
+
+		if (register_debugfs_status(&drvdata->clkout[n])) {
+			dev_warn(&client->dev,
+				 "Failed to register clkout status in debugfs\n");
+		}
+
+		drvdata->onecell.clks[n] = clk;
+
+		/* set initial clkout rate */
+		if (pdata->clkout[n].rate) {
+			dev_dbg(&client->dev, "Setting clkout%d rate to %lu\n",
+				n, pdata->clkout[n].rate);
+			ret = clk_set_rate(clk, pdata->clkout[n].rate);
+			if (ret) {
+				dev_err(&client->dev,
+					"Cannot set rate for clkout%d: %d\n",
+					n, ret);
+				return ret;
+			}
+			/* clocks need to be prepared before post init */
+			ret = clk_prepare(clk);
+			if (ret) {
+				dev_err(&client->dev,
+					"Cannot prepare clk%d\n", n);
+				return ret;
+			}
+		}
+	}
+
+	/*
+	 * Important: Go through the procedure to check PLL locking
+	 * and other steps required by si5338 reference manual.
+	 */
+	ret = post_init(drvdata);
+	if (ret)
+		return ret;
+
+	for (n = 0; n < 4; n++) {
+		if (pdata->clkout[n].rate) {
+			if (pdata->clkout[n].enabled) {
+				ret = clk_enable(drvdata->onecell.clks[n]);
+				if (ret)
+					return ret;
+			} else {
+				clk_unprepare(drvdata->onecell.clks[n]);
+			}
+		}
+	}
+
+	dev_dbg(&client->dev, "%s clocks are registered\n", id->name);
+
+#ifdef CONFIG_OF
+	ret = of_clk_add_provider(client->dev.of_node,
+				  of_clk_src_onecell_get,
+				  &drvdata->onecell);
+	if (ret) {
+		dev_err(&client->dev, "unable to add clk provider\n");
+		return ret;
+	}
+#endif
+	for (n = 0; n < 4; n++) {
+		clk = drvdata->clkout[n].hw.clk;
+		drvdata->lookup[n] = clkdev_alloc(clk,
+						  __clk_get_name(clk),
+						  NULL);
+		if (!drvdata->lookup[n]) {
+			dev_warn(&client->dev,
+				"Unable to add clkout%d to clkdev\n", n);
+			continue;
+		}
+		if (strlen(drvdata->lookup[n]->con_id) !=
+					strlen(__clk_get_name(clk))) {
+			dev_warn(&client->dev,
+				 "Warning: clkdev doesn't support name longer than %zu\n",
+				 strlen(drvdata->lookup[n]->con_id));
+		}
+		clkdev_add(drvdata->lookup[n]);
+	}
+
+    dev_info(&client->dev, "%s: succeed\n", __func__);
+	return 0;
+}
+
+static int si5338_i2c_remove(struct i2c_client *client)
+{
+	struct si5338_driver_data *drvdata = i2c_get_clientdata(client);
+	int n;
+
+#ifdef CONFIG_OF
+	of_clk_del_provider(client->dev.of_node);
+#endif
+
+	for (n = 0; n < 4; n++) {
+		if (drvdata->lookup[n])
+			clkdev_drop(drvdata->lookup[n]);
+	}
+
+	dev_dbg(&client->dev, "Removed\n");
+
+	return 0;
+}
+
+
+static const struct i2c_device_id si5338_i2c_ids[] = {
+	{ "si5338", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, si5338_i2c_ids);
+
+static struct i2c_driver si5338_driver = {
+	.driver = {
+		.name = "si5338",
+#ifdef CONFIG_OF
+		.of_match_table = of_match_ptr(si5338_dt_ids),
+#endif
+	},
+	.probe = si5338_i2c_probe,
+	.remove = si5338_i2c_remove,
+	.id_table = si5338_i2c_ids,
+};
+module_i2c_driver(si5338_driver);
+
+MODULE_AUTHOR("York Sun <yorksun@freescale.com");
+MODULE_DESCRIPTION("Silicon Labs Si5338 clock generator driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/clk/clk-si5338simple.c b/drivers/clk/clk-si5338simple.c
new file mode 100644
index 0000000..38ea136
--- /dev/null
+++ b/drivers/clk/clk-si5338simple.c
@@ -0,0 +1,902 @@
+/*
+# si5338_cfg
+#
+# Script to program Silicon Labs SI5338 Clock chip on Intel/Altera
+# Arria 10 SoC DevKit
+# by  David Koltak  Intel PSG  05/18/2016
+#
+#!/usr/bin/perl
+
+if ($#ARGV != 1)
+{ die "USAGE: $0 {i2c_dev_addr} {reg_map_file}\n"; }
+
+$I2C_BUS_NUM = 0;
+$I2C_SI5228_ADDR = $ARGV[0];
+$I2C_REG_MAP = $ARGV[1];
+
+#
+# READ DATA ARRAY FROM REGISTER MAP FILE
+#
+
+open(_INFILE_, "<$I2C_REG_MAP") || die "ERROR: Unable to open '$I2C_REG_MAP'\n";
+$SI5338_CFG_DATA = "";
+$data_found = 0;
+while ($line = <_INFILE_>)
+{
+  if ($data_found)
+  {
+    $line =~ s/\s+//g;
+    $SI5338_CFG_DATA .= "$line\n";
+    if ($line =~ /};/)
+    { last; }
+  }
+  elsif ($line =~ /Reg_Data\s+const\s+code\s+Reg_Store\[NUM_REGS_MAX\]\s+=\s+{/)
+  { $data_found = 1; }
+}
+
+close(_INFILE_);
+
+#
+# SCRIPT TO PROGRAM SI5338 PART
+#
+
+print "INFO: Disabling si5338 outputs\n";
+
+write_reg(230, 0x10, 0x10);
+
+print "INFO: Pausing si5338 LOL\n";
+
+write_reg(241, 0x80, 0x80);
+
+print "INFO: Writing register map to si5338\n";
+
+@cfg_data = split(/\n/, $SI5338_CFG_DATA);
+$idx = 0;
+
+write_reg(255, 0x00, 0xFF);
+
+foreach $cfg_set (@cfg_data)
+{
+  if ($cfg_set eq "")
+  { next; }
+  
+  $idx++;
+  
+  if ($cfg_set =~ /{\s*(\d\w*)\s*,\s*(\d\w*)\s*,\s*(\d\w*)\s*}/)
+  {
+    $reg_waddr = $1;
+    $reg_wdata = $2;
+    $reg_wmask = $3;
+    
+    if ($reg_waddr =~ /^0/) { $reg_waddr = oct($reg_waddr); }
+    if ($reg_wdata =~ /^0/) { $reg_wdata = oct($reg_wdata); }
+    if ($reg_wmask =~ /^0/) { $reg_wmask = oct($reg_wmask); }
+    
+    write_reg($reg_waddr, $reg_wdata, $reg_wmask);
+  }
+  else { die "ERROR: Invalid config data line at index $idx\n"; }
+}
+
+print "INFO: Validating si5338 input clock status\n";
+
+$rtn = read_reg(218);
+while (($rtn & 0x04) != 0)
+{ $rtn = read_reg(218); }
+
+print "INFO: Configuring si5338 PLL for locking\n";
+
+write_reg(49, 0x00, 0x80);
+
+print "INFO: Initiating si5338 PLL lock sequence\n";
+
+write_reg(246, 0x02, 0x02);
+sleep(1); # NOTE: Only need 25 ms, but 1 second will work
+
+print "INFO: Restarting si5338 LOL\n";
+
+write_reg(241, 0x65, 0xFF);
+
+print "INFO: Confirming si5338 PLL locked status\n";
+
+$rtn = read_reg(218);
+while (($rtn & 0x15) != 0)
+{ $rtn = read_reg(218); }
+
+print "INFO: Copying si5338 FCAL values to active reg\n";
+
+$rtn = read_reg(237);
+write_reg(47, $rtn, 0x03);
+
+$rtn = read_reg(236);
+write_reg(46, $rtn, 0xFF);
+
+$rtn = read_reg(235);
+write_reg(45, $rtn, 0xFF);
+
+write_reg(47, 0x14, 0xFC);
+
+print "INFO: Setting si5338 PLL to use FCAL values\n";
+
+write_reg(49, 0x80, 0x80);
+
+print "INFO: Enabling si5338 outputs\n";
+
+write_reg(230, 0x00, 0x10);
+
+print " * * * FINISHED * * *\n";
+exit;            
+
+#
+# HELPER FUNCTIONS
+#
+
+sub read_reg
+{
+  my $addr = shift;
+  my $data;
+  my $cmd = "i2cget -y $I2C_BUS_NUM $I2C_SI5228_ADDR $addr";
+  
+  print "<-- $cmd\n";
+  $data = `$cmd`;
+  
+  if (!($data =~ /^0x\w\w/))
+  { die "ERROR: Bad return value '$data' from '$cmd'\n"; }
+  
+  return oct($data);
+}
+
+sub write_reg
+{
+  my $addr = shift;
+  my $data = shift;
+  my $mask = shift;
+  my $cmd = "i2cset -y $I2C_BUS_NUM $I2C_SI5228_ADDR $addr $data";
+  
+  if ($mask == 0)
+  { return 0; }
+  elsif ($mask != 0xFF)
+  {
+    $data = ($data & $mask) | (read_reg($addr) & ~$mask);
+    $cmd = "i2cset -y $I2C_BUS_NUM $I2C_SI5228_ADDR $addr $data";
+  }
+  
+  print "--> $cmd\n";
+  $data = system($cmd);
+  
+  if ($data)
+  { die "ERROR: Bad return value '$data' from '$cmd'\n"; }
+  
+  return 0;
+}
+*/
+
+/* NOTICE: on A10DK board, SW1.I2C_Flag should be LOW */
+//#define DEBUG 1
+#include <linux/bsearch.h>
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+#include <linux/clk-provider.h>
+#include <linux/debugfs.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/i2c.h>
+#include <linux/math64.h>
+#include <linux/module.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <asm/io.h>
+#include <linux/unistd.h>
+#include <linux/device.h>
+
+#define PLL_POLLING_TMOUT 100
+
+#define REG5338_PAGE			255
+#define REG5338_PAGE_MASK		1
+#define REG5338_DEV_CONFIG2		2
+#define REG5338_DEV_CONFIG2_MASK	0x3f
+#define REG5338_DEV_CONFIG2_VAL		38 /* last 2 digits of part number */
+#define AWE_STATUS			0xdaff
+#define AWE_FCAL_07_00		0xebff
+#define AWE_FCAL_15_08		0xecff
+#define AWE_FCAL_17_16		0xed03
+#define AWE_SOFT_RESET		0xf602
+#define NUM_REGS_MAX 350
+
+
+/*
+ * This array is used to determine if a register is writable. The mask is
+ * not used in this driver. The data is in format of 0xAAAMM where AAA is
+ * address, MM is bit mask. 1 means the corresponding bit is writable.
+ * Created from SiLabs ClockBuilder output.
+ * Note: Register 226, 230, 241, 246, 255 are not included in header file
+ *	 from ClockBuilder v2.7 or later. Manually added here.
+ */
+static const u32 register_masks[] = {
+	0x61d, 0x1b80, 0x1cff, 0x1dff, 0x1eff, 0x1fff, 0x20ff, 0x21ff,
+	0x22ff, 0x23ff, 0x241f, 0x251f, 0x261f, 0x271f, 0x28ff, 0x297f,
+	0x2a3f, 0x2bff, 0x2dff, 0x2eff, 0x2f3f, 0x30ff, 0x31ff, 0x32ff, 0x33ff,
+	0x34ff, 0x35ff, 0x36ff, 0x37ff, 0x38ff, 0x39ff, 0x3aff, 0x3bff,
+	0x3cff, 0x3dff, 0x3e3f, 0x3fff, 0x40ff, 0x41ff, 0x42ff, 0x43ff,
+	0x44ff, 0x45ff, 0x46ff, 0x47ff, 0x48ff, 0x493f, 0x4aff, 0x4bff,
+	0x4cff, 0x4dff, 0x4eff, 0x4fff, 0x50ff, 0x51ff, 0x52ff, 0x53ff,
+	0x543f, 0x55ff, 0x56ff, 0x57ff, 0x58ff, 0x59ff, 0x5aff, 0x5bff,
+	0x5cff, 0x5dff, 0x5eff, 0x5f3f, 0x61ff, 0x62ff, 0x63ff, 0x64ff,
+	0x65ff, 0x66ff, 0x67ff, 0x68ff, 0x69ff, 0x6abf, 0x6bff, 0x6cff,
+	0x6dff, 0x6eff, 0x6fff, 0x70ff, 0x71ff, 0x72ff, 0x73ff, 0x74ff,
+	0x75ff, 0x76ff, 0x77ff, 0x78ff, 0x79ff, 0x7aff, 0x7bff, 0x7cff,
+	0x7dff, 0x7eff, 0x7fff, 0x80ff, 0x810f, 0x820f, 0x83ff, 0x84ff,
+	0x85ff, 0x86ff, 0x87ff, 0x88ff, 0x89ff, 0x8aff, 0x8bff, 0x8cff,
+	0x8dff, 0x8eff, 0x8fff, 0x90ff, 0x98ff, 0x99ff, 0x9aff, 0x9bff,
+	0x9cff, 0x9dff, 0x9e0f, 0x9f0f, 0xa0ff, 0xa1ff, 0xa2ff, 0xa3ff,
+	0xa4ff, 0xa5ff, 0xa6ff, 0xa7ff, 0xa8ff, 0xa9ff, 0xaaff, 0xabff,
+	0xacff, 0xadff, 0xaeff, 0xafff, 0xb0ff, 0xb1ff, 0xb2ff, 0xb3ff,
+	0xb4ff, 0xb50f, 0xb6ff, 0xb7ff, 0xb8ff, 0xb9ff, 0xbaff, 0xbbff,
+	0xbcff, 0xbdff, 0xbeff, 0xbfff, 0xc0ff, 0xc1ff, 0xc2ff, 0xc3ff,
+	0xc4ff, 0xc5ff, 0xc6ff, 0xc7ff, 0xc8ff, 0xc9ff, 0xcaff, 0xcb0f,
+	0xccff, 0xcdff, 0xceff, 0xcfff, 0xd0ff, 0xd1ff, 0xd2ff, 0xd3ff,
+	0xd4ff, 0xd5ff, 0xd6ff, 0xd7ff, 0xd8ff, 0xd9ff, 0xe204, 0xe6ff,
+	0xf1ff, 0xf202, 0xf6ff, 0xffff, 0x11fff,
+	0x120ff, 0x121ff, 0x122ff, 0x123ff, 0x124ff, 0x125ff, 0x126ff, 0x127ff,
+	0x128ff, 0x129ff, 0x12aff, 0x12b0f, 0x12fff, 0x130ff, 0x131ff, 0x132ff,
+	0x133ff, 0x134ff, 0x135ff, 0x136ff, 0x137ff, 0x138ff, 0x139ff, 0x13aff,
+	0x13b0f, 0x13fff, 0x140ff, 0x141ff, 0x142ff, 0x143ff, 0x144ff, 0x145ff,
+	0x146ff, 0x147ff, 0x148ff, 0x149ff, 0x14aff, 0x14b0f, 0x14fff, 0x150ff,
+	0x151ff, 0x152ff, 0x153ff, 0x154ff, 0x155ff, 0x156ff, 0x157ff, 0x158ff,
+	0x159ff, 0x15aff, 0x15b0f
+};
+
+static int si5338_find_msk(const void *key, const void *elt)
+{
+	const u32 *reg = key;
+	const u32 *msk = elt;
+
+	if (*reg > *msk >> 8)
+		return 1;
+	if (*reg < *msk >> 8)
+		return -1;
+
+	return 0;
+}
+
+static bool si5338_regmap_is_writeable(struct device *dev, unsigned int reg)
+{
+	return bsearch(&reg, register_masks, ARRAY_SIZE(register_masks),
+		       sizeof(u32), si5338_find_msk) != NULL;
+}
+
+static bool si5338_regmap_is_volatile(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case (AWE_STATUS >> 8):
+	case (AWE_SOFT_RESET >> 8):
+	case (AWE_FCAL_07_00 >> 8):
+	case (AWE_FCAL_15_08 >> 8):
+	case (AWE_FCAL_17_16 >> 8):
+		return true;
+	}
+
+	return false;
+}
+
+/* reg, val, msk */
+static const unsigned short si5338_regs[NUM_REGS_MAX][3] = {
+{  0,0x00,0x00},
+{  1,0x00,0x00},
+{  2,0x00,0x00},
+{  3,0x00,0x00},
+{  4,0x00,0x00},
+{  5,0x00,0x00},
+{  6,0x08,0x1D},
+{  7,0x00,0x00},
+{  8,0x70,0x00},
+{  9,0x0F,0x00},
+{ 10,0x00,0x00},
+{ 11,0x00,0x00},
+{ 12,0x00,0x00},
+{ 13,0x00,0x00},
+{ 14,0x00,0x00},
+{ 15,0x00,0x00},
+{ 16,0x00,0x00},
+{ 17,0x00,0x00},
+{ 18,0x00,0x00},
+{ 19,0x00,0x00},
+{ 20,0x00,0x00},
+{ 21,0x00,0x00},
+{ 22,0x00,0x00},
+{ 23,0x00,0x00},
+{ 24,0x00,0x00},
+{ 25,0x00,0x00},
+{ 26,0x00,0x00},
+{ 27,0x70,0x80},
+{ 28,0x16,0xFF},
+{ 29,0x90,0xFF},
+{ 30,0xB0,0xFF},
+{ 31,0xC0,0xFF},
+{ 32,0xC0,0xFF},
+{ 33,0xC0,0xFF},
+{ 34,0xC0,0xFF},
+{ 35,0xAA,0xFF},
+{ 36,0x06,0x1F},
+{ 37,0x06,0x1F},
+{ 38,0x06,0x1F},
+{ 39,0x06,0x1F},
+{ 40,0x84,0xFF},
+{ 41,0x10,0x7F},
+{ 42,0x24,0x3F},
+{ 43,0x00,0x00},
+{ 44,0x00,0x00},
+{ 45,0x00,0xFF},
+{ 46,0x00,0xFF},
+{ 47,0x14,0x3F},
+{ 48,0x36,0xFF},
+{ 49,0x00,0xFF},
+{ 50,0xC3,0xFF},
+{ 51,0x07,0xFF},
+{ 52,0x10,0xFF},
+{ 53,0x50,0xFF},
+{ 54,0x08,0xFF},
+{ 55,0x00,0xFF},
+{ 56,0x00,0xFF},
+{ 57,0x00,0xFF},
+{ 58,0x00,0xFF},
+{ 59,0x08,0xFF},
+{ 60,0x00,0xFF},
+{ 61,0x00,0xFF},
+{ 62,0x00,0x3F},
+{ 63,0x10,0xFF},
+{ 64,0xC6,0xFF},
+{ 65,0x02,0xFF},
+{ 66,0x80,0xFF},
+{ 67,0x00,0xFF},
+{ 68,0x00,0xFF},
+{ 69,0x00,0xFF},
+{ 70,0x90,0xFF},
+{ 71,0x00,0xFF},
+{ 72,0x00,0xFF},
+{ 73,0x00,0x3F},
+{ 74,0x10,0xFF},
+{ 75,0x00,0xFF},
+{ 76,0x02,0xFF},
+{ 77,0x00,0xFF},
+{ 78,0x00,0xFF},
+{ 79,0x00,0xFF},
+{ 80,0x00,0xFF},
+{ 81,0x01,0xFF},
+{ 82,0x00,0xFF},
+{ 83,0x00,0xFF},
+{ 84,0x00,0x3F},
+{ 85,0x10,0xFF},
+{ 86,0x50,0xFF},
+{ 87,0x08,0xFF},
+{ 88,0x00,0xFF},
+{ 89,0x00,0xFF},
+{ 90,0x00,0xFF},
+{ 91,0x00,0xFF},
+{ 92,0x08,0xFF},
+{ 93,0x00,0xFF},
+{ 94,0x00,0xFF},
+{ 95,0x00,0x3F},
+{ 96,0x10,0x00},
+{ 97,0x90,0xFF},
+{ 98,0x31,0xFF},
+{ 99,0x00,0xFF},
+{100,0x00,0xFF},
+{101,0x00,0xFF},
+{102,0x00,0xFF},
+{103,0x08,0xFF},
+{104,0x00,0xFF},
+{105,0x00,0xFF},
+{106,0x80,0xBF},
+{107,0x00,0xFF},
+{108,0x00,0xFF},
+{109,0x00,0xFF},
+{110,0x80,0xFF},
+{111,0x00,0xFF},
+{112,0x00,0xFF},
+{113,0x00,0xFF},
+{114,0x80,0xFF},
+{115,0x00,0xFF},
+{116,0x80,0xFF},
+{117,0x00,0xFF},
+{118,0x80,0xFF},
+{119,0x00,0xFF},
+{120,0x00,0xFF},
+{121,0x00,0xFF},
+{122,0x80,0xFF},
+{123,0x00,0xFF},
+{124,0x00,0xFF},
+{125,0x00,0xFF},
+{126,0x00,0xFF},
+{127,0x00,0xFF},
+{128,0x00,0xFF},
+{129,0x00,0x0F},
+{130,0x00,0x0F},
+{131,0x00,0xFF},
+{132,0x00,0xFF},
+{133,0x00,0xFF},
+{134,0x00,0xFF},
+{135,0x00,0xFF},
+{136,0x00,0xFF},
+{137,0x00,0xFF},
+{138,0x00,0xFF},
+{139,0x00,0xFF},
+{140,0x00,0xFF},
+{141,0x00,0xFF},
+{142,0x00,0xFF},
+{143,0x00,0xFF},
+{144,0x00,0xFF},
+{145,0x00,0x00},
+{146,0xFF,0x00},
+{147,0x00,0x00},
+{148,0x00,0x00},
+{149,0x00,0x00},
+{150,0x00,0x00},
+{151,0x00,0x00},
+{152,0x00,0xFF},
+{153,0x00,0xFF},
+{154,0x00,0xFF},
+{155,0x00,0xFF},
+{156,0x00,0xFF},
+{157,0x00,0xFF},
+{158,0x00,0x0F},
+{159,0x00,0x0F},
+{160,0x00,0xFF},
+{161,0x00,0xFF},
+{162,0x00,0xFF},
+{163,0x00,0xFF},
+{164,0x00,0xFF},
+{165,0x00,0xFF},
+{166,0x00,0xFF},
+{167,0x00,0xFF},
+{168,0x00,0xFF},
+{169,0x00,0xFF},
+{170,0x00,0xFF},
+{171,0x00,0xFF},
+{172,0x00,0xFF},
+{173,0x00,0xFF},
+{174,0x00,0xFF},
+{175,0x00,0xFF},
+{176,0x00,0xFF},
+{177,0x00,0xFF},
+{178,0x00,0xFF},
+{179,0x00,0xFF},
+{180,0x00,0xFF},
+{181,0x00,0x0F},
+{182,0x00,0xFF},
+{183,0x00,0xFF},
+{184,0x00,0xFF},
+{185,0x00,0xFF},
+{186,0x00,0xFF},
+{187,0x00,0xFF},
+{188,0x00,0xFF},
+{189,0x00,0xFF},
+{190,0x00,0xFF},
+{191,0x00,0xFF},
+{192,0x00,0xFF},
+{193,0x00,0xFF},
+{194,0x00,0xFF},
+{195,0x00,0xFF},
+{196,0x00,0xFF},
+{197,0x00,0xFF},
+{198,0x00,0xFF},
+{199,0x00,0xFF},
+{200,0x00,0xFF},
+{201,0x00,0xFF},
+{202,0x00,0xFF},
+{203,0x00,0x0F},
+{204,0x00,0xFF},
+{205,0x00,0xFF},
+{206,0x00,0xFF},
+{207,0x00,0xFF},
+{208,0x00,0xFF},
+{209,0x00,0xFF},
+{210,0x00,0xFF},
+{211,0x00,0xFF},
+{212,0x00,0xFF},
+{213,0x00,0xFF},
+{214,0x00,0xFF},
+{215,0x00,0xFF},
+{216,0x00,0xFF},
+{217,0x00,0xFF},
+{218,0x00,0x00},
+{219,0x00,0x00},
+{220,0x00,0x00},
+{221,0x0D,0x00},
+{222,0x00,0x00},
+{223,0x00,0x00},
+{224,0xF4,0x00},
+{225,0xF0,0x00},
+{226,0x00,0x00},
+{227,0x00,0x00},
+{228,0x00,0x00},
+{229,0x00,0x00},
+{231,0x00,0x00},
+{232,0x00,0x00},
+{233,0x00,0x00},
+{234,0x00,0x00},
+{235,0x00,0x00},
+{236,0x00,0x00},
+{237,0x00,0x00},
+{238,0x14,0x00},
+{239,0x00,0x00},
+{240,0x00,0x00},
+{242,0x02,0x02},
+{243,0xF0,0x00},
+{244,0x00,0x00},
+{245,0x00,0x00},
+{247,0x00,0x00},
+{248,0x00,0x00},
+{249,0xA8,0x00},
+{250,0x00,0x00},
+{251,0x84,0x00},
+{252,0x00,0x00},
+{253,0x00,0x00},
+{254,0x00,0x00},
+{255,   1,0xFF}, // set page bit to 1 
+{  0+256,0x00,0x00},
+{  1+256,0x00,0x00},
+{  2+256,0x00,0x00},
+{  3+256,0x00,0x00},
+{  4+256,0x00,0x00},
+{  5+256,0x00,0x00},
+{  6+256,0x00,0x00},
+{  7+256,0x00,0x00},
+{  8+256,0x00,0x00},
+{  9+256,0x00,0x00},
+{ 10+256,0x00,0x00},
+{ 11+256,0x00,0x00},
+{ 12+256,0x00,0x00},
+{ 13+256,0x00,0x00},
+{ 14+256,0x00,0x00},
+{ 15+256,0x00,0x00},
+{ 16+256,0x00,0x00},
+{ 17+256,0x01,0x00},
+{ 18+256,0x00,0x00},
+{ 19+256,0x00,0x00},
+{ 20+256,0x90,0x00},
+{ 21+256,0x31,0x00},
+{ 22+256,0x00,0x00},
+{ 23+256,0x00,0x00},
+{ 24+256,0x01,0x00},
+{ 25+256,0x00,0x00},
+{ 26+256,0x00,0x00},
+{ 27+256,0x00,0x00},
+{ 28+256,0x00,0x00},
+{ 29+256,0x00,0x00},
+{ 30+256,0x00,0x00},
+{ 31+256,0x00,0xFF},
+{ 32+256,0x00,0xFF},
+{ 33+256,0x01,0xFF},
+{ 34+256,0x00,0xFF},
+{ 35+256,0x00,0xFF},
+{ 36+256,0x90,0xFF},
+{ 37+256,0x31,0xFF},
+{ 38+256,0x00,0xFF},
+{ 39+256,0x00,0xFF},
+{ 40+256,0x01,0xFF},
+{ 41+256,0x00,0xFF},
+{ 42+256,0x00,0xFF},
+{ 43+256,0x00,0x0F},
+{ 44+256,0x00,0x00},
+{ 45+256,0x00,0x00},
+{ 46+256,0x00,0x00},
+{ 47+256,0x00,0xFF},
+{ 48+256,0x00,0xFF},
+{ 49+256,0x01,0xFF},
+{ 50+256,0x00,0xFF},
+{ 51+256,0x00,0xFF},
+{ 52+256,0x90,0xFF},
+{ 53+256,0x31,0xFF},
+{ 54+256,0x00,0xFF},
+{ 55+256,0x00,0xFF},
+{ 56+256,0x01,0xFF},
+{ 57+256,0x00,0xFF},
+{ 58+256,0x00,0xFF},
+{ 59+256,0x00,0x0F},
+{ 60+256,0x00,0x00},
+{ 61+256,0x00,0x00},
+{ 62+256,0x00,0x00},
+{ 63+256,0x00,0xFF},
+{ 64+256,0x00,0xFF},
+{ 65+256,0x01,0xFF},
+{ 66+256,0x00,0xFF},
+{ 67+256,0x00,0xFF},
+{ 68+256,0x90,0xFF},
+{ 69+256,0x31,0xFF},
+{ 70+256,0x00,0xFF},
+{ 71+256,0x00,0xFF},
+{ 72+256,0x01,0xFF},
+{ 73+256,0x00,0xFF},
+{ 74+256,0x00,0xFF},
+{ 75+256,0x00,0x0F},
+{ 76+256,0x00,0x00},
+{ 77+256,0x00,0x00},
+{ 78+256,0x00,0x00},
+{ 79+256,0x00,0xFF},
+{ 80+256,0x00,0xFF},
+{ 81+256,0x00,0xFF},
+{ 82+256,0x00,0xFF},
+{ 83+256,0x00,0xFF},
+{ 84+256,0x90,0xFF},
+{ 85+256,0x31,0xFF},
+{ 86+256,0x00,0xFF},
+{ 87+256,0x00,0xFF},
+{ 88+256,0x01,0xFF},
+{ 89+256,0x00,0xFF},
+{ 90+256,0x00,0xFF},
+{ 91+256,0x00,0x0F},
+{ 92+256,0x00,0x00},
+{ 93+256,0x00,0x00},
+{ 94+256,0x00,0x00},
+{255,   0,0xFF} // set page bit to 0
+};
+
+static const struct regmap_range_cfg si5338_regmap_range[] = {
+	{
+		.selector_reg = REG5338_PAGE,		/* 255 */
+		.selector_mask  = REG5338_PAGE_MASK,	/* 1 */
+		.selector_shift = 0,
+		.window_start = 0,
+		.window_len = 256,
+		.range_min = 0,
+		.range_max = 347,
+	},
+};
+
+static const struct regmap_config si5338_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.cache_type = REGCACHE_RBTREE,
+	.max_register = 347,
+	.ranges = si5338_regmap_range,
+	.num_ranges = ARRAY_SIZE(si5338_regmap_range),
+	.writeable_reg = si5338_regmap_is_writeable,
+	.volatile_reg = si5338_regmap_is_volatile,
+};
+
+/*
+ * SI5338 register access
+ */
+
+struct si5338simple_t {
+	struct i2c_client *client;
+	struct regmap *regmap;
+};
+
+static inline int si5338simple_reg_read(struct si5338simple_t *drvdata, u16 reg, u8 *val)
+{
+    int ret;
+	unsigned int tmp;
+
+	ret = regmap_read(drvdata->regmap, reg, &tmp);
+	if (ret) {
+		dev_err(&drvdata->client->dev, "regmap_read failed: [0x%x] -> 0x%x\n",
+			reg, tmp);
+		return -ENODEV;
+	}
+	dev_dbg(&drvdata->client->dev, "i2cget -y 0 0x71 %d -> %d\n", reg, tmp);
+	*val = (u8)tmp;
+	return 0;
+}
+
+static inline int si5338simple_reg_write(struct si5338simple_t *drvdata, u8 val, u16 reg, u8 msk)
+{
+	int ret;
+	unsigned int tmp;
+
+	if (msk == 0x00) return 0;
+
+#if 0
+	regmap_update_bits(drvdata->regmap, reg, msk, val);
+#else
+	if (msk == 0xff) tmp = val;
+	else {
+		ret = regmap_read(drvdata->regmap, reg, &tmp);
+		if (ret) {
+			dev_err(&drvdata->client->dev, "regmap_read failed: [0x%x] -> 0x%x\n",
+				reg, tmp);
+			return -ENODEV;
+		}
+		tmp &= ~msk;
+		tmp |= val & msk;
+	}
+
+	ret = regmap_write(drvdata->regmap, reg, tmp);
+	if (ret < 0) {
+		dev_err(&drvdata->client->dev, "regmap_write failed: [0x%x] <- 0x%x\n",
+			reg, tmp);
+		return -ENODEV;
+	}
+#endif
+	dev_dbg(&drvdata->client->dev, "i2cset -y 0 0x71 %d %d\n",
+		reg, tmp);
+	return 0;
+}
+
+/*
+ * Si5351 i2c probe and device tree parsing
+ */
+
+#ifdef CONFIG_OF
+static int si5338simple_dt_parse(struct i2c_client *client)
+{
+	struct device_node *np = client->dev.of_node;
+
+	if (np == NULL)
+		return 0;
+
+	return 0;
+}
+
+static const struct of_device_id si5338simple_dt_ids[] = {
+	{ .compatible = "silabs,si5338" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, si5338simple_dt_ids);
+#else
+static int si5338simple_dt_parse(struct i2c_client *client)
+{
+	return 0;
+}
+#endif /* CONFIG_OF */
+
+static int si5338simple_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	int ret, i;
+	u8 val;
+	struct si5338simple_t *drvdata;
+
+	dev_info(&client->dev, "%s: enter", __func__);
+
+	drvdata = devm_kzalloc(&client->dev, sizeof(*drvdata), GFP_KERNEL);
+	if (!drvdata)
+		return -ENOMEM;
+
+	si5338simple_dt_parse(client);
+
+	i2c_set_clientdata(client, drvdata);
+	drvdata->client = client;
+
+	/* Register regmap */
+	drvdata->regmap = devm_regmap_init_i2c(client, &si5338_regmap_config);
+	if (IS_ERR(drvdata->regmap)) {
+		dev_err(&client->dev, "devm_regmap_init_i2c failed 0x%x\n", drvdata->regmap);
+		return PTR_ERR(drvdata->regmap);
+	}
+
+	/* Check if si5338 exists */ 
+	ret = si5338simple_reg_read(drvdata, REG5338_DEV_CONFIG2, &val);
+	if (ret < 0) return -ENODEV;
+	if ((val & REG5338_DEV_CONFIG2_MASK) != REG5338_DEV_CONFIG2_VAL) {
+		dev_err(&client->dev, "[%d] -> 0x%x but expected 0x%x\n",
+			REG5338_DEV_CONFIG2, val, REG5338_DEV_CONFIG2_VAL);
+		return -ENODEV;
+	}
+	ret = si5338simple_reg_read(drvdata, 0, &val);
+	if (ret < 0) return -ENODEV;
+	dev_info(&client->dev, "si5338 Rev.%d detected\n", val & 0x7);
+
+	dev_dbg(&client->dev, "Disabling si5338 outputs\n");
+	ret = si5338simple_reg_write(drvdata, 0x10, 230, 0x10);
+	if (ret < 0) return -ENODEV;
+
+	dev_dbg(&client->dev, "Pausing LOL\n");
+	ret = si5338simple_reg_write(drvdata, 0x80, 241, 0x80);
+	if (ret < 0) return -ENODEV;
+	ret = si5338simple_reg_write(drvdata, 0x00, 255, 0xff);
+	if (ret < 0) return -ENODEV;
+
+	dev_dbg(&client->dev, "Writing registers table produced by CLOCKBUILDER DESKTOP\n");
+	for (i = 0; i < ARRAY_SIZE(si5338_regs); i++) {
+		ret = si5338simple_reg_write(drvdata, si5338_regs[i][1],
+			si5338_regs[i][0], si5338_regs[i][2]);
+		if (ret < 0) return -ENODEV;
+	}
+
+	dev_dbg(&client->dev, "Confirming PLL locked status\n");
+	i = PLL_POLLING_TMOUT;
+	do {
+		msleep(1);
+		ret = si5338simple_reg_read(drvdata, 218, &val);
+	    if (ret < 0) return -ENODEV;
+		if (!(val & 0x04)) break;
+	} while (i--);
+	if (0 == i) {
+		dev_err(&client->dev, "Timeout(%d ms): polling [218] for 0x04 but 0x%x\n",
+			PLL_POLLING_TMOUT, val); 
+		return -ETIMEDOUT;
+	}
+	dev_info(&client->dev, "PLL locked without LOL\n");
+
+	dev_dbg(&client->dev, "Configuring PLL for locking\n");
+	ret = si5338simple_reg_write(drvdata, 0x00, 49, 0xFF);
+	if (ret < 0) return -ENODEV;
+
+	dev_dbg(&client->dev, "Initiating PLL lock sequence\n");
+	ret = si5338simple_reg_write(drvdata,  0x02, 246, 0x02);
+	if (ret < 0) return -ENODEV;
+
+	msleep(25); /* NOTE: need 25 ms per datasheet */
+
+	dev_dbg(&client->dev, "Restarting LOL\n");
+	ret = si5338simple_reg_write(drvdata, 0x65, 241, 0xFF);
+	if (ret < 0) return -ENODEV;
+
+	dev_dbg(&client->dev, "Confirming PLL locked status\n");
+	i = PLL_POLLING_TMOUT;
+	do {
+		msleep(1);
+		ret = si5338simple_reg_read(drvdata, 218, &val);
+	    if (ret < 0) return -ENODEV;
+		if (!(val & 0x15)) break;
+	} while (i--);
+	if (0 == i) {
+		dev_err(&client->dev, "Timeout(%d ms): polling [218] for 0x15 but 0x%x\n",
+			PLL_POLLING_TMOUT, val); 
+		return -ETIMEDOUT;
+	}
+	dev_info(&client->dev, "PLL locked with LOL\n");
+
+	dev_dbg(&client->dev, "Copying FCAL values to active\n");
+	ret = si5338simple_reg_read(drvdata, 237, &val);
+	if (ret < 0) return -ENODEV;
+	ret = si5338simple_reg_write(drvdata, val, 47,  0x03);
+	if (ret < 0) return -ENODEV;
+	ret = si5338simple_reg_read(drvdata, 236, &val);
+	if (ret < 0) return -ENODEV;
+	ret = si5338simple_reg_write(drvdata, val, 46, 0xFF);
+	if (ret < 0) return -ENODEV;
+	ret = si5338simple_reg_read(drvdata, 235, &val);
+	if (ret < 0) return -ENODEV;
+	ret = si5338simple_reg_write(drvdata, val, 45, 0xFF);
+	if (ret < 0) return -ENODEV;
+	ret = si5338simple_reg_write(drvdata, 0x14, 47, 0xFC);
+	if (ret < 0) return -ENODEV;
+	dev_dbg(&client->dev, "Setting PLL to use FCAL values\n");
+	ret = si5338simple_reg_write(drvdata , 0x80, 49, 0x80);
+	if (ret < 0) return -ENODEV;
+	dev_dbg(&client->dev, "Enabling outputs\n");
+	ret = si5338simple_reg_write(drvdata, 0x00, 230, 0x10);
+	if (ret < 0) return -ENODEV;
+
+	dev_info(&client->dev, "%s: succeed", __func__);
+	return 0;
+}
+
+static int si5338simple_remove(struct i2c_client *client)
+{
+	struct si5338simple_t *drvdata = i2c_get_clientdata(client);
+
+    //misc_deregister(&drvdata->misc_dev);
+	//kfree(drvdata);
+
+	dev_info(&client->dev, "Removed\n");
+	return 0;
+}
+
+static const struct i2c_device_id si5338_hw_ids[] = {
+	{ "si5338", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, si5338_hw_ids);
+
+static struct i2c_driver si5338simple_driver = {
+	.driver = {
+		.name	= "si5338simple",
+		.owner	= THIS_MODULE,
+#ifdef CONFIG_OF
+		.of_match_table = of_match_ptr(si5338simple_dt_ids),
+#endif
+	},
+	.probe		= si5338simple_probe,
+	.remove		= si5338simple_remove,
+	.id_table	= si5338_hw_ids,
+};
+module_i2c_driver(si5338simple_driver);
+
+MODULE_AUTHOR("David Koltak, Intel PSG");
+MODULE_DESCRIPTION("si5338simple based on 'si5338_cfg' from Altera");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/clk/si5338.h b/drivers/clk/si5338.h
new file mode 100644
index 0000000..5422955
--- /dev/null
+++ b/drivers/clk/si5338.h
@@ -0,0 +1,48 @@
+/*
+ * Si5338A/B/C programmable clock generator platform_data.
+ */
+
+#ifndef __LINUX_PLATFORM_DATA_SI5338_H__
+#define __LINUX_PLATFORM_DATA_SI5338_H__
+
+struct clk;
+
+/*
+ * struct si5338_clkout_config - Si5338 clock output configuration
+ * @name: clkout name. If omitted, clkout0/1/2/3 with name_prefix will be used
+ * @clkout_src: clkout source clock
+ * @drive: output drive strength
+ * @rate: initial clkout rate, or default if 0
+ * @enabled: output enabled by default
+ */
+struct si5338_clkout_config {
+	const char *name;
+	u8 clkout_src;
+	const char *drive;
+	u8 disable_state;
+	unsigned long rate;
+	bool enabled;
+};
+
+/*
+ * struct si5338_platform_data - Platform data for the Si5338 clock driver
+ * @name_prefix: prefix to clock names
+ *		 In case multiple clock chips exist, each can have unique names
+ * @ref_src: reference clock source
+ * @fb_src: feedback clock source
+ * @pll_src: array of pll source clock setting
+ * @pll_master: index of MS (1 of 4) which can change pll clock
+ * @pll_vco: set pll vco clock. If this is set, pll_master is ignored
+ * @clkout: array of clkout configuration
+ */
+struct si5338_platform_data {
+	const char *name_prefix;
+	u8 ref_src;
+	u8 fb_src;
+	u8 pll_src;
+	u8 pll_master;
+	u32 pll_vco;
+	struct si5338_clkout_config clkout[4];
+};
+
+#endif
diff --git a/drivers/dma/dma-axi-dmac.c b/drivers/dma/dma-axi-dmac.c
index 912bbb9..db16b84 100644
--- a/drivers/dma/dma-axi-dmac.c
+++ b/drivers/dma/dma-axi-dmac.c
@@ -243,11 +243,15 @@ static void axi_dmac_start_transfer(struct axi_dmac_chan *chan)
 	if (axi_dmac_dest_is_mem(chan)) {
 		axi_dmac_write(dmac, AXI_DMAC_REG_DEST_ADDRESS, sg->dest_addr);
 		axi_dmac_write(dmac, AXI_DMAC_REG_DEST_STRIDE, sg->dest_stride);
+		printk("%s: axi_dmac_dst_is_mem: %d, %d, 0x%x, %d, %d\n", __func__,
+            dmac->dma_dev.dev_id, sg->id, sg->dest_addr, sg->x_len, sg->y_len);
 	}
 
 	if (axi_dmac_src_is_mem(chan)) {
 		axi_dmac_write(dmac, AXI_DMAC_REG_SRC_ADDRESS, sg->src_addr);
 		axi_dmac_write(dmac, AXI_DMAC_REG_SRC_STRIDE, sg->src_stride);
+		printk("%s: axi_dmac_src_is_mem: %d, %d, 0x%x, %d, %d\n", __func__,
+            dmac->dma_dev.dev_id, sg->id, sg->dest_addr, sg->x_len, sg->y_len);
 	}
 
 	/*
@@ -308,6 +312,7 @@ static bool axi_dmac_transfer_done(struct axi_dmac_chan *chan,
 		}
 	} while (active);
 
+	printk("%s: %u\n", __func__, completed_transfers);
 	return start_next;
 }
 
@@ -828,6 +833,7 @@ static int axi_dmac_probe(struct platform_device *pdev)
 	struct resource *res;
 	int ret;
 
+	dev_info(&pdev->dev, "%s: enter\n", __func__);
 	dmac = devm_kzalloc(&pdev->dev, sizeof(*dmac), GFP_KERNEL);
 	if (!dmac)
 		return -ENOMEM;
@@ -918,6 +924,8 @@ static int axi_dmac_probe(struct platform_device *pdev)
 	platform_set_drvdata(pdev, dmac);
 
 	devm_regmap_init_mmio(&pdev->dev, dmac->base, &axi_dmac_regmap_config);
+	dev_info(&pdev->dev, "%s succeed: dma %x direction %d\n", __func__,
+        dma_dev->dev_id, dma_dev->directions);
 
 #ifdef SPEED_TEST
 	for (i = 0; i < 0x30; i += 4)
diff --git a/drivers/dma/dmaengine.c b/drivers/dma/dmaengine.c
index 6b53526..37c27b7 100644
--- a/drivers/dma/dmaengine.c
+++ b/drivers/dma/dmaengine.c
@@ -1005,6 +1005,8 @@ int dma_async_device_register(struct dma_device *device)
 	}
 
 	device->chancnt = chancnt;
+	dev_info(device->dev, "%s: dma %d channel %d register succeed\n",
+			__func__, device->dev_id, chan->chan_id);
 
 	mutex_lock(&dma_list_mutex);
 	/* take references on public channels */
diff --git a/drivers/iio/adc/ad9371.c b/drivers/iio/adc/ad9371.c
index 886b3f5..ea100fe 100644
--- a/drivers/iio/adc/ad9371.c
+++ b/drivers/iio/adc/ad9371.c
@@ -4042,7 +4042,11 @@ static int ad9371_probe(struct spi_device *spi)
 		return PTR_ERR(phy->fmc_clk);
 
 	phy->sysref_dev_clk = devm_clk_get(&spi->dev, "sysref_dev_clk");
+	//if (IS_ERR(phy->sysref_dev_clk))
+	//	return PTR_ERR(phy->sysref_dev_clk);
 	phy->sysref_fmc_clk = devm_clk_get(&spi->dev, "sysref_fmc_clk");
+	//if (IS_ERR(phy->sysref_fmc_clk))
+	//	return PTR_ERR(phy->sysref_fmc_clk);
 
 	ret = clk_prepare_enable(phy->fmc_clk);
 	if (ret)
@@ -4141,10 +4145,13 @@ static int ad9371_probe(struct spi_device *spi)
 	MYKONOS_getApiVersion(phy->mykDevice, &api_vers[0], &api_vers[1], &api_vers[2], &api_vers[3]);
 	MYKONOS_getDeviceRev(phy->mykDevice, &rev);
 
-	dev_info(&spi->dev, "%s : AD937%d Rev %d, Firmware %u.%u.%u API version: %u.%u.%u.%u successfully initialized",
+	dev_info(&spi->dev, "%s: AD937%d Rev.%d, Firmware %u.%u.%u API %u.%u.%u.%u successfully initialized",
 		 __func__, AD937x_PARTID(phy), rev, vers[0], vers[1], vers[2],
 		 api_vers[0], api_vers[1], api_vers[2], api_vers[3]);
 
+	/* release: multiple ad9371 chips share this gpio */
+	gpiod_put(phy->sysref_req_gpio);
+
 	return 0;
 
 out_iio_device_unregister:
diff --git a/drivers/iio/adc/ad_adc.c b/drivers/iio/adc/ad_adc.c
index d30815a..75c4bb9 100644
--- a/drivers/iio/adc/ad_adc.c
+++ b/drivers/iio/adc/ad_adc.c
@@ -318,6 +318,11 @@ static int adc_probe(struct platform_device *pdev)
 	if (ret)
 		goto err_unconfigure_ring;
 
+    dev_info(&pdev->dev, "%s: %d.%d.%c mem->start 0x%X mapped to 0x%X\n", __func__,
+        	PCORE_VERSION_MAJOR(st->pcore_version),
+			PCORE_VERSION_MINOR(st->pcore_version),
+        	PCORE_VERSION_LETTER(st->pcore_version),
+			mem->start, st->regs);
 	return 0;
 
 err_unconfigure_ring:
diff --git a/drivers/iio/frequency/Makefile b/drivers/iio/frequency/Makefile
index 352fdb8..7579bfb 100644
--- a/drivers/iio/frequency/Makefile
+++ b/drivers/iio/frequency/Makefile
@@ -6,8 +6,8 @@
 obj-$(CONFIG_AD9508) += ad9508.o
 obj-$(CONFIG_AD9517) += ad9517.o
 obj-$(CONFIG_AD9523) += ad9523.o
-obj-$(CONFIG_AD9528) += ad9528.o
-obj-$(CONFIG_AD9548) += ad9548.o
+obj-$(CONFIG_AD9548) += ad9548.o # should be latter than lmk04828
+obj-$(CONFIG_AD9528) += ad9528.o # should be latter than ad9548
 obj-$(CONFIG_ADF4350) += adf4350.o
 obj-$(CONFIG_ADF5355) += adf5355.o
 cf_axi_dds_drv-y := cf_axi_dds.o cf_axi_dds_buffer_stream.o
@@ -17,6 +17,9 @@ obj-$(CONFIG_CF_AXI_DDS_AD9144) += ad9144.o
 obj-$(CONFIG_CF_AXI_DDS_AD9739A) += ad9739a.o
 obj-$(CONFIG_HMC7044) += hmc7044.o
 
-ad916x_drv-y := ad916x/ad916x_api.o  ad916x/ad916x_irq_api.o  ad916x/ad916x_jesd_api.o  ad916x/ad916x_jesd_test_api.o  ad916x/ad916x_nco_api.o  ad916x/ad916x_reg.o  ad916x/api_errors.o  ad916x/utils.o
+ad916x_drv-y := ad916x/ad916x_api.o  ad916x/ad916x_irq_api.o \
+	ad916x/ad916x_jesd_api.o  ad916x/ad916x_jesd_test_api.o \
+	ad916x/ad916x_nco_api.o  ad916x/ad916x_reg.o \
+	ad916x/api_errors.o  ad916x/utils.o
 obj-$(CONFIG_CF_AXI_DDS_AD9162) += ad9162.o ad916x_drv.o
 
diff --git a/drivers/iio/frequency/ad9528.c b/drivers/iio/frequency/ad9528.c
index fbe4432..9ea1234 100644
--- a/drivers/iio/frequency/ad9528.c
+++ b/drivers/iio/frequency/ad9528.c
@@ -372,24 +372,38 @@ static int ad9528_sync(struct iio_dev *indio_dev)
 {
 	int ret = ad9528_write(indio_dev,
 			AD9528_CHANNEL_SYNC, AD9528_CHANNEL_SYNC_SET);
-	if (ret < 0)
+	if (ret < 0) {
+		dev_err(&indio_dev->dev, "ERR: write AD9528_CHANNEL_SYNC_SET\n");
 		return ret;
+	}
 
 	ret = ad9528_io_update(indio_dev);
-	if (ret < 0)
+	if (ret < 0) {
+		dev_err(&indio_dev->dev, "ERR: write AD9528_IO_UPDATE\n");
 		return ret;
+	}
 
 	ret = ad9528_write(indio_dev, AD9528_CHANNEL_SYNC, 0);
-	if (ret < 0)
+	if (ret < 0) {
+		dev_err(&indio_dev->dev, "ERR: write AD9528_CHANNEL_SYNC\n");
 		return ret;
+	}
 
 	ret = ad9528_io_update(indio_dev);
-	if (ret < 0)
+	if (ret < 0) {
+		dev_err(&indio_dev->dev, "ERR: write AD9528_IO_UPDATE\n");
 		return ret;
+	}
 
-	return ad9528_poll(indio_dev, AD9528_READBACK,
+	ret = ad9528_poll(indio_dev, AD9528_READBACK,
 			AD9528_VCXO_OK | AD9528_PLL2_LOCKED,
 			AD9528_VCXO_OK | AD9528_PLL2_LOCKED);
+	if (ret == -ETIMEDOUT) {
+		dev_err(&indio_dev->dev, "ERR: VCXO/PLL2 unlock/timeout\n");
+		return ret;
+	}
+
+	return ret;
 }
 
 static ssize_t ad9528_store(struct device *dev,
@@ -846,6 +860,25 @@ static struct clk *ad9528_clk_register(struct iio_dev *indio_dev, unsigned num,
 	return clk;
 }
 
+static int ad9528_clk_unregister(struct iio_dev *indio_dev)
+{
+	int i;
+	struct ad9528_state *st = iio_priv(indio_dev);
+	struct ad9528_platform_data *pdata = st->pdata;
+	struct ad9528_channel_spec *chan;
+
+	for (i = 0; i < pdata->num_channels; i++) {
+		chan = &pdata->channels[i];
+		if (chan->channel_num >= AD9528_NUM_CHAN || chan->output_dis)
+			continue;
+
+		if(st->clk_data.clks[chan->channel_num])
+			clk_unregister(st->clk_data.clks[chan->channel_num]);
+		st->clk_data.clks[chan->channel_num] = 0;
+	}
+	return 0;
+}
+
 static int ad9528_setup(struct iio_dev *indio_dev)
 {
 	struct ad9528_state *st = iio_priv(indio_dev);
@@ -860,21 +893,27 @@ static int ad9528_setup(struct iio_dev *indio_dev)
 			AD9528_SER_CONF_SOFT_RESET |
 			((st->spi->mode & SPI_3WIRE || pdata->spi3wire)? 0 :
 			 AD9528_SER_CONF_SDO_ACTIVE));
-	if (ret < 0)
+	if (ret < 0) {
+		dev_err(&indio_dev->dev, "ERR: write SERIAL_PORT_CONFIG\n");
 		return ret;
-
+	}
 	ret = ad9528_write(indio_dev, AD9528_SERIAL_PORT_CONFIG_B,
 			AD9528_SER_CONF_READ_BUFFERED);
-	if (ret < 0)
+	if (ret < 0) {
+		dev_err(&indio_dev->dev, "ERR: write SERIAL_PORT_CONFIG_B\n");
 		return ret;
-
+	}
 	ret = ad9528_io_update(indio_dev);
-	if (ret < 0)
+	if (ret < 0) {
+		dev_err(&indio_dev->dev, "ad9528_io_update\n");
 		return ret;
+	}
 
 	ret = ad9528_read(indio_dev, AD9528_CHIP_ID);
-	if (ret < 0)
+	if (ret < 0) {
+		dev_err(&indio_dev->dev, "read AD9528_CHIP_ID\n");
 		return ret;
+	}
 
 	if (ret != AD9528_SPI_MAGIC) {
 		dev_err(&indio_dev->dev,
@@ -887,18 +926,24 @@ static int ad9528_setup(struct iio_dev *indio_dev)
 	 */
 	ret = ad9528_write(indio_dev, AD9528_PLL1_REF_A_DIVIDER,
 		pdata->refa_r_div);
-	if (ret < 0)
+	if (ret < 0) {
+		dev_err(&indio_dev->dev, "ERR: write AD9528_PLL1_REF_A_DIVIDER\n");
 		return ret;
+	}
 
 	ret = ad9528_write(indio_dev, AD9528_PLL1_REF_B_DIVIDER,
 		pdata->refb_r_div);
-	if (ret < 0)
+	if (ret < 0) {
+		dev_err(&indio_dev->dev, "ERR: write AD9528_PLL1_REF_B_DIVIDER\n");
 		return ret;
+	}
 
 	ret = ad9528_write(indio_dev, AD9528_PLL1_FEEDBACK_DIVIDER,
 		pdata->pll1_feedback_div);
-	if (ret < 0)
+	if (ret < 0) {
+		dev_err(&indio_dev->dev, "ERR: write AD9528_PLL1_FEEDBACK_DIVIDER\n");
 		return ret;
+	}
 
 	ret = ad9528_write(indio_dev, AD9528_PLL1_CHARGE_PUMP_CTRL,
 		AD_IFE(pll1_bypass_en, AD9528_PLL1_CHARGE_PUMP_TRISTATE,
@@ -906,8 +951,10 @@ static int ad9528_setup(struct iio_dev *indio_dev)
 			pll1_charge_pump_current_nA) |
 		AD9528_PLL1_CHARGE_PUMP_MODE_NORMAL |
 		AD9528_PLL1_CHARGE_PUMP_AUTO_TRISTATE_DIS));
-	if (ret < 0)
+	if (ret < 0) {
+		dev_err(&indio_dev->dev, "ERR: write AD9528_PLL1_CHARGE_PUMP_CTRL\n");
 		return ret;
+	}
 
 	ret = ad9528_write(indio_dev, AD9528_PLL1_CTRL,
 		AD_IFE(pll1_bypass_en,
@@ -927,8 +974,10 @@ static int ad9528_setup(struct iio_dev *indio_dev)
 		AD_IF(refb_cmos_neg_inp_en, AD9528_PLL1_REFB_CMOS_NEG_INP_EN) |
 		AD_IF(pll1_feedback_src_vcxo, AD9528_PLL1_SOURCE_VCXO) |
 		AD9528_PLL1_REF_MODE(pdata->ref_mode));
-	if (ret < 0)
+	if (ret < 0) {
+		dev_err(&indio_dev->dev, "ERR: write AD9528_PLL1_CTRL\n");
 		return ret;
+	}
 
 	/*
 	 * PLL2 Setup
@@ -948,20 +997,26 @@ static int ad9528_setup(struct iio_dev *indio_dev)
 	ret = ad9528_write(indio_dev, AD9528_PLL2_CHARGE_PUMP,
 		AD9528_PLL2_CHARGE_PUMP_CURRENT_nA(pdata->
 			pll2_charge_pump_current_nA));
-	if (ret < 0)
+	if (ret < 0) {
+		dev_err(&indio_dev->dev, "ERR: write AD9528_PLL2_CHARGE_PUMP\n");
 		return ret;
+	}
 
 	ret = ad9528_write(indio_dev, AD9528_PLL2_FEEDBACK_DIVIDER_AB,
 		AD9528_PLL2_FB_NDIV_A_CNT(pll2_ndiv_a_cnt) |
 		AD9528_PLL2_FB_NDIV_B_CNT(pll2_ndiv_b_cnt));
-	if (ret < 0)
+	if (ret < 0) {
+		dev_err(&indio_dev->dev, "ERR: write AD9528_PLL2_FEEDBACK_DIVIDER_AB\n");
 		return ret;
+	}
 
 	ret = ad9528_write(indio_dev, AD9528_PLL2_CTRL,
 		AD9528_PLL2_CHARGE_PUMP_MODE_NORMAL |
 		AD_IF(pll2_freq_doubler_en, AD9528_PLL2_FREQ_DOUBLER_EN));
-	if (ret < 0)
+	if (ret < 0) {
+		dev_err(&indio_dev->dev, "ERR: write AD9528_PLL2_CTRL\n");
 		return ret;
+	}
 
 
 	vco_freq = div_u64((unsigned long long)pdata->vcxo_freq *
@@ -971,15 +1026,19 @@ static int ad9528_setup(struct iio_dev *indio_dev)
 	vco_ctrl = AD_IF(pll2_freq_doubler_en || pdata->pll2_r1_div != 1,
 				AD9528_PLL2_DOUBLER_R1_EN);
 	ret = ad9528_write(indio_dev, AD9528_PLL2_VCO_CTRL, vco_ctrl);
-	if (ret < 0)
+	if (ret < 0) {
+		dev_err(&indio_dev->dev, "ERR: write AD9528_PLL2_VCO_CTRL\n");
 		return ret;
+	}
 
 	ret = ad9528_write(indio_dev, AD9528_PLL2_VCO_DIVIDER,
 		AD9528_PLL2_VCO_DIV_M1(pdata->pll2_vco_div_m1) |
 		AD_IFE(pll2_vco_div_m1, 0,
 		       AD9528_PLL2_VCO_DIV_M1_PWR_DOWN_EN));
-	if (ret < 0)
+	if (ret < 0) {
+		dev_err(&indio_dev->dev, "ERR: write AD9528_PLL2_VCO_DIVIDER\n");
 		return ret;
+	}
 
 	if (pdata->pll2_vco_div_m1)
 		st->vco_out_freq[AD9528_VCO] =
@@ -996,13 +1055,17 @@ static int ad9528_setup(struct iio_dev *indio_dev)
 
 	ret = ad9528_write(indio_dev, AD9528_PLL2_R1_DIVIDER,
 		AD9528_PLL2_R1_DIV(pdata->pll2_r1_div));
-	if (ret < 0)
+	if (ret < 0) {
+		dev_err(&indio_dev->dev, "ERR: write AD9528_PLL2_R1_DIVIDER\n");
 		return ret;
+	}
 
 	ret = ad9528_write(indio_dev, AD9528_PLL2_N2_DIVIDER,
 		AD9528_PLL2_N2_DIV(pdata->pll2_n2_div));
-	if (ret < 0)
+	if (ret < 0) {
+		dev_err(&indio_dev->dev, "ERR: write AD9528_PLL2_N2_DIVIDER\n");
 		return ret;
+	}
 
 	ret = ad9528_write(indio_dev, AD9528_PLL2_LOOP_FILTER_CTRL,
 		AD9528_PLL2_LOOP_FILTER_CPOLE1(pdata->cpole1) |
@@ -1010,8 +1073,10 @@ static int ad9528_setup(struct iio_dev *indio_dev)
 		AD9528_PLL2_LOOP_FILTER_RPOLE2(pdata->rpole2) |
 		AD_IF(rzero_bypass_en,
 		      AD9528_PLL2_LOOP_FILTER_RZERO_BYPASS_EN));
-	if (ret < 0)
+	if (ret < 0) {
+		dev_err(&indio_dev->dev, "ERR: write AD9528_PLL2_LOOP_FILTER_CTRL\n");
 		return ret;
+	}
 
 	st->clk_data.clks = st->clks;
 	st->clk_data.clk_num = AD9528_NUM_CHAN;
@@ -1032,8 +1097,10 @@ static int ad9528_setup(struct iio_dev *indio_dev)
 			AD9528_CLK_DIST_DIV(chan->channel_divider) |
 			AD9528_CLK_DIST_DIV_PHASE(chan->divider_phase) |
 			AD9528_CLK_DIST_CTRL(chan->signal_source));
-		if (ret < 0)
+		if (ret < 0) {
+			dev_err(&indio_dev->dev, "ERR: write AD9528_CHANNEL%d_OUTPUT\n", chan->channel_num);
 			return ret;
+		}
 
 		st->ad9528_channels[i].type = IIO_ALTVOLTAGE;
 		st->ad9528_channels[i].output = 1;
@@ -1064,18 +1131,24 @@ static int ad9528_setup(struct iio_dev *indio_dev)
 
 	ret = ad9528_write(indio_dev, AD9528_CHANNEL_PD_EN,
 			AD9528_CHANNEL_PD_MASK(~active_mask));
-	if (ret < 0)
+	if (ret < 0) {
+		dev_err(&indio_dev->dev, "ERR: write AD9528_CHANNEL_PD_EN\n");
 		return ret;
+	}
 
 	ret = ad9528_write(indio_dev, AD9528_CHANNEL_SYNC_IGNORE,
 			AD9528_CHANNEL_IGNORE_MASK(ignoresync_mask));
-	if (ret < 0)
+	if (ret < 0) {
+		dev_err(&indio_dev->dev, "ERR: write AD9528_CHANNEL_SYNC_IGNORE\n");
 		return ret;
+	}
 
 	ret = ad9528_write(indio_dev, AD9528_SYSREF_K_DIVIDER,
 			AD9528_SYSREF_K_DIV(pdata->sysref_k_div));
-	if (ret < 0)
+	if (ret < 0) {
+		dev_err(&indio_dev->dev, "ERR: write AD9528_SYSREF_K_DIVIDER\n");
 		return ret;
+	}
 
 	sysref_ctrl = AD9528_SYSREF_PATTERN_MODE(pdata->sysref_pattern_mode) |
 		AD9528_SYSREF_SOURCE(pdata->sysref_src) |
@@ -1083,41 +1156,57 @@ static int ad9528_setup(struct iio_dev *indio_dev)
 		AD9528_SYSREF_PATTERN_TRIGGER_CTRL(pdata->sysref_req_trigger_mode) |
 		(pdata->sysref_req_en ? AD9528_SYSREF_REQUEST_BY_PIN : 0);
 	ret = ad9528_write(indio_dev, AD9528_SYSREF_CTRL, sysref_ctrl);
-	if (ret < 0)
+	if (ret < 0) {
+		dev_err(&indio_dev->dev, "ERR: write AD9528_SYSREF_CTRL\n");
 		return ret;
+	}
 
 	ret = ad9528_write(indio_dev, AD9528_PD_EN, AD9528_PD_BIAS);
-	if (ret < 0)
+	if (ret < 0) {
+		dev_err(&indio_dev->dev, "ERR: write AD9528_PD_EN\n");
 		return ret;
+	}
 
 	ret = ad9528_io_update(indio_dev);
-	if (ret < 0)
+	if (ret < 0) {
+		dev_err(&indio_dev->dev, "ad9528_io_update\n");
 		return ret;
+	}
 
 	ret = ad9528_write(indio_dev, AD9528_PLL2_VCO_CTRL,
 			vco_ctrl | AD9528_PLL2_VCO_CALIBRATE);
-	if (ret < 0)
+	if (ret < 0) {
+		dev_err(&indio_dev->dev, "ERR: write AD9528_PLL2_VCO_CTRL\n");
 		return ret;
+	}
 
 	ret = ad9528_io_update(indio_dev);
-	if (ret < 0)
+	if (ret < 0) {
+		dev_err(&indio_dev->dev, "ERR: write ad9528_io_update\n");
 		return ret;
+	}
 
 	ret = ad9528_poll(indio_dev, AD9528_READBACK,
 			AD9528_IS_CALIBRATING, 0);
-	if (ret < 0)
+	if (ret < 0) {
+		dev_err(&indio_dev->dev, "ERR: write AD9528_READBACK\n");
 		return ret;
-
+	}
+	
 	sysref_ctrl |= AD9528_SYSREF_PATTERN_REQ;
 	ret = ad9528_write(indio_dev, AD9528_SYSREF_CTRL, sysref_ctrl);
-	if (ret < 0)
+	if (ret < 0) {
+		dev_err(&indio_dev->dev, "ERR: Software trigger SYSREF by writing [0403].bit0\n");
 		return ret;
+	}
 
 	if (pdata->stat0_pin_func_sel != 0xFF) {
 		ret = ad9528_write(indio_dev, AD9528_STAT_MON0,
 				   pdata->stat0_pin_func_sel);
-		if (ret < 0)
+		if (ret < 0) {
+			dev_err(&indio_dev->dev, "ERR: write AD9528_STAT_MON0\n");
 			return ret;
+		}
 
 		stat_en_mask |= AD9528_STAT0_PIN_EN;
 	}
@@ -1125,8 +1214,10 @@ static int ad9528_setup(struct iio_dev *indio_dev)
 	if (pdata->stat1_pin_func_sel != 0xFF) {
 		ret = ad9528_write(indio_dev, AD9528_STAT_MON1,
 				   pdata->stat1_pin_func_sel);
-		if (ret < 0)
+		if (ret < 0) {
+			dev_err(&indio_dev->dev, "ERR: write AD9528_STAT_MON1\n");
 			return ret;
+		}
 
 		stat_en_mask |= AD9528_STAT1_PIN_EN;
 	}
@@ -1134,17 +1225,23 @@ static int ad9528_setup(struct iio_dev *indio_dev)
 	if (stat_en_mask) {
 		ret = ad9528_write(indio_dev, AD9528_STAT_PIN_EN,
 				   stat_en_mask);
-		if (ret < 0)
+		if (ret < 0) {
+			dev_err(&indio_dev->dev, "ERR: write AD9528_STAT_PIN_EN\n");
 			return ret;
+		}
 	}
 
 	ret = ad9528_io_update(indio_dev);
-	if (ret < 0)
+	if (ret < 0) {
+		dev_err(&indio_dev->dev, "ERR: write ad9528_io_update\n");
 		return ret;
+	}
 
 	ret = ad9528_sync(indio_dev);
-	if (ret < 0)
+	if (ret < 0) {
+		dev_err(&indio_dev->dev, "ERR: write ad9528_sync\n");
 		return ret;
+	}
 
 	for (i = 0; i < pdata->num_channels; i++) {
 		struct clk *clk;
@@ -1345,6 +1442,8 @@ static int ad9528_probe(struct spi_device *spi)
 	struct gpio_desc *status1_gpio;
 	int ret;
 
+	dev_info(&spi->dev, "%s: enter\n", __func__);
+
 	if (spi->dev.of_node)
 		pdata = ad9528_parse_dt(&spi->dev);
 	else
@@ -1401,13 +1500,18 @@ static int ad9528_probe(struct spi_device *spi)
 	indio_dev->num_channels = pdata->num_channels;
 
 	ret = ad9528_setup(indio_dev);
-	if (ret < 0)
+	if (ret < 0) {
+		dev_info(&spi->dev, "%s exit at line %d\n", __func__, __LINE__);
 		goto error_disable_reg;
+	}
 
 	ret = iio_device_register(indio_dev);
-	if (ret)
+	if (ret) {
+		dev_info(&spi->dev, "%s exit line at %d\n", __func__, __LINE__);
 		goto error_disable_reg;
+	}
 
+	dev_info(&spi->dev, "%s: succeed\n", __func__);
 	return 0;
 
 error_disable_reg:
@@ -1427,6 +1531,7 @@ static int ad9528_remove(struct spi_device *spi)
 	if (!IS_ERR(st->reg))
 		regulator_disable(st->reg);
 
+	ad9528_clk_unregister(indio_dev);
 	return 0;
 }
 
diff --git a/drivers/iio/frequency/ad9548.c b/drivers/iio/frequency/ad9548.c
index 75a7296..edd24972 100644
--- a/drivers/iio/frequency/ad9548.c
+++ b/drivers/iio/frequency/ad9548.c
@@ -18,6 +18,10 @@
 
 #include <linux/iio/iio.h>
 
+/* enable: sys_clk_in with 10.0 MHz from external GPRS
+  disable: sys_clk_in with 76.8 MHz from lmk04828 */
+//#define EXT_CLKIN_10M
+
 #define AD_READ		(1 << 15)
 #define AD_WRITE	(0 << 15)
 #define AD_CNT(x)	(((x) - 1) << 13)
@@ -26,18 +30,45 @@
 #define CHIPID_AD9548	0x48
 
 static const unsigned short ad9548_regs[][2] = {
+#if 0
 	{0x0000, 0x30}, /* Reset */
 	{0x0000, 0x10},
 	{0x0000, 0x10},
 	{0x0000, 0x10},
 	{0x0000, 0x10},
 	{0x0000, 0x10},
+//#else
+	{0x0000, 0x90}, /* Reset */
+	{0x0000, 0x90},
+	{0x0000, 0x90},
+	{0x0000, 0x90},
+	{0x0000, 0x90},
+	{0x0000, 0x90},
+#endif
+#if 1
 	{0x0100, 0x18}, /* System clock */
-	{0x0101, 0x28},
-	{0x0102, 0x45},
-	{0x0103, 0x43},
-	{0x0104, 0xDE},
+#else
+	/*	Date: 20180817
+		Change: bit6: Charge pump mode automatic/0->manual/1
+				bit[5:3]: charge pump current 500->1000 μA
+		Result: TO BE Verified by RF team */
+	{0x0100, 0x78},
+#endif
+#if defined(EXT_CLKIN_10M)
+	{0x0101, 0x4D},
+	/*0x45->0x05*/
+	{0x0102, 0x05},
+	{0x0103, 0x0D},
+	{0x0104, 0xD1},
 	{0x0105, 0x13},
+#else
+	{0x0101, 0x0A},
+	/*0x45->0x05*/
+	{0x0102, 0x05},
+	{0x0103, 0x9E},
+	{0x0104, 0xAE},
+	{0x0105, 0xC6},
+#endif
 	{0x0106, 0x01},
 	{0x0107, 0x00},
 	{0x0108, 0x00},
@@ -60,11 +91,19 @@
 	{0x0212, 0x00},
 	{0x0213, 0xFF}, /* Auxiliary DAC */
 	{0x0214, 0x01},
+#if defined(EXT_CLKIN_10M)
+	{0x0300, 0xE7}, /* DPLL */
+	{0x0301, 0xE2},
+	{0x0302, 0x35},
+	{0x0303, 0x86},
+	{0x0304, 0xDA},
+#else
 	{0x0300, 0x29}, /* DPLL */
 	{0x0301, 0x5C},
 	{0x0302, 0x8F},
 	{0x0303, 0xC2},
 	{0x0304, 0xF5},
+#endif
 	{0x0305, 0x28},
 	{0x0307, 0x00},
 	{0x0308, 0x00},
@@ -88,19 +127,26 @@
 	{0x031A, 0x00},
 	{0x031B, 0x00},
 	{0x0306, 0x01}, /* Update TW */
-	{0x0400, 0x0C}, /* Clock distribution output */
-	{0x0401, 0x03},
-	{0x0402, 0x00},
-	{0x0403, 0x02},
-	{0x0404, 0x04},
-	{0x0405, 0x08},
+	{0x0400, 0x0D}, /* Clock distribution output */
+	{0x0401, 0x02},
+	{0x0402, 0x0D},
+	{0x0403, 0x00},
+	{0x0404, 0x03},
+#if 1
+	{0x0405, 0x0A},
+#else
+	/*	Change: bit4: OUT1 Invert the polarity;
+				bit3: OUT1 low->normal drive strength
+		Result: AD9528 PLL2 ***UNCLOCK*** */
+	{0x0405, 0x12},
+#endif
 	{0x0406, 0x03},
 	{0x0407, 0x03},
-	{0x0408, 0x03},
+	{0x0408, 0x00},
 	{0x0409, 0x00},
 	{0x040A, 0x00},
 	{0x040B, 0x00},
-	{0x040C, 0x03},
+	{0x040C, 0x00},
 	{0x040D, 0x00},
 	{0x040E, 0x00},
 	{0x040F, 0x00},
@@ -113,7 +159,7 @@
 	{0x0416, 0x00},
 	{0x0417, 0x00},
 	{0x0500, 0xFE}, /* Reference inputs */
-	{0x0501, 0x00},
+	{0x0501, 0x03},
 	{0x0502, 0x00},
 	{0x0503, 0x08},
 	{0x0504, 0x00},
@@ -121,13 +167,13 @@
 	{0x0506, 0x00},
 	{0x0507, 0x00},
 	{0x0600, 0x00}, /* Profiles are 0x0600-0x07FF */
-	{0x0601, 0x55}, /* Profile 0 */
-	{0x0602, 0xA0}, /* 30MHz input from FPGA, 122.880MHz output clock */
-	{0x0603, 0xFC},
-	{0x0604, 0x01},
-	{0x0605, 0x00},
-	{0x0606, 0x00},
-	{0x0607, 0x00},
+	{0x0601, 0x00}, /* Profile 0 */
+	{0x0602, 0x80}, /* 30MHz input from FPGA, 122.880MHz output clock */
+	{0x0603, 0xC6},
+	{0x0604, 0xA4},
+	{0x0605, 0x7E},
+	{0x0606, 0x8D},
+	{0x0607, 0x03},
 	{0x0608, 0xE8},
 	{0x0609, 0x03},
 	{0x060A, 0x00},
@@ -150,19 +196,19 @@
 	{0x061B, 0xCB},
 	{0x061C, 0xC4},
 	{0x061D, 0x05},
-	{0x061E, 0x7F},
+	{0x061E, 0x07},
 	{0x061F, 0x00},
 	{0x0620, 0x00},
 	{0x0621, 0x00},
-	{0x0622, 0x0B},
-	{0x0623, 0x02},
-	{0x0624, 0x00},
-	{0x0625, 0x00},
+	{0x0622, 0xCA},
+	{0x0623, 0x0A},
+	{0x0624, 0x98},
+	{0x0625, 0x3A},
 	{0x0626, 0x26},
-	{0x0627, 0xB0},
+	{0x0627, 0x60},
 	{0x0628, 0x00},
-	{0x0629, 0x10},
-	{0x062A, 0x27},
+	{0x0629, 0xe8},
+	{0x062A, 0x03},
 	{0x062B, 0x20},
 	{0x062C, 0x44},
 	{0x062D, 0xF4},
@@ -171,6 +217,9 @@
 	{0x0630, 0x20},
 	{0x0631, 0x44},
 	{0x0005, 0x01}, /* I/O Update */
+	{0x0A01, 0x38},
+	{0x0A0D, 0x01},
+	{0x0005, 0x01}, /* I/O Update */
 	{0x0A0E, 0x01}, /* Force validation timeout */
 	{0x0005, 0x01}, /* I/O Update */
 	{0x0A02, 0x02}, /* Sync distribution */
@@ -191,8 +240,10 @@ static int ad9548_read(struct spi_device *spi, unsigned reg)
 
 
 	ret = spi_write_then_read(spi, &buf[0], 2, &buf[2], 1);
-	if (ret < 0)
+	if (ret < 0) {
+		dev_err(&spi->dev, "%s %u\n", __func__, reg);
 		return ret;
+	}
 
 	return buf[2];
 }
@@ -210,8 +261,10 @@ static int ad9548_write(struct spi_device *spi,
 	buf[2] = val;
 
 	ret = spi_write(spi, buf, 3);
-	if (ret < 0)
+	if (ret < 0) {
+		dev_err(&spi->dev, "%s %u %u\n", __func__, reg, val);
 		return ret;
+	}
 
 	return 0;
 }
@@ -220,18 +273,57 @@ static int ad9548_probe(struct spi_device *spi)
 {
 	int i, ret, timeout;
 
+	dev_info(&spi->dev, "%s: enter", __func__);
+
+#ifdef CONFIG_OF
+	/*
+	struct device_node *np;
+	np = of_find_node_by_name(NULL, "clksyn");
+	if (NULL == np) {
+		dev_err(&spi->dev, "device-tree: node 'ad9548-spi' not find\n");
+		return -EINVAL;
+	}
+	ret = of_property_read_u32_index(np, "pl-cs-val", 0, &pl_cs_val);
+	if (ret < 0) {
+		dev_err(&spi->dev, "device-tree: property 'pl-cs-val' not find\n");
+		return -EINVAL;
+	}*/
+#endif
+
+	ret = ad9548_write(spi, 0x0, 0x20);
+	if (ret < 0) {
+		dev_err(&spi->dev, "Failed to write for reset\n");
+		return -ENODEV;
+	}
+	mdelay(100);
 	ret = ad9548_read(spi, 0x3);
-	if (ret < 0)
-		return ret;
+	if (ret < 0) {
+		dev_err(&spi->dev, "Failed to read [3] for ID\n");
+		return -ENODEV;
+	}
 	if (ret != CHIPID_AD9548) {
-		dev_err(&spi->dev, "Unrecognized CHIP_ID 0x%X\n", ret);
- 		return -ENODEV;
+		ret = ad9548_write(spi, 0x0, 0xB0);
+		if (ret < 0) {
+			dev_err(&spi->dev, "Failed to change default 3-wire mode into 4-wire\n");
+			return -ENODEV;
+		}
+		mdelay(100);
+		ret = ad9548_read(spi, 0x3);
+		if (ret < 0) {
+			dev_err(&spi->dev, "Failed to read [3] for ID\n");
+			return -ENODEV;
+		}
+		if (ret != CHIPID_AD9548) {
+			dev_err(&spi->dev, "Unrecognized CHIP_ID 0x%X\n", ret);
+			return -ENODEV;
+		}
 	}
+	dev_info(&spi->dev, "Rev.0x%X probed\n", ad9548_read(spi, 0x2));
 
-	for (i = 0; i < ARRAY_SIZE(ad9548_regs); i++)
+	for (i = 0; i < ARRAY_SIZE(ad9548_regs); i++) {
 		switch (ad9548_regs[i][0]) {
 		case WAIT_B:
-			timeout = 100;
+			timeout = 800;
 			do {
 				ret = ad9548_read(spi, 0xD01);
 				if (ret < 0)
@@ -241,8 +333,10 @@ static int ad9548_probe(struct spi_device *spi)
 				mdelay(1);
 			} while (timeout--);
 
-			if (timeout <= 0)
+			if (timeout <= 0) {
+				dev_info(&spi->dev, "system clock PLL unlock in 800ms\n");
 				return -ETIMEDOUT;
+			}
 			break;
 		default:
 			ret = ad9548_write(spi, ad9548_regs[i][0],
@@ -251,25 +345,35 @@ static int ad9548_probe(struct spi_device *spi)
 				return ret;
 			break;
 		}
+	}
 
-	dev_info(&spi->dev, "Rev. 0x%X probed\n", ad9548_read(spi, 0x2));
-
+	dev_info(&spi->dev, "%s: succeed\n", __func__);
 	return 0;
 }
 
-static const struct spi_device_id ad9548_id[] = {
-	{"ad9548", 0},
-	{}
+#ifdef CONFIG_OF
+static const struct of_device_id ad9548_dt_ids[] = {
+	{ .compatible = "adi,ad9548" },
+	{ }
+};
+#endif
+
+static const struct spi_device_id ad9548_hw_ids[] = {
+	{ "ad9548", CHIPID_AD9548 },
+	{ }
 };
-MODULE_DEVICE_TABLE(spi, ad9548_id);
+MODULE_DEVICE_TABLE(spi, ad9548_hw_ids);
 
 static struct spi_driver ad9548_driver = {
 	.driver = {
 		.name	= "ad9548",
 		.owner	= THIS_MODULE,
+#ifdef CONFIG_OF
+		.of_match_table = of_match_ptr(ad9548_dt_ids),
+#endif
 	},
 	.probe		= ad9548_probe,
-	.id_table	= ad9548_id,
+	.id_table	= ad9548_hw_ids,
 };
 module_spi_driver(ad9548_driver);
 
diff --git a/drivers/iio/jesd204/axi_jesd204_rx.c b/drivers/iio/jesd204/axi_jesd204_rx.c
index 3b3a0b9..bbd4b11 100644
--- a/drivers/iio/jesd204/axi_jesd204_rx.c
+++ b/drivers/iio/jesd204/axi_jesd204_rx.c
@@ -684,6 +684,10 @@ static int axi_jesd204_rx_probe(struct platform_device *pdev)
 
 	device_create_file(&pdev->dev, &dev_attr_status);
 
+	dev_info(&pdev->dev, "%s: %d.%d.%c\n", __func__,
+		PCORE_VERSION_MAJOR(jesd->version),
+		PCORE_VERSION_MINOR(jesd->version),
+		PCORE_VERSION_PATCH(jesd->version));
 	return 0;
 
 err_disable_device_clk:
@@ -703,8 +707,40 @@ static int axi_jesd204_rx_remove(struct platform_device *pdev)
 	struct axi_jesd204_rx *jesd = platform_get_drvdata(pdev);
 	int irq = platform_get_irq(pdev, 0);
 
+	if (jesd == NULL)
+		return 0;
+	if (irq < 0)
+		return irq;
+
+	switch (jesd->num_lanes) {
+	case 8:
+		device_remove_file(&pdev->dev, &dev_attr_lane4_info);
+		device_remove_file(&pdev->dev, &dev_attr_lane5_info);
+		device_remove_file(&pdev->dev, &dev_attr_lane6_info);
+		device_remove_file(&pdev->dev, &dev_attr_lane7_info);
+	case 4:
+		device_remove_file(&pdev->dev, &dev_attr_lane2_info);
+		device_remove_file(&pdev->dev, &dev_attr_lane3_info);
+	case 2:
+		device_remove_file(&pdev->dev, &dev_attr_lane1_info);
+	case 1:
+		device_remove_file(&pdev->dev, &dev_attr_lane0_info);
+		break;
+	default:
+		break;
+	}
+
+	device_remove_file(&pdev->dev, &dev_attr_status);
+
 	of_clk_del_provider(pdev->dev.of_node);
 
+	/* reference:
+	https://www.ibm.com/developerworks/library/l-tasklets/index.html
+	https://www.systutorials.com/linux-kernels/192771 */
+	cancel_delayed_work(&(jesd->watchdog_work));
+	flush_scheduled_work();
+
+	disable_irq(irq);
 	free_irq(irq, jesd);
 
 	writel_relaxed(0xff, jesd->base + JESD204_RX_REG_IRQ_PENDING);
@@ -722,7 +758,7 @@ static int axi_jesd204_rx_remove(struct platform_device *pdev)
 	{ .compatible = "adi,axi-jesd204-rx-1.0" },
 	{ /* end of list */ },
 };
-MODULE_DEVICE_TABLE(of, adxcvr_of_match);
+MODULE_DEVICE_TABLE(of, axi_jesd204_rx_of_match);
 
 static struct platform_driver axi_jesd204_rx_driver = {
 	.probe = axi_jesd204_rx_probe,
diff --git a/drivers/iio/jesd204/axi_jesd204_tx.c b/drivers/iio/jesd204/axi_jesd204_tx.c
index c093777..28e878e 100644
--- a/drivers/iio/jesd204/axi_jesd204_tx.c
+++ b/drivers/iio/jesd204/axi_jesd204_tx.c
@@ -561,6 +561,10 @@ static int axi_jesd204_tx_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, jesd);
 
+    dev_info(&pdev->dev, "%s: %d.%d.%c\n", __func__,
+    	PCORE_VERSION_MAJOR(version),
+		PCORE_VERSION_MINOR(version),
+		PCORE_VERSION_PATCH(version));
 	return 0;
 err_disable_device_clk:
 /*
@@ -579,8 +583,10 @@ static int axi_jesd204_tx_remove(struct platform_device *pdev)
 	struct axi_jesd204_tx *jesd = platform_get_drvdata(pdev);
 	int irq = platform_get_irq(pdev, 0);
 
+	device_remove_file(&pdev->dev, &dev_attr_status);
 	of_clk_del_provider(pdev->dev.of_node);
 
+	disable_irq(irq);
 	free_irq(irq, jesd);
 
 	writel_relaxed(0xff, jesd->base + JESD204_TX_REG_IRQ_PENDING);
@@ -598,7 +604,7 @@ static int axi_jesd204_tx_remove(struct platform_device *pdev)
 	{ .compatible = "adi,axi-jesd204-tx-1.0" },
 	{ /* end of list */ },
 };
-MODULE_DEVICE_TABLE(of, adxcvr_of_match);
+MODULE_DEVICE_TABLE(of, axi_jesd204_tx_of_match);
 
 static struct platform_driver axi_jesd204_tx_driver = {
 	.probe = axi_jesd204_tx_probe,
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index a0518bd..76c968f 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -411,6 +411,20 @@ config TI_DAC7512
 	  This driver can also be built as a module. If so, the module
 	  will be called ti_dac7512.
 
+config TI_LMK04828
+	tristate "Texas Instruments LMK04828 Low-Noise Clock Jitter Cleaner"
+	depends on SPI
+	default n
+	help
+	  Say yes here to build support for TI LMK04828 Ultra Low-Noise JESD204B
+	  Compliant Clock Jitter Cleaner with Dual Loop PLLs.
+	  NOTICE: Current HW design in fact use it as one clock generator: 
+	    VCO->122.88MHz->LMK04828-> 76.8MHz -> AD9548 -> ... -> AD9528
+	    VCO->122.88MHz->LMK04828-> 1PPS    -> FPGA Synchronize -> 1ms IRQ -> ARM
+
+	  This driver can also be built as a module. If so, the module
+	  will be called ti_lmk04828.
+
 config VMWARE_BALLOON
 	tristate "VMware Balloon Driver"
 	depends on VMWARE_VMCI && X86 && HYPERVISOR_GUEST
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index 0280797..09d7ad0 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -31,6 +31,7 @@ obj-$(CONFIG_ISL29020)		+= isl29020.o
 obj-$(CONFIG_SENSORS_TSL2550)	+= tsl2550.o
 obj-$(CONFIG_DS1682)		+= ds1682.o
 obj-$(CONFIG_TI_DAC7512)	+= ti_dac7512.o
+obj-$(CONFIG_TI_LMK04828)	+= ti_lmk04828.o
 obj-$(CONFIG_C2PORT)		+= c2port/
 obj-$(CONFIG_HMC6352)		+= hmc6352.o
 obj-$(CONFIG_XLNX_LCD)		+= xilinx_lcd.o
diff --git a/drivers/misc/ti_dac7512.c b/drivers/misc/ti_dac7512.c
index f5456fb..3ac6c07 100644
--- a/drivers/misc/ti_dac7512.c
+++ b/drivers/misc/ti_dac7512.c
@@ -89,7 +89,9 @@ static int dac7512_remove(struct spi_device *spi)
 static struct spi_driver dac7512_driver = {
 	.driver = {
 		.name	= "dac7512",
+#ifdef CONFIG_OF
 		.of_match_table = of_match_ptr(dac7512_of_match),
+#endif
 	},
 	.probe	= dac7512_probe,
 	.remove	= dac7512_remove,
diff --git a/drivers/misc/ti_lmk04828.c b/drivers/misc/ti_lmk04828.c
new file mode 100644
index 0000000..4af5a08
--- /dev/null
+++ b/drivers/misc/ti_lmk04828.c
@@ -0,0 +1,460 @@
+/*
+ * https://blog.csdn.net/u010243305/article/details/78426058
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/spidev.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/acpi.h>
+#include <linux/miscdevice.h>
+#include <linux/cdev.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <asm/current.h>
+#include <linux/sched.h>
+#include <linux/uaccess.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/unistd.h>
+
+#define MASK_WRITE	0x80
+#define MASK_READ	0x80
+#define MASK_SEVE	0x60
+#define MASK_ADDR_H 	0x1F
+#define SPI_SPEED_HZ	200000
+#define LMK04828_MAGIC	'K'
+#define GET_REG _IOR(LMK04828_MAGIC, 0, int)
+#define SET_REG _IOW(LMK04828_MAGIC, 0, int)
+
+struct lmk04828_t {
+	dev_t devt;
+	struct miscdevice misc_dev;
+	spinlock_t spi_lock;
+	struct spi_device *spi;
+	struct list_head device_entry;
+
+	/* TX/RX buffers are NULL unless opened (users > 0) */
+	struct mutex buf_lock;
+	unsigned int users;
+	u8 *tx_buffer;
+	u8 *rx_buffer;
+	u32 speed_hz;
+	u32 cur_index;	/* record the register offset */
+	void __iomem *pl_cs_addr;
+	u32 pl_cs_val;
+};
+
+void lmk04828spi_cs(struct lmk04828_t *drvdata)
+{
+#if 0
+	iowrite32(drvdata->pl_cs_val, drvdata->pl_cs_addr);
+#endif
+}
+
+static ssize_t lmk04828spi_sync(struct lmk04828_t *drvdata, struct spi_message *m)
+{
+	DECLARE_COMPLETION_ONSTACK(done);
+	int ret;
+	struct spi_device *spi = drvdata->spi;
+
+	if (spi == NULL) return -ESHUTDOWN;
+
+	lmk04828spi_cs(drvdata);
+
+	ret = spi_sync(spi, m);
+	if (ret != 0)
+		return ret;
+	return m->actual_length;
+}
+
+static ssize_t lmk04828spi_sync_write(struct lmk04828_t *drvdata, size_t len)
+{
+	struct spi_transfer t = {
+		.tx_buf 	= drvdata->tx_buffer,
+		.len		= len,
+		.speed_hz	= drvdata->speed_hz,
+	};
+	struct spi_message m;
+
+	spi_message_init(&m);
+	spi_message_add_tail(&t, &m);
+	return lmk04828spi_sync(drvdata, &m);
+}
+
+static ssize_t lmk04828spi_sync_read(struct lmk04828_t *drvdata, size_t len)
+{
+	struct spi_transfer t = {
+		.rx_buf 	= drvdata->rx_buffer,
+		.len		= len,
+		.speed_hz	= drvdata->speed_hz,
+	};
+	struct spi_message m;
+
+	spi_message_init(&m);
+	spi_message_add_tail(&t, &m);
+	return lmk04828spi_sync(drvdata, &m);
+}
+
+static int lmk04828reg_write(struct lmk04828_t *drvdata, u16 reg, u8 val)
+{
+	u8 cmd[3];
+	u8 addr_h = reg >> 8;
+	u8 addr_l = reg & 0xff;
+
+	cmd[0] = addr_h & MASK_ADDR_H;
+	cmd[0] &= ~ MASK_SEVE;
+	cmd[0] &= ~ MASK_WRITE;
+	cmd[1] = addr_l;
+	cmd[2] = val;
+	drvdata->tx_buffer = cmd;
+	drvdata->speed_hz = SPI_SPEED_HZ;
+
+	return lmk04828spi_sync_write(drvdata, 3);
+}
+
+static int lmk04828reg_read(struct lmk04828_t *drvdata, u16 reg, u8 *val)
+{
+	u8 cmd[3];
+	u8 addr_h = reg >> 8;
+	u8 addr_l = reg & 0xff;
+
+	cmd[0] = addr_h & MASK_ADDR_H;
+	cmd[0] &= ~MASK_SEVE;
+	cmd[0] |= MASK_READ;
+	cmd[1] = addr_l;
+	cmd[2] = 0;
+	drvdata->tx_buffer = cmd;
+	drvdata->rx_buffer = val;
+	drvdata->speed_hz = SPI_SPEED_HZ;
+
+	return spi_write_then_read(drvdata->spi, cmd, 2, val, 1);
+}
+
+static u8 lmk04828reg_read2(struct lmk04828_t *drvdata, u16 reg)
+{
+	u8 cmd[3];
+	int ret;
+
+	cmd[0] = 0x80 | (reg >> 8);
+	cmd[1] = reg & 0xff;
+	ret = spi_write_then_read(drvdata->spi, cmd, 2, &cmd[2], 1);
+	dev_dbg(&drvdata->spi->dev, "%s: REG: 0x%X VAL: 0x%X (%d)\n",
+		__func__, reg, cmd[2], ret);
+	if (ret < 0) {
+		dev_err(&drvdata->spi->dev, "%s: failed (%d)\n", __func__, ret);
+		return (u8)ret;
+	}
+
+	return cmd[2];
+}
+
+static int lmk04828pll2_init(struct lmk04828_t *drvdata, bool enable, int val)
+{
+	int ret1,ret2,ret3;
+
+	if (!enable) {
+		ret1 = lmk04828reg_write(drvdata, 0x168, val & 0xff);
+		ret2 = lmk04828reg_write(drvdata, 0x167, (val >> 8) & 0xff);
+		ret3 = lmk04828reg_write(drvdata, 0x166, (val >> 16) & 0x03);
+	} else {
+		ret1 = lmk04828reg_write(drvdata, 0x168, val & 0xff);
+		ret2 = lmk04828reg_write(drvdata, 0x167, (val >> 8) & 0xff);
+		ret3 = lmk04828reg_write(drvdata, 0x166, ((val >> 16) & 0x03) | 0x04);
+	}
+	if (ret1 >=0 && ret2 >=0 && ret3 >=0) {
+		return 0;
+	} else {
+		return -1;
+	}
+}
+
+static int lmk04828_init(struct lmk04828_t *drvdata)
+{
+	if (0 > lmk04828reg_write(drvdata, 0x000, 0x80)) {
+		return -1;
+	}
+	msleep(100);
+
+	/* PIN MUX SET */
+	if (0 > lmk04828reg_write(drvdata, 0x14A, 0x33)) {
+		return -1;
+	}
+
+	if (0 > lmk04828reg_write(drvdata, 0x000, 0x10)) {
+		return -1;
+	}
+	msleep(100);
+
+	if (!((0xD0 == lmk04828reg_read2(drvdata, 0x004)) && 
+		  (0x5B == lmk04828reg_read2(drvdata, 0x005)) && 
+		  (0x20 == lmk04828reg_read2(drvdata, 0x006)))) {
+		dev_err(&drvdata->spi->dev, "Initialization falied!\n");
+		return -1;
+	}
+	if (0 > lmk04828reg_write(drvdata, 0x116, 0x79)) {
+		return -1;
+	}
+	if (0 > lmk04828reg_write(drvdata, 0x11e, 0x79)) {
+		return -1;
+	}
+	if (0 > lmk04828reg_write(drvdata, 0x126, 0x79)) {
+		return -1;
+	}
+	if (0 > lmk04828reg_write(drvdata, 0x100, 0x00)) {
+		return -1;
+	}
+	if (0 > lmk04828reg_write(drvdata, 0x104, 0x20)) {
+		return -1;
+	}
+	if (0 > lmk04828reg_write(drvdata, 0x106, 0x70)) {
+		return -1;
+	}
+	if (0 > lmk04828reg_write(drvdata, 0x107, 0x33)) {
+		return -1;
+	}
+	if (0 > lmk04828reg_write(drvdata, 0x128, 0x00)) {
+		return -1;
+	}
+	if (0 > lmk04828reg_write(drvdata, 0x143, 0x10)) {
+		return -1;
+	}
+	if (0 > lmk04828reg_write(drvdata, 0x144, 0xff)) {
+		return -1;
+	}
+	if (0 > lmk04828reg_write(drvdata, 0x147, 0x38)) {
+		return -1;
+	}
+	if (0 > lmk04828reg_write(drvdata, 0x162, 0x45)) {
+		return -1;
+	}
+	if (0 > lmk04828reg_write(drvdata, 0x168, 0x0a)) {
+		return -1;
+	}
+
+	return 0;
+}
+
+/*------------------------------------------------------------------------------
+ * File ops
+ */
+
+static int lmk04828_open(struct inode *inode, struct file *fp)
+{
+	struct lmk04828_t *drvdata = NULL;
+
+	//TODO
+	// = container_of(inode->i_cdrvdata, struct lmk04828_t, cdev);
+	if (drvdata->devt != inode->i_rdev)
+		return -EINVAL;
+
+	nonseekable_open(inode, fp);
+
+	if (mutex_lock_interruptible(&drvdata->buf_lock)) {
+		return -ERESTARTSYS;
+	}
+
+	if (drvdata->users) {
+		mutex_unlock(&drvdata->buf_lock);
+		return -EINVAL;
+	}
+
+	fp->private_data = drvdata;
+
+	drvdata->cur_index = 0;
+	drvdata->users++;
+
+	mutex_unlock(&drvdata->buf_lock);
+	return 0;
+}
+
+static int lmk04828_release(struct inode *inode, struct file *fp)
+{
+	struct lmk04828_t *drvdata = fp->private_data;
+
+	if (drvdata->devt != inode->i_rdev)
+		return -EINVAL;
+
+	mutex_lock(&drvdata->buf_lock);
+	drvdata->users = 0;
+	mutex_unlock(&drvdata->buf_lock);
+	return 0;
+}
+
+static loff_t lmk04828_llseek(struct file *fp, loff_t off, int len)
+{
+	struct lmk04828_t *drvdata = fp->private_data;
+
+	mutex_lock(&drvdata->buf_lock);
+	drvdata->cur_index = off;
+	mutex_unlock(&drvdata->buf_lock);
+	return 0;
+}
+
+static ssize_t lmk04828_read(struct file *fp, char __user *buf,
+		size_t size, loff_t *off)
+{
+	u8 kbuf[1];
+	struct lmk04828_t *drvdata = fp->private_data;
+
+	mutex_lock(&drvdata->buf_lock);
+	lmk04828reg_read(drvdata, drvdata->cur_index, kbuf);
+	mutex_unlock(&drvdata->buf_lock);
+
+	return copy_to_user(buf, kbuf, 1);
+}
+
+static ssize_t lmk04828_write(struct file *fp, const char __user *buf,
+		size_t size, loff_t  *off)
+{
+	u8 kbuf[1];
+	int ret;
+	struct lmk04828_t *drvdata = fp->private_data;
+
+	ret = copy_from_user(kbuf, buf, 1);
+	if (ret < 0) {
+		dev_err(&drvdata->spi->dev, "%s: copy_from_user failed %d\n", __func__, ret);
+		return -1;
+	}
+
+	mutex_lock(&drvdata->buf_lock);
+	ret = lmk04828reg_write(drvdata, drvdata->cur_index, kbuf[0]);
+	mutex_unlock(&drvdata->buf_lock);
+	return ret;
+}
+
+static long lmk04828_ioctl(struct file *fp, unsigned int cmd,
+		unsigned long arg)
+{
+	struct lmk04828_t *drvdata = fp->private_data;
+
+	switch(cmd) {
+	case GET_REG:
+		break;
+	case SET_REG:
+		break;
+	default:
+		dev_err(&drvdata->spi->dev, "invalid argument\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static struct file_operations fops = {
+	.owner			= THIS_MODULE,
+	.open			= lmk04828_open,
+	.release		= lmk04828_release,
+	.read			= lmk04828_read,
+	.write			= lmk04828_write,
+	.llseek			= lmk04828_llseek,
+	.unlocked_ioctl	= lmk04828_ioctl,
+};
+
+/*------------------------------------------------------------------------------
+ * init and deinit
+ */
+
+static int lmk04828_probe(struct spi_device *spi)
+{
+	struct lmk04828_t *drvdata;
+	struct device_node *np;
+	int ret;
+
+	dev_info(&spi->dev, "%s: enter\n", __func__);
+
+	/* Allocate driver data */
+	drvdata = kzalloc(sizeof(*drvdata), GFP_KERNEL);
+	if (!drvdata)
+		return -ENOMEM;
+
+	/* Initialize the driver data */
+	drvdata->spi = spi;
+	drvdata->speed_hz = SPI_SPEED_HZ;
+	spin_lock_init(&drvdata->spi_lock);
+	mutex_init(&drvdata->buf_lock);
+	INIT_LIST_HEAD(&drvdata->device_entry);
+	drvdata->misc_dev.fops = &fops;
+	drvdata->misc_dev.name = "lmk04828";
+	drvdata->misc_dev.minor = MISC_DYNAMIC_MINOR;
+
+	misc_register(&drvdata->misc_dev);
+
+#ifdef CONFIG_OF
+#if 0
+	np = of_find_node_by_name(NULL, "clkgen");
+	if (NULL == np) {
+		dev_err(&spi->dev, "device-tree: node 'lmk04828' not find\n");
+		return -EINVAL;
+	}
+	u32 tmp;
+	ret = of_property_read_u32_index(np, "pl-cs-addr", 0, &tmp);
+	if (ret < 0) {
+		dev_err(&spi->dev, "device-tree: property 'pl-cs-addr' not find\n");
+		return -EINVAL;
+	}
+	drvdata->pl_cs_addr = ioremap(tmp, 4);
+	ret = of_property_read_u32_index(np, "pl-cs-val", 0, &drvdata->pl_cs_val);
+	if (ret < 0) {
+		dev_err(&spi->dev, "device-tree: property 'pl-cs-val' not find\n");
+		return -EINVAL;
+	}
+	dev_info(&spi->dev, "device-tree: pl-cs-addr=%x(ioremap %p), pl-cs-val=%x\n",
+		tmp, drvdata->pl_cs_addr, drvdata->pl_cs_val);
+	iowrite32(drvdata->pl_cs_val, drvdata->pl_cs_addr);
+#endif
+#endif
+
+	spi_set_drvdata(spi, drvdata);
+
+	ret = lmk04828_init(drvdata);
+	if (ret < 0) {
+		dev_err(&spi->dev, "%s: init failed due to spi access!\n", __func__);
+		return -ENODEV;
+	}
+
+	dev_info(&spi->dev, "%s: succeed\n", __func__);
+	return 0;
+}
+
+static int lmk04828_remove(struct spi_device *spi)
+{
+	struct lmk04828_t *drvdata = spi_get_drvdata(spi);
+	misc_deregister(&drvdata->misc_dev);
+	kfree(drvdata);
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id lmk04828_dt_ids[] = {
+	{ .compatible = "ti,lmk04828" },
+	{ }
+};
+#endif
+
+static const struct spi_device_id lmk04828_hw_ids[] = {
+	{ "lmk04828", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(spi, lmk04828_id_table);
+
+static struct spi_driver lmk04828_driver = {
+	.driver = {
+		.name	= "lmk04828",
+		.owner = THIS_MODULE,
+#ifdef CONFIG_OF
+		.of_match_table = of_match_ptr(lmk04828_dt_ids),
+#endif
+	},
+	.probe		= lmk04828_probe,
+	.remove 	= lmk04828_remove,
+	.id_table	= lmk04828_hw_ids,
+};
+
+module_spi_driver(lmk04828_driver);
+MODULE_ALIAS("lmk04828-spi");
+MODULE_AUTHOR("Thomas Chou <thomas@wytron.com.tw>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/misc/ti_lmk04828org.c b/drivers/misc/ti_lmk04828org.c
new file mode 100644
index 0000000..fe95684
--- /dev/null
+++ b/drivers/misc/ti_lmk04828org.c
@@ -0,0 +1,420 @@
+/*
+ * https://blog.csdn.net/u010243305/article/details/78426058
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/spidev.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/acpi.h>
+#include <linux/miscdevice.h>
+#include <linux/cdev.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <asm/current.h>
+#include <linux/sched.h>
+#include <linux/uaccess.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/unistd.h>
+
+#define MASK_WRITE  0x80
+#define MASK_READ   0x80
+#define MASK_SEVE   0x60
+#define MASK_ADDR_H     0x1F
+#define SPI_SPEED_HZ    200000
+#define LMK04828_MAGIC  'K'
+#define GET_REG _IOR(LMK04828_MAGIC, 0, int)
+#define SET_REG _IOW(LMK04828_MAGIC, 0, int)
+
+struct lmk04828_t {
+    dev_t devt;
+    struct miscdevice misc_dev;
+    spinlock_t spi_lock;
+    struct spi_device *spi;
+    struct list_head device_entry;
+
+    /* TX/RX buffers are NULL unless opened (users > 0) */
+    struct mutex buf_lock;
+    unsigned int users;
+    u8 *tx_buffer;
+    u8 *rx_buffer;
+    u32 speed_hz;
+    u32 cur_index;  /* record the register offset */
+    void __iomem *pl_cs_addr;
+    u32 pl_cs_val;
+};
+static struct lmk04828_t *drvdata;
+
+void lmk04828spi_cs(struct lmk04828_t *drvdata)
+{
+#if 0
+    iowrite32(drvdata->pl_cs_val, drvdata->pl_cs_addr);
+#endif
+}
+
+static ssize_t lmk04828spi_sync(struct lmk04828_t *drvdata, struct spi_message *m)
+{
+    DECLARE_COMPLETION_ONSTACK(done);
+    int ret;
+	struct spi_device *spi = drvdata->spi;
+
+    if (spi == NULL) return -ESHUTDOWN;
+
+    lmk04828spi_cs(drvdata);
+
+	ret = spi_sync(spi, m);
+    if (ret != 0)
+		return ret;
+	return m->actual_length;
+}
+
+static ssize_t lmk04828spi_sync_write(struct lmk04828_t *drvdata, size_t len)
+{
+    struct spi_transfer t = {
+		.tx_buf     = drvdata->tx_buffer,
+		.len        = len,
+		.speed_hz   = drvdata->speed_hz,
+	};
+    struct spi_message m;
+
+    spi_message_init(&m);
+    spi_message_add_tail(&t, &m);
+    return lmk04828spi_sync(drvdata, &m);
+}
+
+static ssize_t lmk04828spi_sync_read(struct lmk04828_t *drvdata, size_t len)
+{
+    struct spi_transfer t = {
+		.rx_buf     = drvdata->rx_buffer,
+		.len        = len,
+		.speed_hz   = drvdata->speed_hz,
+	};
+    struct spi_message m;
+
+    spi_message_init(&m);
+    spi_message_add_tail(&t, &m);
+    return lmk04828spi_sync(drvdata, &m);
+}
+
+int lmk04828_write_reg(int reg, u8 value)
+{
+    u8 cmd[3]={0};
+    u8 addr_h = reg >> 8;
+    u8 addr_l = reg & 0xff;
+
+    cmd[0] = addr_h & MASK_ADDR_H;
+    cmd[0] &= ~ MASK_SEVE;
+    cmd[0] &= ~ MASK_WRITE;
+    cmd[1] = addr_l;
+    cmd[2] = value;
+    drvdata->tx_buffer = cmd;
+    drvdata->speed_hz = SPI_SPEED_HZ;
+
+    return lmk04828spi_sync_write(drvdata, 3);
+}
+
+int lmk04828_read_reg(int reg, u8 buff[1])
+{
+    u8 cmd[3]={0};
+    u8 addr_h = reg >> 8;
+    u8 addr_l = reg & 0xff;
+
+    cmd[0] = addr_h & MASK_ADDR_H;
+    cmd[0] &= ~ MASK_SEVE;
+    cmd[0] |=  MASK_READ;
+    cmd[1] = addr_l;
+    cmd[2] = 0;
+    drvdata->tx_buffer = cmd;
+    drvdata->rx_buffer = buff;
+    drvdata->speed_hz = SPI_SPEED_HZ;
+
+    return spi_write_then_read(drvdata->spi, cmd,2, buff, 1);
+}
+
+int lmk04828_spi_read(unsigned reg)
+{
+	u8 buf[3];
+	int ret;
+
+	buf[0] = 0x80 | (reg >> 8);
+	buf[1] = reg & 0xFF;
+	ret = spi_write_then_read(drvdata->spi, &buf[0], 2, &buf[2], 1);
+	dev_dbg(&drvdata->spi->dev, "%s: REG: 0x%X VAL: 0x%X (%d)\n",
+		__func__, reg, buf[2], ret);
+	if (ret < 0) {
+		dev_err(&drvdata->spi->dev, "%s: failed (%d)\n", __func__, ret);
+		return ret;
+	}
+
+	return buf[2];
+}
+
+int lmk04828_reg_pll2_n(char enable, unsigned int val)
+{
+    int ret1,ret2,ret3;
+
+    if (!enable) {
+        ret1 = lmk04828_write_reg(0x168, val & 0xff);
+        ret2 = lmk04828_write_reg(0x167, (val >> 8) & 0xff);
+        ret3 = lmk04828_write_reg(0x166, (val >> 16) & 0x03 );
+    } else {
+        ret1 = lmk04828_write_reg(0x168, val & 0xff);
+        ret2 = lmk04828_write_reg(0x167, (val >> 8) & 0xff);
+        ret3 = lmk04828_write_reg(0x166, ((val >> 16) & 0x03) | 0x04 );
+    }
+    if (ret1 >=0 && ret2 >=0 && ret3 >=0) {
+        return 0;
+    } else {
+        return -1;
+    }
+}
+
+int lmk04828_reg_init(void)
+{
+    if (0 > lmk04828_write_reg(0, 0x80)) {
+        return -1;
+    }
+    msleep(100);
+
+    /* PIN MUX SET */
+    if (0 > lmk04828_write_reg(0x14A, 0X33)) {
+        return -1;
+    }
+
+    if (0 > lmk04828_write_reg(0, 0x10)) {
+        return -1;
+    }
+    msleep(100);
+
+    if (!((0xD0 == lmk04828_spi_read(0x004)) && 
+          (0x5B == lmk04828_spi_read(0x005)) && 
+          (0x20 == lmk04828_spi_read(0x006)))) {
+        dev_err(&drvdata->spi->dev, "Initialization falied!\n");
+        return -1;
+    }
+    if (0 > lmk04828_write_reg(0x116, 0x79)) {
+        return -1;
+    }
+    if (0 > lmk04828_write_reg(0x11e, 0x79)) {
+        return -1;
+    }
+    if (0 > lmk04828_write_reg(0x126, 0x79)) {
+        return -1;
+    }
+    if (0 > lmk04828_write_reg(0x100, 0)) {
+        return -1;
+    }
+    if (0 > lmk04828_write_reg(0x104, 0x20)) {
+        return -1;
+    }
+    if (0 > lmk04828_write_reg(0x106, 0x70)) {
+        return -1;
+    }
+    if (0 > lmk04828_write_reg(0x107, 0x33)) {
+        return -1;
+    }
+    if (0 > lmk04828_write_reg(0x128, 0)) {
+        return -1;
+    }
+    if (0 > lmk04828_write_reg(0x143, 0x10)) {
+        return -1;
+    }
+    if (0 > lmk04828_write_reg(0x144, 0xff)) {
+        return -1;
+    }
+    if (0 > lmk04828_write_reg(0x147, 0x38)) {
+        return -1;
+    }
+    if (0 > lmk04828_write_reg(0x162, 0x45)) {
+        return -1;
+    }
+    if (0 > lmk04828_write_reg(0x168, 0x0a)) {
+        return -1;
+    }
+
+    return 0;
+}
+
+/*------------------------------------------------------------------------------
+ * File ops
+ */
+
+static int lmk04828_open(struct inode *inode, struct file *fp)
+{
+    return 0;
+}
+
+static int lmk04828_release(struct inode *inode, struct file *fp)
+{
+    return 0;
+}
+
+static loff_t lmk04828_llseek(struct file *fp, loff_t off, int len)
+{
+    drvdata->cur_index = off;
+    return 0;
+}
+
+static ssize_t lmk04828_read(struct file *fp, char __user *buf,
+		size_t size, loff_t *off)
+{
+    u8 kbuf[1]={0};
+
+    mutex_lock(&drvdata->buf_lock);
+    lmk04828_read_reg(drvdata->cur_index, kbuf);
+    mutex_unlock(&drvdata->buf_lock);
+
+    return copy_to_user(buf, kbuf, 1);
+}
+
+static ssize_t lmk04828_write(struct file *fp, const char __user *buf,
+        size_t size, loff_t  *off)
+{
+    u8 kbuf[1] = { 0 };
+    int ret = 0;
+
+	if (0 > copy_from_user(kbuf, buf, 1)) {
+        dev_err(&drvdata->spi->dev, "copy_from_user error %s %d\n", __func__, __LINE__);
+		return -1;
+    }
+
+    mutex_lock(&drvdata->buf_lock);
+    ret = lmk04828_write_reg(drvdata->cur_index, kbuf[0]);
+    mutex_unlock(&drvdata->buf_lock);
+    return ret;
+}
+
+static long lmk04828_ioctl(struct file *fp, unsigned int cmd,
+		unsigned long arg)
+{
+    switch(cmd) {
+    case GET_REG:
+		break;
+    case SET_REG:
+		break;
+    default:
+		dev_err(&drvdata->spi->dev, "invalid argument\n");
+		return -EINVAL;
+    }
+
+    return 0;
+}
+
+static struct file_operations fops = {
+    .owner			= THIS_MODULE,
+    .open			= lmk04828_open,
+    .release		= lmk04828_release,
+    .read			= lmk04828_read,
+    .write			= lmk04828_write,
+    .llseek			= lmk04828_llseek,
+    .unlocked_ioctl	= lmk04828_ioctl,
+};
+
+/*------------------------------------------------------------------------------
+ * init and deinit
+ */
+
+static int lmk04828_probe(struct spi_device *spi)
+{
+    //struct lmk04828_t *drvdata;
+    struct device_inode *np;
+	int ret;
+
+    dev_info(&spi->dev, "%s: enter\n", __func__);
+
+    /* Allocate driver data */
+    drvdata = kzalloc(sizeof(*drvdata), GFP_KERNEL);
+    if (!drvdata)
+        return -ENOMEM;
+
+    /* Initialize the driver data */
+    drvdata->spi = spi;
+    drvdata->speed_hz = SPI_SPEED_HZ;
+    spin_lock_init(&drvdata->spi_lock);
+    mutex_init(&drvdata->buf_lock);
+    INIT_LIST_HEAD(&drvdata->device_entry);
+    drvdata->misc_dev.fops = &fops;
+    drvdata->misc_dev.name = "lmk04828";
+    drvdata->misc_dev.minor = MISC_DYNAMIC_MINOR;
+
+    misc_register(&drvdata->misc_dev);
+
+#ifdef CONFIG_OF
+    np = of_find_inode_by_name(NULL, "lmk04828-spi");
+    if (NULL == np) {
+        dev_err(&spi->dev, "device-tree: inode 'lmk04828-spi' not find\n");
+        return -EINVAL;
+    }
+#if 0
+	u32 tmp;
+	ret = of_property_read_u32_index(np, "pl-cs-addr", 0, &tmp);
+    if (ret < 0) {
+		dev_err(&spi->dev, "device-tree: property 'pl-cs-addr' not find\n");
+		return -EINVAL;
+	}
+	drvdata->pl_cs_addr = ioremap(tmp, 4);
+	ret = of_property_read_u32_index(np, "pl-cs-val", 0, &drvdata->pl_cs_val);
+	if (ret < 0) {
+        dev_err(&spi->dev, "device-tree: property 'pl-cs-val' not find\n");
+		return -EINVAL;
+    }
+    dev_info(&spi->dev, "device-tree: pl-cs-addr=%x(ioremap %p), pl-cs-val=%x\n",
+		tmp, drvdata->pl_cs_addr, drvdata->pl_cs_val);
+	iowrite32(drvdata->pl_cs_val, drvdata->pl_cs_addr);
+#endif
+#endif
+
+	spi_set_drvdata(spi, drvdata);
+
+    ret = lmk04828_reg_init();
+	if (ret < 0) {
+		dev_err(&spi->dev, "%s: init failed due to spi access!\n", __func__);
+		return -ENODEV;
+	}
+
+    dev_info(&spi->dev, "%s: succeed\n", __func__);
+    return 0;
+}
+
+static int lmk04828_remove(struct spi_device *spi)
+{
+    struct lmk04828_t *drvdata = spi_get_drvdata(spi);
+    misc_deregister(&drvdata->misc_dev);
+	kfree(drvdata);
+    return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id lmk04828_of_match[] = {
+    { .compatible = "ti,lmk04828" },
+    { }
+};
+#endif
+
+static const struct spi_device_id lmk04828_id_table[] = {
+    { "lmk04828", 0 },
+    { }
+};
+MODULE_DEVICE_TABLE(spi, lmk04828_id_table);
+
+static struct spi_driver lmk04828_driver = {
+    .driver = {
+        .name   = "lmk04828",
+        .owner = THIS_MODULE,
+#ifdef CONFIG_OF
+        .of_match_table = of_match_ptr(lmk04828_of_match),
+#endif
+    },
+    .probe      = lmk04828_probe,
+    .remove     = lmk04828_remove,
+    .id_table   = lmk04828_id_table,
+};
+
+module_spi_driver(lmk04828_driver);
+MODULE_ALIAS("lmk04828-spi");
+MODULE_AUTHOR("Thomas Chou <thomas@wytron.com.tw>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/net/ethernet/altera/altera_tse.h b/drivers/net/ethernet/altera/altera_tse.h
index e005200..446e778 100644
--- a/drivers/net/ethernet/altera/altera_tse.h
+++ b/drivers/net/ethernet/altera/altera_tse.h
@@ -120,6 +120,17 @@
 #define MAC_CMDCFG_DISABLE_READ_TIMEOUT_GET(v)	GET_BIT_VALUE(v, 27)
 #define MAC_CMDCFG_CNT_RESET_GET(v)		GET_BIT_VALUE(v, 31)
 
+/* SGMII PCS register addresses
+ */
+#define SGMII_PCS_SCRATCH	0x10
+#define SGMII_PCS_REV		0x11
+#define SGMII_PCS_LINK_TIMER_0	0x12
+#define SGMII_PCS_LINK_TIMER_1	0x13
+#define SGMII_PCS_IF_MODE	0x14
+#define SGMII_PCS_DIS_READ_TO	0x15
+#define SGMII_PCS_READ_TO	0x16
+#define SGMII_PCS_SW_RESET_TIMEOUT 100 /* usecs */
+
 /* MDIO registers within MAC register Space
  */
 struct altera_tse_mdio {
diff --git a/drivers/net/ethernet/altera/altera_tse_main.c b/drivers/net/ethernet/altera/altera_tse_main.c
index a0eee72..373f3e0 100644
--- a/drivers/net/ethernet/altera/altera_tse_main.c
+++ b/drivers/net/ethernet/altera/altera_tse_main.c
@@ -27,7 +27,13 @@
  * You should have received a copy of the GNU General Public License along with
  * this program.  If not, see <http://www.gnu.org/licenses/>.
  */
+/*
+ * 2018-05-28: upgrade with kernel 4.16.12
+ *   https://elixir.bootlin.com/linux/latest/source/drivers/net/ethernet/altera
+ */
 
+#define A10AD9371FOXCONN_TSEMAC_DBG
+#define DEBUG 1
 #include <linux/atomic.h>
 #include <linux/delay.h>
 #include <linux/etherdevice.h>
@@ -96,6 +102,35 @@ static inline u32 tse_tx_avail(struct altera_tse_private *priv)
 	return priv->tx_cons + priv->tx_ring_size - priv->tx_prod - 1;
 }
 
+/* PCS Register read/write functions
+ */
+static u16 sgmii_pcs_read(struct altera_tse_private *priv, int regnum)
+{
+	/* set MDIO address */
+    csrwr32(0,               priv->mac_dev, tse_csroffs(mdio_phy0_addr));
+	//csrwr32((mii_id & 0x1f), priv->mac_dev, tse_csroffs(mdio_phy0_addr));
+
+	return csrrd32(priv->mac_dev,
+		       tse_csroffs(mdio_phy0) + regnum * 4) & 0xffff;
+}
+
+static void sgmii_pcs_write(struct altera_tse_private *priv, int regnum,
+				u16 value)
+{
+	/* set MDIO address */
+    csrwr32(0,               priv->mac_dev, tse_csroffs(mdio_phy0_addr));
+	//csrwr32((mii_id & 0x1f), priv->mac_dev, tse_csroffs(mdio_phy0_addr));
+
+	csrwr32(value, priv->mac_dev, tse_csroffs(mdio_phy0) + regnum * 4);
+}
+
+/* Check PCS scratch memory */
+static int sgmii_pcs_scratch_test(struct altera_tse_private *priv, u16 value)
+{
+	sgmii_pcs_write(priv, SGMII_PCS_SCRATCH, value);
+	return (sgmii_pcs_read(priv, SGMII_PCS_SCRATCH) == value);
+}
+
 /* MDIO specific functions
  */
 static int altera_tse_mdio_read(struct mii_bus *bus, int mii_id, int regnum)
@@ -604,6 +639,7 @@ static int tse_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	return ret;
 }
 
+static int init_sgmii_pcs(struct net_device *dev);
 /* Called every time the controller might need to be made
  * aware of new link state.  The PHY code conveys this
  * information through variables in the phydev structure, and this
@@ -622,6 +658,9 @@ static void altera_tse_adjust_link(struct net_device *dev)
 		/* Read old config */
 		u32 cfg_reg = ioread32(&priv->mac_dev->command_config);
 
+        pr_info("%s: duplex (%d, %d) speed (%d, %d)\n",
+			__func__, phydev->duplex, priv->oldduplex, phydev->speed,priv->oldspeed);
+
 		/* Check duplex */
 		if (phydev->duplex != priv->oldduplex) {
 			new_state = 1;
@@ -665,6 +704,9 @@ static void altera_tse_adjust_link(struct net_device *dev)
 		if (!priv->oldlink) {
 			new_state = 1;
 			priv->oldlink = 1;
+#if 0
+            init_sgmii_pcs(dev);
+#endif
 		}
 	} else if (priv->oldlink) {
 		new_state = 1;
@@ -931,7 +973,7 @@ static int init_mac(struct altera_tse_private *priv)
 	/* Disable RX/TX shift 16 for alignment of all received frames on 16-bit
 	 * start address
 	 */
-	tse_set_bit(priv->mac_dev, tse_csroffs(rx_cmd_stat),
+	tse_clear_bit(priv->mac_dev, tse_csroffs(rx_cmd_stat),
 		    ALTERA_TSE_RX_CMD_STAT_RX_SHIFT16);
 
 	tse_clear_bit(priv->mac_dev, tse_csroffs(tx_cmd_stat),
@@ -1082,6 +1124,86 @@ static void tse_set_rx_mode(struct net_device *dev)
 	spin_unlock(&priv->mac_cfg_lock);
 }
 
+/* Initialise (if necessary) the SGMII PCS component
+  1. External PHY Initialization using MDIO
+  2. PCS Configuration Register Initialization
+  a. Set Auto Negotiation Link Timer to 1.6ms for SGMII
+    link_timer (address 0x12) = 0x0D40
+    Link_timer (address 0x13) = 0x03
+  b. Enable SGMII Interface and Enable SGMII Auto Negotiation
+    SGMII_ENA = 1, USE_SGMII_AN = 1
+    if_mode = 0x0003
+  c. Enable PCS Auto Negotiation
+    AUTO_NEGOTIATION_ENA = 1, Bit 6,8,13 can be ignore
+    PCS Control Register = 0x1140
+  d. PCS SW-Reset/Bit15 is recommended after any confguration changed
+    PCS Control Register = 0x1140 | 0x8000;
+    Wait PCS Control Register RESET bit is clear
+  3, MAC configuration Register Initialization
+ */
+static int init_sgmii_pcs(struct net_device *dev)
+{
+	struct altera_tse_private *priv = netdev_priv(dev);
+	int n;
+	unsigned int tmp_reg = 0;
+
+	if (priv->phy_iface != PHY_INTERFACE_MODE_SGMII)
+		return 0; /* Nothing to do, not in SGMII mode */
+
+	/* The TSE SGMII PCS block looks a little like a PHY, it is
+	 * mapped into the zeroth MDIO space of the MAC and it has
+	 * ID registers like a PHY would.  Sadly this is often
+	 * configured to zeroes, so don't be surprised if it does
+	 * show 0x00000000.
+	 */
+
+	if (sgmii_pcs_scratch_test(priv, 0x0000) &&
+		sgmii_pcs_scratch_test(priv, 0xffff) &&
+		sgmii_pcs_scratch_test(priv, 0xa5a5) &&
+		sgmii_pcs_scratch_test(priv, 0x5a5a)) {
+		netdev_info(dev, "PCS PHY ID: 0x%04x%04x\n",
+				sgmii_pcs_read(priv, MII_PHYSID1),
+				sgmii_pcs_read(priv, MII_PHYSID2));
+	} else {
+		netdev_err(dev, "SGMII PCS Scratch memory test failed.\n");
+		return -ENOMEM;
+	}
+
+	/* Starting on page 5-29 of the MegaCore Function User Guide
+	 * Set SGMII Link timer to 1.6ms
+	 */
+	sgmii_pcs_write(priv, SGMII_PCS_LINK_TIMER_0, 0x0D40);
+	sgmii_pcs_write(priv, SGMII_PCS_LINK_TIMER_1, 0x03);
+
+	/* Enable SGMII Interface and Enable SGMII Auto Negotiation */
+	sgmii_pcs_write(priv, SGMII_PCS_IF_MODE, 0x3);
+
+	/* Enable Autonegotiation */
+	tmp_reg = sgmii_pcs_read(priv, MII_BMCR);
+	tmp_reg |= (BMCR_SPEED1000 | BMCR_FULLDPLX | BMCR_ANENABLE);
+	sgmii_pcs_write(priv, MII_BMCR, tmp_reg);
+
+	/* Reset PCS block */
+	tmp_reg |= BMCR_RESET;
+	sgmii_pcs_write(priv, MII_BMCR, tmp_reg);
+	n = SGMII_PCS_SW_RESET_TIMEOUT;
+	do {
+#if 0
+		if (tse_bit_is_clear(priv->mac_dev, tse_csroffs(mdio_phy0.control), BIT(15))) {
+#else
+		if (!(sgmii_pcs_read(priv, MII_BMCR) & BMCR_RESET)) {
+#endif
+			netdev_info(dev, "SGMII PCS block initialised OK\n");
+			return 0;
+		}
+		udelay(1);
+	} while (n--);
+
+	/* We failed to reset the block, return a timeout */
+	netdev_err(dev, "SGMII PCS block reset failed.\n");
+	return -ETIMEDOUT;
+}
+
 /* Open and initialize the interface
  */
 static int tse_open(struct net_device *dev)
@@ -1106,6 +1228,16 @@ static int tse_open(struct net_device *dev)
 		netdev_warn(dev, "TSE revision %x\n", priv->revision);
 
 	spin_lock(&priv->mac_cfg_lock);
+
+	/* no-op if MAC not operating in SGMII mode*/
+	ret = init_sgmii_pcs(dev);
+	if (ret) {
+		netdev_err(dev,
+			   "Cannot init the SGMII PCS (error: %d)\n", ret);
+		spin_unlock(&priv->mac_cfg_lock);
+		goto phy_error;
+	}
+
 	ret = reset_mac(priv);
 	/* Note that reset_mac will fail if the clocks are gated by the PHY
 	 * due to the PHY being put into isolation or power down mode.
@@ -1153,8 +1285,10 @@ static int tse_open(struct net_device *dev)
 
 	/* Enable DMA interrupts */
 	spin_lock_irqsave(&priv->rxdma_irq_lock, flags);
+#if !defined(A10AD9371FOXCONN_TSEMAC_DBG)
 	priv->dmaops->enable_rxirq(priv);
 	priv->dmaops->enable_txirq(priv);
+#endif
 
 	/* Setup RX descriptor chain */
 	for (i = 0; i < priv->rx_ring_size; i++)
@@ -1236,7 +1370,9 @@ static int tse_shutdown(struct net_device *dev)
 static struct net_device_ops altera_tse_netdev_ops = {
 	.ndo_open		= tse_open,
 	.ndo_stop		= tse_shutdown,
+#if !defined(A10AD9371FOXCONN_TSEMAC_DBG)
 	.ndo_start_xmit		= tse_start_xmit,
+#endif
 	.ndo_set_mac_address	= eth_mac_addr,
 	.ndo_set_rx_mode	= tse_set_rx_mode,
 	.ndo_change_mtu		= tse_change_mtu,
@@ -1251,7 +1387,7 @@ static int request_and_map(struct platform_device *pdev, const char *name,
 
 	*res = platform_get_resource_byname(pdev, IORESOURCE_MEM, name);
 	if (*res == NULL) {
-		dev_err(device, "resource %s not defined\n", name);
+		dev_err(device, "devicetree: resource %s not defined\n", name);
 		return -ENODEV;
 	}
 
@@ -1285,6 +1421,7 @@ static int altera_tse_probe(struct platform_device *pdev)
 	void __iomem *descmap;
 	const struct of_device_id *of_id = NULL;
 
+	dev_info(&pdev->dev, "%s: enter", __func__);
 	ndev = alloc_etherdev(sizeof(struct altera_tse_private));
 	if (!ndev) {
 		dev_err(&pdev->dev, "Could not allocate network device\n");
@@ -1328,11 +1465,13 @@ static int altera_tse_probe(struct platform_device *pdev)
 		if (upper_32_bits(priv->rxdescmem_busaddr)) {
 			dev_dbg(priv->device,
 				"SGDMA bus addresses greater than 32-bits\n");
+			ret = -EINVAL;
 			goto err_free_netdev;
 		}
 		if (upper_32_bits(priv->txdescmem_busaddr)) {
 			dev_dbg(priv->device,
 				"SGDMA bus addresses greater than 32-bits\n");
+			ret = -EINVAL;
 			goto err_free_netdev;
 		}
 	} else if (priv->dmaops &&
@@ -1518,6 +1657,18 @@ static int altera_tse_probe(struct platform_device *pdev)
 		netdev_err(ndev, "Cannot attach to PHY (error: %d)\n", ret);
 		goto err_init_phy;
 	}
+
+#if defined(A10AD9371FOXCONN_TSEMAC_DBG)
+    ndev->flags |= IFF_PROMISC;
+    tse_open(ndev);
+    if (priv->hash_filter) {
+        tse_set_rx_mode_hashfilter(ndev);
+    } else {
+        tse_set_rx_mode(ndev);
+    }
+#endif
+
+	dev_info(&pdev->dev, "%s: succeed", __func__);
 	return 0;
 
 err_init_phy:
@@ -1537,6 +1688,8 @@ static int altera_tse_remove(struct platform_device *pdev)
 	struct net_device *ndev = platform_get_drvdata(pdev);
 	struct altera_tse_private *priv = netdev_priv(ndev);
 
+    tse_shutdown(ndev);
+
 	if (ndev->phydev) {
 		phy_disconnect(ndev->phydev);
 
diff --git a/drivers/net/ethernet/altera/altera_tse_main_4d16d12.c b/drivers/net/ethernet/altera/altera_tse_main_4d16d12.c
new file mode 100644
index 0000000..527908c
--- /dev/null
+++ b/drivers/net/ethernet/altera/altera_tse_main_4d16d12.c
@@ -0,0 +1,1701 @@
+/* Altera Triple-Speed Ethernet MAC driver
+ * Copyright (C) 2008-2014 Altera Corporation. All rights reserved
+ *
+ * Contributors:
+ *   Dalon Westergreen
+ *   Thomas Chou
+ *   Ian Abbott
+ *   Yuriy Kozlov
+ *   Tobias Klauser
+ *   Andriy Smolskyy
+ *   Roman Bulgakov
+ *   Dmytro Mytarchuk
+ *   Matthew Gerlach
+ *
+ * Original driver contributed by SLS.
+ * Major updates contributed by GlobalLogic
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/atomic.h>
+#include <linux/delay.h>
+#include <linux/etherdevice.h>
+#include <linux/if_vlan.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mii.h>
+#include <linux/netdevice.h>
+#include <linux/of_device.h>
+#include <linux/of_mdio.h>
+#include <linux/of_net.h>
+#include <linux/of_platform.h>
+#include <linux/phy.h>
+#include <linux/platform_device.h>
+#include <linux/skbuff.h>
+#include <asm/cacheflush.h>
+
+#include "altera_utils.h"
+#include "altera_tse.h"
+#include "altera_sgdma.h"
+#include "altera_msgdma.h"
+
+static atomic_t instance_count = ATOMIC_INIT(~0);
+/* Module parameters */
+static int debug = -1;
+module_param(debug, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(debug, "Message Level (-1: default, 0: no output, 16: all)");
+
+static const u32 default_msg_level = (NETIF_MSG_DRV | NETIF_MSG_PROBE |
+					NETIF_MSG_LINK | NETIF_MSG_IFUP |
+					NETIF_MSG_IFDOWN);
+
+#define RX_DESCRIPTORS 64
+static int dma_rx_num = RX_DESCRIPTORS;
+module_param(dma_rx_num, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(dma_rx_num, "Number of descriptors in the RX list");
+
+#define TX_DESCRIPTORS 64
+static int dma_tx_num = TX_DESCRIPTORS;
+module_param(dma_tx_num, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(dma_tx_num, "Number of descriptors in the TX list");
+
+
+#define POLL_PHY (-1)
+
+/* Make sure DMA buffer size is larger than the max frame size
+ * plus some alignment offset and a VLAN header. If the max frame size is
+ * 1518, a VLAN header would be additional 4 bytes and additional
+ * headroom for alignment is 2 bytes, 2048 is just fine.
+ */
+#define ALTERA_RXDMABUFFER_SIZE	2048
+
+/* Allow network stack to resume queueing packets after we've
+ * finished transmitting at least 1/4 of the packets in the queue.
+ */
+#define TSE_TX_THRESH(x)	(x->tx_ring_size / 4)
+
+#define TXQUEUESTOP_THRESHHOLD	2
+
+static const struct of_device_id altera_tse_ids[];
+
+static inline u32 tse_tx_avail(struct altera_tse_private *priv)
+{
+	return priv->tx_cons + priv->tx_ring_size - priv->tx_prod - 1;
+}
+
+/* PCS Register read/write functions
+ */
+static u16 sgmii_pcs_read(struct altera_tse_private *priv, int regnum)
+{
+	return csrrd32(priv->mac_dev,
+		       tse_csroffs(mdio_phy0) + regnum * 4) & 0xffff;
+}
+
+static void sgmii_pcs_write(struct altera_tse_private *priv, int regnum,
+				u16 value)
+{
+	csrwr32(value, priv->mac_dev, tse_csroffs(mdio_phy0) + regnum * 4);
+}
+
+/* Check PCS scratch memory */
+static int sgmii_pcs_scratch_test(struct altera_tse_private *priv, u16 value)
+{
+	sgmii_pcs_write(priv, SGMII_PCS_SCRATCH, value);
+	return (sgmii_pcs_read(priv, SGMII_PCS_SCRATCH) == value);
+}
+
+/* MDIO specific functions
+ */
+static int altera_tse_mdio_read(struct mii_bus *bus, int mii_id, int regnum)
+{
+	struct net_device *ndev = bus->priv;
+	struct altera_tse_private *priv = netdev_priv(ndev);
+
+	/* set MDIO address */
+	csrwr32((mii_id & 0x1f), priv->mac_dev,
+		tse_csroffs(mdio_phy1_addr));
+
+	/* get the data */
+	return csrrd32(priv->mac_dev,
+		       tse_csroffs(mdio_phy1) + regnum * 4) & 0xffff;
+}
+
+static int altera_tse_mdio_write(struct mii_bus *bus, int mii_id, int regnum,
+				 u16 value)
+{
+	struct net_device *ndev = bus->priv;
+	struct altera_tse_private *priv = netdev_priv(ndev);
+
+	/* set MDIO address */
+	csrwr32((mii_id & 0x1f), priv->mac_dev,
+		tse_csroffs(mdio_phy1_addr));
+
+	/* write the data */
+	csrwr32(value, priv->mac_dev, tse_csroffs(mdio_phy1) + regnum * 4);
+	return 0;
+}
+
+static int altera_tse_mdio_create(struct net_device *dev, unsigned int id)
+{
+	struct altera_tse_private *priv = netdev_priv(dev);
+	int ret;
+	struct device_node *mdio_node = NULL;
+	struct mii_bus *mdio = NULL;
+	struct device_node *child_node = NULL;
+
+	for_each_child_of_node(priv->device->of_node, child_node) {
+		if (of_device_is_compatible(child_node, "altr,tse-mdio")) {
+			mdio_node = child_node;
+			break;
+		}
+	}
+
+	if (mdio_node) {
+		netdev_dbg(dev, "FOUND MDIO subnode\n");
+	} else {
+		netdev_dbg(dev, "NO MDIO subnode\n");
+		return 0;
+	}
+
+	mdio = mdiobus_alloc();
+	if (mdio == NULL) {
+		netdev_err(dev, "Error allocating MDIO bus\n");
+		return -ENOMEM;
+	}
+
+	mdio->name = ALTERA_TSE_RESOURCE_NAME;
+	mdio->read = &altera_tse_mdio_read;
+	mdio->write = &altera_tse_mdio_write;
+	snprintf(mdio->id, MII_BUS_ID_SIZE, "%s-%u", mdio->name, id);
+
+	mdio->priv = dev;
+	mdio->parent = priv->device;
+
+	ret = of_mdiobus_register(mdio, mdio_node);
+	if (ret != 0) {
+		netdev_err(dev, "Cannot register MDIO bus %s\n",
+			   mdio->id);
+		goto out_free_mdio;
+	}
+
+	if (netif_msg_drv(priv))
+		netdev_info(dev, "MDIO bus %s: created\n", mdio->id);
+
+	priv->mdio = mdio;
+	return 0;
+out_free_mdio:
+	mdiobus_free(mdio);
+	mdio = NULL;
+	return ret;
+}
+
+static void altera_tse_mdio_destroy(struct net_device *dev)
+{
+	struct altera_tse_private *priv = netdev_priv(dev);
+
+	if (priv->mdio == NULL)
+		return;
+
+	if (netif_msg_drv(priv))
+		netdev_info(dev, "MDIO bus %s: removed\n",
+			    priv->mdio->id);
+
+	mdiobus_unregister(priv->mdio);
+	mdiobus_free(priv->mdio);
+	priv->mdio = NULL;
+}
+
+static int tse_init_rx_buffer(struct altera_tse_private *priv,
+			      struct tse_buffer *rxbuffer, int len)
+{
+	rxbuffer->skb = netdev_alloc_skb_ip_align(priv->dev, len);
+	if (!rxbuffer->skb)
+		return -ENOMEM;
+
+	rxbuffer->dma_addr = dma_map_single(priv->device, rxbuffer->skb->data,
+						len,
+						DMA_FROM_DEVICE);
+
+	if (dma_mapping_error(priv->device, rxbuffer->dma_addr)) {
+		netdev_err(priv->dev, "%s: DMA mapping error\n", __func__);
+		dev_kfree_skb_any(rxbuffer->skb);
+		return -EINVAL;
+	}
+	rxbuffer->dma_addr &= (dma_addr_t)~3;
+	rxbuffer->len = len;
+	return 0;
+}
+
+static void tse_free_rx_buffer(struct altera_tse_private *priv,
+			       struct tse_buffer *rxbuffer)
+{
+	struct sk_buff *skb = rxbuffer->skb;
+	dma_addr_t dma_addr = rxbuffer->dma_addr;
+
+	if (skb != NULL) {
+		if (dma_addr)
+			dma_unmap_single(priv->device, dma_addr,
+					 rxbuffer->len,
+					 DMA_FROM_DEVICE);
+		dev_kfree_skb_any(skb);
+		rxbuffer->skb = NULL;
+		rxbuffer->dma_addr = 0;
+	}
+}
+
+/* Unmap and free Tx buffer resources
+ */
+static void tse_free_tx_buffer(struct altera_tse_private *priv,
+			       struct tse_buffer *buffer)
+{
+	if (buffer->dma_addr) {
+		if (buffer->mapped_as_page)
+			dma_unmap_page(priv->device, buffer->dma_addr,
+				       buffer->len, DMA_TO_DEVICE);
+		else
+			dma_unmap_single(priv->device, buffer->dma_addr,
+					 buffer->len, DMA_TO_DEVICE);
+		buffer->dma_addr = 0;
+	}
+	if (buffer->skb) {
+		dev_kfree_skb_any(buffer->skb);
+		buffer->skb = NULL;
+	}
+}
+
+static int alloc_init_skbufs(struct altera_tse_private *priv)
+{
+	unsigned int rx_descs = priv->rx_ring_size;
+	unsigned int tx_descs = priv->tx_ring_size;
+	int ret = -ENOMEM;
+	int i;
+
+	/* Create Rx ring buffer */
+	priv->rx_ring = kcalloc(rx_descs, sizeof(struct tse_buffer),
+				GFP_KERNEL);
+	if (!priv->rx_ring)
+		goto err_rx_ring;
+
+	/* Create Tx ring buffer */
+	priv->tx_ring = kcalloc(tx_descs, sizeof(struct tse_buffer),
+				GFP_KERNEL);
+	if (!priv->tx_ring)
+		goto err_tx_ring;
+
+	priv->tx_cons = 0;
+	priv->tx_prod = 0;
+
+	/* Init Rx ring */
+	for (i = 0; i < rx_descs; i++) {
+		ret = tse_init_rx_buffer(priv, &priv->rx_ring[i],
+					 priv->rx_dma_buf_sz);
+		if (ret)
+			goto err_init_rx_buffers;
+	}
+
+	priv->rx_cons = 0;
+	priv->rx_prod = 0;
+
+	return 0;
+err_init_rx_buffers:
+	while (--i >= 0)
+		tse_free_rx_buffer(priv, &priv->rx_ring[i]);
+	kfree(priv->tx_ring);
+err_tx_ring:
+	kfree(priv->rx_ring);
+err_rx_ring:
+	return ret;
+}
+
+static void free_skbufs(struct net_device *dev)
+{
+	struct altera_tse_private *priv = netdev_priv(dev);
+	unsigned int rx_descs = priv->rx_ring_size;
+	unsigned int tx_descs = priv->tx_ring_size;
+	int i;
+
+	/* Release the DMA TX/RX socket buffers */
+	for (i = 0; i < rx_descs; i++)
+		tse_free_rx_buffer(priv, &priv->rx_ring[i]);
+	for (i = 0; i < tx_descs; i++)
+		tse_free_tx_buffer(priv, &priv->tx_ring[i]);
+
+
+	kfree(priv->tx_ring);
+}
+
+/* Reallocate the skb for the reception process
+ */
+static inline void tse_rx_refill(struct altera_tse_private *priv)
+{
+	unsigned int rxsize = priv->rx_ring_size;
+	unsigned int entry;
+	int ret;
+
+	for (; priv->rx_cons - priv->rx_prod > 0;
+			priv->rx_prod++) {
+		entry = priv->rx_prod % rxsize;
+		if (likely(priv->rx_ring[entry].skb == NULL)) {
+			ret = tse_init_rx_buffer(priv, &priv->rx_ring[entry],
+				priv->rx_dma_buf_sz);
+			if (unlikely(ret != 0))
+				break;
+			priv->dmaops->add_rx_desc(priv, &priv->rx_ring[entry]);
+		}
+	}
+}
+
+/* Pull out the VLAN tag and fix up the packet
+ */
+static inline void tse_rx_vlan(struct net_device *dev, struct sk_buff *skb)
+{
+	struct ethhdr *eth_hdr;
+	u16 vid;
+	if ((dev->features & NETIF_F_HW_VLAN_CTAG_RX) &&
+	    !__vlan_get_tag(skb, &vid)) {
+		eth_hdr = (struct ethhdr *)skb->data;
+		memmove(skb->data + VLAN_HLEN, eth_hdr, ETH_ALEN * 2);
+		skb_pull(skb, VLAN_HLEN);
+		__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vid);
+	}
+}
+
+/* Receive a packet: retrieve and pass over to upper levels
+ */
+static int tse_rx(struct altera_tse_private *priv, int limit)
+{
+	unsigned int count = 0;
+	unsigned int next_entry;
+	struct sk_buff *skb;
+	unsigned int entry = priv->rx_cons % priv->rx_ring_size;
+	u32 rxstatus;
+	u16 pktlength;
+	u16 pktstatus;
+
+	/* Check for count < limit first as get_rx_status is changing
+	* the response-fifo so we must process the next packet
+	* after calling get_rx_status if a response is pending.
+	* (reading the last byte of the response pops the value from the fifo.)
+	*/
+	while ((count < limit) &&
+	       ((rxstatus = priv->dmaops->get_rx_status(priv)) != 0)) {
+		pktstatus = rxstatus >> 16;
+		pktlength = rxstatus & 0xffff;
+
+		if ((pktstatus & 0xFF) || (pktlength == 0))
+			netdev_err(priv->dev,
+				   "RCV pktstatus %08X pktlength %08X\n",
+				   pktstatus, pktlength);
+
+		/* DMA trasfer from TSE starts with 2 aditional bytes for
+		 * IP payload alignment. Status returned by get_rx_status()
+		 * contains DMA transfer length. Packet is 2 bytes shorter.
+		 */
+		pktlength -= 2;
+
+		count++;
+		next_entry = (++priv->rx_cons) % priv->rx_ring_size;
+
+		skb = priv->rx_ring[entry].skb;
+		if (unlikely(!skb)) {
+			netdev_err(priv->dev,
+				   "%s: Inconsistent Rx descriptor chain\n",
+				   __func__);
+			priv->dev->stats.rx_dropped++;
+			break;
+		}
+		priv->rx_ring[entry].skb = NULL;
+
+		skb_put(skb, pktlength);
+
+		dma_unmap_single(priv->device, priv->rx_ring[entry].dma_addr,
+				 priv->rx_ring[entry].len, DMA_FROM_DEVICE);
+
+		if (netif_msg_pktdata(priv)) {
+			netdev_info(priv->dev, "frame received %d bytes\n",
+				    pktlength);
+			print_hex_dump(KERN_ERR, "data: ", DUMP_PREFIX_OFFSET,
+				       16, 1, skb->data, pktlength, true);
+		}
+
+		tse_rx_vlan(priv->dev, skb);
+
+		skb->protocol = eth_type_trans(skb, priv->dev);
+		skb_checksum_none_assert(skb);
+
+		napi_gro_receive(&priv->napi, skb);
+
+		priv->dev->stats.rx_packets++;
+		priv->dev->stats.rx_bytes += pktlength;
+
+		entry = next_entry;
+
+		tse_rx_refill(priv);
+	}
+
+	return count;
+}
+
+/* Reclaim resources after transmission completes
+ */
+static int tse_tx_complete(struct altera_tse_private *priv)
+{
+	unsigned int txsize = priv->tx_ring_size;
+	u32 ready;
+	unsigned int entry;
+	struct tse_buffer *tx_buff;
+	int txcomplete = 0;
+
+	spin_lock(&priv->tx_lock);
+
+	ready = priv->dmaops->tx_completions(priv);
+
+	/* Free sent buffers */
+	while (ready && (priv->tx_cons != priv->tx_prod)) {
+		entry = priv->tx_cons % txsize;
+		tx_buff = &priv->tx_ring[entry];
+
+		if (netif_msg_tx_done(priv))
+			netdev_dbg(priv->dev, "%s: curr %d, dirty %d\n",
+				   __func__, priv->tx_prod, priv->tx_cons);
+
+		if (likely(tx_buff->skb))
+			priv->dev->stats.tx_packets++;
+
+		tse_free_tx_buffer(priv, tx_buff);
+		priv->tx_cons++;
+
+		txcomplete++;
+		ready--;
+	}
+
+	if (unlikely(netif_queue_stopped(priv->dev) &&
+		     tse_tx_avail(priv) > TSE_TX_THRESH(priv))) {
+		if (netif_queue_stopped(priv->dev) &&
+		    tse_tx_avail(priv) > TSE_TX_THRESH(priv)) {
+			if (netif_msg_tx_done(priv))
+				netdev_dbg(priv->dev, "%s: restart transmit\n",
+					   __func__);
+			netif_wake_queue(priv->dev);
+		}
+	}
+
+	spin_unlock(&priv->tx_lock);
+	return txcomplete;
+}
+
+/* NAPI polling function
+ */
+static int tse_poll(struct napi_struct *napi, int budget)
+{
+	struct altera_tse_private *priv =
+			container_of(napi, struct altera_tse_private, napi);
+	int rxcomplete = 0;
+	unsigned long int flags;
+
+	tse_tx_complete(priv);
+
+	rxcomplete = tse_rx(priv, budget);
+
+	if (rxcomplete < budget) {
+
+		napi_complete_done(napi, rxcomplete);
+
+		netdev_dbg(priv->dev,
+			   "NAPI Complete, did %d packets with budget %d\n",
+			   rxcomplete, budget);
+
+		spin_lock_irqsave(&priv->rxdma_irq_lock, flags);
+		priv->dmaops->enable_rxirq(priv);
+		priv->dmaops->enable_txirq(priv);
+		spin_unlock_irqrestore(&priv->rxdma_irq_lock, flags);
+	}
+	return rxcomplete;
+}
+
+/* DMA TX & RX FIFO interrupt routing
+ */
+static irqreturn_t altera_isr(int irq, void *dev_id)
+{
+	struct net_device *dev = dev_id;
+	struct altera_tse_private *priv;
+
+	if (unlikely(!dev)) {
+		pr_err("%s: invalid dev pointer\n", __func__);
+		return IRQ_NONE;
+	}
+	priv = netdev_priv(dev);
+
+	spin_lock(&priv->rxdma_irq_lock);
+	/* reset IRQs */
+	priv->dmaops->clear_rxirq(priv);
+	priv->dmaops->clear_txirq(priv);
+	spin_unlock(&priv->rxdma_irq_lock);
+
+	if (likely(napi_schedule_prep(&priv->napi))) {
+		spin_lock(&priv->rxdma_irq_lock);
+		priv->dmaops->disable_rxirq(priv);
+		priv->dmaops->disable_txirq(priv);
+		spin_unlock(&priv->rxdma_irq_lock);
+		__napi_schedule(&priv->napi);
+	}
+
+
+	return IRQ_HANDLED;
+}
+
+/* Transmit a packet (called by the kernel). Dispatches
+ * either the SGDMA method for transmitting or the
+ * MSGDMA method, assumes no scatter/gather support,
+ * implying an assumption that there's only one
+ * physically contiguous fragment starting at
+ * skb->data, for length of skb_headlen(skb).
+ */
+static int tse_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct altera_tse_private *priv = netdev_priv(dev);
+	unsigned int txsize = priv->tx_ring_size;
+	unsigned int entry;
+	struct tse_buffer *buffer = NULL;
+	int nfrags = skb_shinfo(skb)->nr_frags;
+	unsigned int nopaged_len = skb_headlen(skb);
+	enum netdev_tx ret = NETDEV_TX_OK;
+	dma_addr_t dma_addr;
+
+	spin_lock_bh(&priv->tx_lock);
+
+	if (unlikely(tse_tx_avail(priv) < nfrags + 1)) {
+		if (!netif_queue_stopped(dev)) {
+			netif_stop_queue(dev);
+			/* This is a hard error, log it. */
+			netdev_err(priv->dev,
+				   "%s: Tx list full when queue awake\n",
+				   __func__);
+		}
+		ret = NETDEV_TX_BUSY;
+		goto out;
+	}
+
+	/* Map the first skb fragment */
+	entry = priv->tx_prod % txsize;
+	buffer = &priv->tx_ring[entry];
+
+	dma_addr = dma_map_single(priv->device, skb->data, nopaged_len,
+				  DMA_TO_DEVICE);
+	if (dma_mapping_error(priv->device, dma_addr)) {
+		netdev_err(priv->dev, "%s: DMA mapping error\n", __func__);
+		ret = NETDEV_TX_OK;
+		goto out;
+	}
+
+	buffer->skb = skb;
+	buffer->dma_addr = dma_addr;
+	buffer->len = nopaged_len;
+
+	priv->dmaops->tx_buffer(priv, buffer);
+
+	skb_tx_timestamp(skb);
+
+	priv->tx_prod++;
+	dev->stats.tx_bytes += skb->len;
+
+	if (unlikely(tse_tx_avail(priv) <= TXQUEUESTOP_THRESHHOLD)) {
+		if (netif_msg_hw(priv))
+			netdev_dbg(priv->dev, "%s: stop transmitted packets\n",
+				   __func__);
+		netif_stop_queue(dev);
+	}
+
+out:
+	spin_unlock_bh(&priv->tx_lock);
+
+	return ret;
+}
+
+/* Called every time the controller might need to be made
+ * aware of new link state.  The PHY code conveys this
+ * information through variables in the phydev structure, and this
+ * function converts those variables into the appropriate
+ * register values, and can bring down the device if needed.
+ */
+static void altera_tse_adjust_link(struct net_device *dev)
+{
+	struct altera_tse_private *priv = netdev_priv(dev);
+	struct phy_device *phydev = dev->phydev;
+	int new_state = 0;
+
+	/* only change config if there is a link */
+	spin_lock(&priv->mac_cfg_lock);
+	if (phydev->link) {
+		/* Read old config */
+		u32 cfg_reg = ioread32(&priv->mac_dev->command_config);
+
+		/* Check duplex */
+		if (phydev->duplex != priv->oldduplex) {
+			new_state = 1;
+			if (!(phydev->duplex))
+				cfg_reg |= MAC_CMDCFG_HD_ENA;
+			else
+				cfg_reg &= ~MAC_CMDCFG_HD_ENA;
+
+			netdev_dbg(priv->dev, "%s: Link duplex = 0x%x\n",
+				   dev->name, phydev->duplex);
+
+			priv->oldduplex = phydev->duplex;
+		}
+
+		/* Check speed */
+		if (phydev->speed != priv->oldspeed) {
+			new_state = 1;
+			switch (phydev->speed) {
+			case 1000:
+				cfg_reg |= MAC_CMDCFG_ETH_SPEED;
+				cfg_reg &= ~MAC_CMDCFG_ENA_10;
+				break;
+			case 100:
+				cfg_reg &= ~MAC_CMDCFG_ETH_SPEED;
+				cfg_reg &= ~MAC_CMDCFG_ENA_10;
+				break;
+			case 10:
+				cfg_reg &= ~MAC_CMDCFG_ETH_SPEED;
+				cfg_reg |= MAC_CMDCFG_ENA_10;
+				break;
+			default:
+				if (netif_msg_link(priv))
+					netdev_warn(dev, "Speed (%d) is not 10/100/1000!\n",
+						    phydev->speed);
+				break;
+			}
+			priv->oldspeed = phydev->speed;
+		}
+		iowrite32(cfg_reg, &priv->mac_dev->command_config);
+
+		if (!priv->oldlink) {
+			new_state = 1;
+			priv->oldlink = 1;
+		}
+	} else if (priv->oldlink) {
+		new_state = 1;
+		priv->oldlink = 0;
+		priv->oldspeed = 0;
+		priv->oldduplex = -1;
+	}
+
+	if (new_state && netif_msg_link(priv))
+		phy_print_status(phydev);
+
+	spin_unlock(&priv->mac_cfg_lock);
+}
+static struct phy_device *connect_local_phy(struct net_device *dev)
+{
+	struct altera_tse_private *priv = netdev_priv(dev);
+	struct phy_device *phydev = NULL;
+	char phy_id_fmt[MII_BUS_ID_SIZE + 3];
+
+	if (priv->phy_addr != POLL_PHY) {
+		snprintf(phy_id_fmt, MII_BUS_ID_SIZE + 3, PHY_ID_FMT,
+			 priv->mdio->id, priv->phy_addr);
+
+		netdev_dbg(dev, "trying to attach to %s\n", phy_id_fmt);
+
+		phydev = phy_connect(dev, phy_id_fmt, &altera_tse_adjust_link,
+				     priv->phy_iface);
+		if (IS_ERR(phydev))
+			netdev_err(dev, "Could not attach to PHY\n");
+
+	} else {
+		int ret;
+		phydev = phy_find_first(priv->mdio);
+		if (phydev == NULL) {
+			netdev_err(dev, "No PHY found\n");
+			return phydev;
+		}
+
+		ret = phy_connect_direct(dev, phydev, &altera_tse_adjust_link,
+				priv->phy_iface);
+		if (ret != 0) {
+			netdev_err(dev, "Could not attach to PHY\n");
+			phydev = NULL;
+		}
+	}
+	return phydev;
+}
+
+static int altera_tse_phy_get_addr_mdio_create(struct net_device *dev)
+{
+	struct altera_tse_private *priv = netdev_priv(dev);
+	struct device_node *np = priv->device->of_node;
+	int ret = 0;
+
+	priv->phy_iface = of_get_phy_mode(np);
+
+	/* Avoid get phy addr and create mdio if no phy is present */
+	if (!priv->phy_iface)
+		return 0;
+
+	/* try to get PHY address from device tree, use PHY autodetection if
+	 * no valid address is given
+	 */
+
+	if (of_property_read_u32(priv->device->of_node, "phy-addr",
+			 &priv->phy_addr)) {
+		priv->phy_addr = POLL_PHY;
+	}
+
+	if (!((priv->phy_addr == POLL_PHY) ||
+		  ((priv->phy_addr >= 0) && (priv->phy_addr < PHY_MAX_ADDR)))) {
+		netdev_err(dev, "invalid phy-addr specified %d\n",
+			priv->phy_addr);
+		return -ENODEV;
+	}
+
+	/* Create/attach to MDIO bus */
+	ret = altera_tse_mdio_create(dev,
+					 atomic_add_return(1, &instance_count));
+
+	if (ret)
+		return -ENODEV;
+
+	return 0;
+}
+
+/* Initialize driver's PHY state, and attach to the PHY
+ */
+static int init_phy(struct net_device *dev)
+{
+	struct altera_tse_private *priv = netdev_priv(dev);
+	struct phy_device *phydev;
+	struct device_node *phynode;
+	bool fixed_link = false;
+	int rc = 0;
+
+	/* Avoid init phy in case of no phy present */
+	if (!priv->phy_iface)
+		return 0;
+
+	priv->oldlink = 0;
+	priv->oldspeed = 0;
+	priv->oldduplex = -1;
+
+	phynode = of_parse_phandle(priv->device->of_node, "phy-handle", 0);
+
+	if (!phynode) {
+		/* check if a fixed-link is defined in device-tree */
+		if (of_phy_is_fixed_link(priv->device->of_node)) {
+			rc = of_phy_register_fixed_link(priv->device->of_node);
+			if (rc < 0) {
+				netdev_err(dev, "cannot register fixed PHY\n");
+				return rc;
+			}
+
+			/* In the case of a fixed PHY, the DT node associated
+			 * to the PHY is the Ethernet MAC DT node.
+			 */
+			phynode = of_node_get(priv->device->of_node);
+			fixed_link = true;
+
+			netdev_dbg(dev, "fixed-link detected\n");
+			phydev = of_phy_connect(dev, phynode,
+						&altera_tse_adjust_link,
+						0, priv->phy_iface);
+		} else {
+			netdev_dbg(dev, "no phy-handle found\n");
+			if (!priv->mdio) {
+				netdev_err(dev, "No phy-handle nor local mdio specified\n");
+				return -ENODEV;
+			}
+			phydev = connect_local_phy(dev);
+		}
+	} else {
+		netdev_dbg(dev, "phy-handle found\n");
+		phydev = of_phy_connect(dev, phynode,
+			&altera_tse_adjust_link, 0, priv->phy_iface);
+	}
+	of_node_put(phynode);
+
+	if (!phydev) {
+		netdev_err(dev, "Could not find the PHY\n");
+		if (fixed_link)
+			of_phy_deregister_fixed_link(priv->device->of_node);
+		return -ENODEV;
+	}
+
+	/* Stop Advertising 1000BASE Capability if interface is not GMII
+	 * Note: Checkpatch throws CHECKs for the camel case defines below,
+	 * it's ok to ignore.
+	 */
+	if ((priv->phy_iface == PHY_INTERFACE_MODE_MII) ||
+	    (priv->phy_iface == PHY_INTERFACE_MODE_RMII))
+		phydev->advertising &= ~(SUPPORTED_1000baseT_Half |
+					 SUPPORTED_1000baseT_Full);
+
+	/* Broken HW is sometimes missing the pull-up resistor on the
+	 * MDIO line, which results in reads to non-existent devices returning
+	 * 0 rather than 0xffff. Catch this here and treat 0 as a non-existent
+	 * device as well. If a fixed-link is used the phy_id is always 0.
+	 * Note: phydev->phy_id is the result of reading the UID PHY registers.
+	 */
+	if ((phydev->phy_id == 0) && !fixed_link) {
+		netdev_err(dev, "Bad PHY UID 0x%08x\n", phydev->phy_id);
+		phy_disconnect(phydev);
+		return -ENODEV;
+	}
+
+	netdev_dbg(dev, "attached to PHY %d UID 0x%08x Link = %d\n",
+		   phydev->mdio.addr, phydev->phy_id, phydev->link);
+
+	return 0;
+}
+
+static void tse_update_mac_addr(struct altera_tse_private *priv, u8 *addr)
+{
+	u32 msb;
+	u32 lsb;
+
+	msb = (addr[3] << 24) | (addr[2] << 16) | (addr[1] << 8) | addr[0];
+	lsb = ((addr[5] << 8) | addr[4]) & 0xffff;
+
+	/* Set primary MAC address */
+	csrwr32(msb, priv->mac_dev, tse_csroffs(mac_addr_0));
+	csrwr32(lsb, priv->mac_dev, tse_csroffs(mac_addr_1));
+}
+
+/* MAC software reset.
+ * When reset is triggered, the MAC function completes the current
+ * transmission or reception, and subsequently disables the transmit and
+ * receive logic, flushes the receive FIFO buffer, and resets the statistics
+ * counters.
+ */
+static int reset_mac(struct altera_tse_private *priv)
+{
+	int counter;
+	u32 dat;
+
+	dat = csrrd32(priv->mac_dev, tse_csroffs(command_config));
+	dat &= ~(MAC_CMDCFG_TX_ENA | MAC_CMDCFG_RX_ENA);
+	dat |= MAC_CMDCFG_SW_RESET | MAC_CMDCFG_CNT_RESET;
+	csrwr32(dat, priv->mac_dev, tse_csroffs(command_config));
+
+	counter = 0;
+	while (counter++ < ALTERA_TSE_SW_RESET_WATCHDOG_CNTR) {
+		if (tse_bit_is_clear(priv->mac_dev, tse_csroffs(command_config),
+				     MAC_CMDCFG_SW_RESET))
+			break;
+		udelay(1);
+	}
+
+	if (counter >= ALTERA_TSE_SW_RESET_WATCHDOG_CNTR) {
+		dat = csrrd32(priv->mac_dev, tse_csroffs(command_config));
+		dat &= ~MAC_CMDCFG_SW_RESET;
+		csrwr32(dat, priv->mac_dev, tse_csroffs(command_config));
+		return -1;
+	}
+	return 0;
+}
+
+/* Initialize MAC core registers
+*/
+static int init_mac(struct altera_tse_private *priv)
+{
+	unsigned int cmd = 0;
+	u32 frm_length;
+
+	/* Setup Rx FIFO */
+	csrwr32(priv->rx_fifo_depth - ALTERA_TSE_RX_SECTION_EMPTY,
+		priv->mac_dev, tse_csroffs(rx_section_empty));
+
+	csrwr32(ALTERA_TSE_RX_SECTION_FULL, priv->mac_dev,
+		tse_csroffs(rx_section_full));
+
+	csrwr32(ALTERA_TSE_RX_ALMOST_EMPTY, priv->mac_dev,
+		tse_csroffs(rx_almost_empty));
+
+	csrwr32(ALTERA_TSE_RX_ALMOST_FULL, priv->mac_dev,
+		tse_csroffs(rx_almost_full));
+
+	/* Setup Tx FIFO */
+	csrwr32(priv->tx_fifo_depth - ALTERA_TSE_TX_SECTION_EMPTY,
+		priv->mac_dev, tse_csroffs(tx_section_empty));
+
+	csrwr32(ALTERA_TSE_TX_SECTION_FULL, priv->mac_dev,
+		tse_csroffs(tx_section_full));
+
+	csrwr32(ALTERA_TSE_TX_ALMOST_EMPTY, priv->mac_dev,
+		tse_csroffs(tx_almost_empty));
+
+	csrwr32(ALTERA_TSE_TX_ALMOST_FULL, priv->mac_dev,
+		tse_csroffs(tx_almost_full));
+
+	/* MAC Address Configuration */
+	tse_update_mac_addr(priv, priv->dev->dev_addr);
+
+	/* MAC Function Configuration */
+	frm_length = ETH_HLEN + priv->dev->mtu + ETH_FCS_LEN;
+	csrwr32(frm_length, priv->mac_dev, tse_csroffs(frm_length));
+
+	csrwr32(ALTERA_TSE_TX_IPG_LENGTH, priv->mac_dev,
+		tse_csroffs(tx_ipg_length));
+
+	/* Disable RX/TX shift 16 for alignment of all received frames on 16-bit
+	 * start address
+	 */
+	tse_set_bit(priv->mac_dev, tse_csroffs(rx_cmd_stat),
+		    ALTERA_TSE_RX_CMD_STAT_RX_SHIFT16);
+
+	tse_clear_bit(priv->mac_dev, tse_csroffs(tx_cmd_stat),
+		      ALTERA_TSE_TX_CMD_STAT_TX_SHIFT16 |
+		      ALTERA_TSE_TX_CMD_STAT_OMIT_CRC);
+
+	/* Set the MAC options */
+	cmd = csrrd32(priv->mac_dev, tse_csroffs(command_config));
+	cmd &= ~MAC_CMDCFG_PAD_EN;	/* No padding Removal on Receive */
+	cmd &= ~MAC_CMDCFG_CRC_FWD;	/* CRC Removal */
+	cmd |= MAC_CMDCFG_RX_ERR_DISC;	/* Automatically discard frames
+					 * with CRC errors
+					 */
+	cmd |= MAC_CMDCFG_CNTL_FRM_ENA;
+	cmd &= ~MAC_CMDCFG_TX_ENA;
+	cmd &= ~MAC_CMDCFG_RX_ENA;
+
+	/* Default speed and duplex setting, full/100 */
+	cmd &= ~MAC_CMDCFG_HD_ENA;
+	cmd &= ~MAC_CMDCFG_ETH_SPEED;
+	cmd &= ~MAC_CMDCFG_ENA_10;
+
+	csrwr32(cmd, priv->mac_dev, tse_csroffs(command_config));
+
+	csrwr32(ALTERA_TSE_PAUSE_QUANTA, priv->mac_dev,
+		tse_csroffs(pause_quanta));
+
+	if (netif_msg_hw(priv))
+		dev_dbg(priv->device,
+			"MAC post-initialization: CMD_CONFIG = 0x%08x\n", cmd);
+
+	return 0;
+}
+
+/* Start/stop MAC transmission logic
+ */
+static void tse_set_mac(struct altera_tse_private *priv, bool enable)
+{
+	u32 value = csrrd32(priv->mac_dev, tse_csroffs(command_config));
+
+	if (enable)
+		value |= MAC_CMDCFG_TX_ENA | MAC_CMDCFG_RX_ENA;
+	else
+		value &= ~(MAC_CMDCFG_TX_ENA | MAC_CMDCFG_RX_ENA);
+
+	csrwr32(value, priv->mac_dev, tse_csroffs(command_config));
+}
+
+/* Change the MTU
+ */
+static int tse_change_mtu(struct net_device *dev, int new_mtu)
+{
+	if (netif_running(dev)) {
+		netdev_err(dev, "must be stopped to change its MTU\n");
+		return -EBUSY;
+	}
+
+	dev->mtu = new_mtu;
+	netdev_update_features(dev);
+
+	return 0;
+}
+
+static void altera_tse_set_mcfilter(struct net_device *dev)
+{
+	struct altera_tse_private *priv = netdev_priv(dev);
+	int i;
+	struct netdev_hw_addr *ha;
+
+	/* clear the hash filter */
+	for (i = 0; i < 64; i++)
+		csrwr32(0, priv->mac_dev, tse_csroffs(hash_table) + i * 4);
+
+	netdev_for_each_mc_addr(ha, dev) {
+		unsigned int hash = 0;
+		int mac_octet;
+
+		for (mac_octet = 5; mac_octet >= 0; mac_octet--) {
+			unsigned char xor_bit = 0;
+			unsigned char octet = ha->addr[mac_octet];
+			unsigned int bitshift;
+
+			for (bitshift = 0; bitshift < 8; bitshift++)
+				xor_bit ^= ((octet >> bitshift) & 0x01);
+
+			hash = (hash << 1) | xor_bit;
+		}
+		csrwr32(1, priv->mac_dev, tse_csroffs(hash_table) + hash * 4);
+	}
+}
+
+
+static void altera_tse_set_mcfilterall(struct net_device *dev)
+{
+	struct altera_tse_private *priv = netdev_priv(dev);
+	int i;
+
+	/* set the hash filter */
+	for (i = 0; i < 64; i++)
+		csrwr32(1, priv->mac_dev, tse_csroffs(hash_table) + i * 4);
+}
+
+/* Set or clear the multicast filter for this adaptor
+ */
+static void tse_set_rx_mode_hashfilter(struct net_device *dev)
+{
+	struct altera_tse_private *priv = netdev_priv(dev);
+
+	spin_lock(&priv->mac_cfg_lock);
+
+	if (dev->flags & IFF_PROMISC)
+		tse_set_bit(priv->mac_dev, tse_csroffs(command_config),
+			    MAC_CMDCFG_PROMIS_EN);
+
+	if (dev->flags & IFF_ALLMULTI)
+		altera_tse_set_mcfilterall(dev);
+	else
+		altera_tse_set_mcfilter(dev);
+
+	spin_unlock(&priv->mac_cfg_lock);
+}
+
+/* Set or clear the multicast filter for this adaptor
+ */
+static void tse_set_rx_mode(struct net_device *dev)
+{
+	struct altera_tse_private *priv = netdev_priv(dev);
+
+	spin_lock(&priv->mac_cfg_lock);
+
+	if ((dev->flags & IFF_PROMISC) || (dev->flags & IFF_ALLMULTI) ||
+	    !netdev_mc_empty(dev) || !netdev_uc_empty(dev))
+		tse_set_bit(priv->mac_dev, tse_csroffs(command_config),
+			    MAC_CMDCFG_PROMIS_EN);
+	else
+		tse_clear_bit(priv->mac_dev, tse_csroffs(command_config),
+			      MAC_CMDCFG_PROMIS_EN);
+
+	spin_unlock(&priv->mac_cfg_lock);
+}
+
+/* Initialise (if necessary) the SGMII PCS component
+ */
+static int init_sgmii_pcs(struct net_device *dev)
+{
+	struct altera_tse_private *priv = netdev_priv(dev);
+	int n;
+	unsigned int tmp_reg = 0;
+
+	if (priv->phy_iface != PHY_INTERFACE_MODE_SGMII)
+		return 0; /* Nothing to do, not in SGMII mode */
+
+	/* The TSE SGMII PCS block looks a little like a PHY, it is
+	 * mapped into the zeroth MDIO space of the MAC and it has
+	 * ID registers like a PHY would.  Sadly this is often
+	 * configured to zeroes, so don't be surprised if it does
+	 * show 0x00000000.
+	 */
+
+	if (sgmii_pcs_scratch_test(priv, 0x0000) &&
+		sgmii_pcs_scratch_test(priv, 0xffff) &&
+		sgmii_pcs_scratch_test(priv, 0xa5a5) &&
+		sgmii_pcs_scratch_test(priv, 0x5a5a)) {
+		netdev_info(dev, "PCS PHY ID: 0x%04x%04x\n",
+				sgmii_pcs_read(priv, MII_PHYSID1),
+				sgmii_pcs_read(priv, MII_PHYSID2));
+	} else {
+		netdev_err(dev, "SGMII PCS Scratch memory test failed.\n");
+		return -ENOMEM;
+	}
+
+	/* Starting on page 5-29 of the MegaCore Function User Guide
+	 * Set SGMII Link timer to 1.6ms
+	 */
+	sgmii_pcs_write(priv, SGMII_PCS_LINK_TIMER_0, 0x0D40);
+	sgmii_pcs_write(priv, SGMII_PCS_LINK_TIMER_1, 0x03);
+
+	/* Enable SGMII Interface and Enable SGMII Auto Negotiation */
+	sgmii_pcs_write(priv, SGMII_PCS_IF_MODE, 0x3);
+
+	/* Enable Autonegotiation */
+	tmp_reg = sgmii_pcs_read(priv, MII_BMCR);
+	tmp_reg |= (BMCR_SPEED1000 | BMCR_FULLDPLX | BMCR_ANENABLE);
+	sgmii_pcs_write(priv, MII_BMCR, tmp_reg);
+
+	/* Reset PCS block */
+	tmp_reg |= BMCR_RESET;
+	sgmii_pcs_write(priv, MII_BMCR, tmp_reg);
+	for (n = 0; n < SGMII_PCS_SW_RESET_TIMEOUT; n++) {
+		if (!(sgmii_pcs_read(priv, MII_BMCR) & BMCR_RESET)) {
+			netdev_info(dev, "SGMII PCS block initialised OK\n");
+			return 0;
+		}
+		udelay(1);
+	}
+
+	/* We failed to reset the block, return a timeout */
+	netdev_err(dev, "SGMII PCS block reset failed.\n");
+	return -ETIMEDOUT;
+}
+
+/* Open and initialize the interface
+ */
+static int tse_open(struct net_device *dev)
+{
+	struct altera_tse_private *priv = netdev_priv(dev);
+	int ret = 0;
+	int i;
+	unsigned long int flags;
+
+	/* Reset and configure TSE MAC and probe associated PHY */
+	ret = priv->dmaops->init_dma(priv);
+	if (ret != 0) {
+		netdev_err(dev, "Cannot initialize DMA\n");
+		goto phy_error;
+	}
+
+	if (netif_msg_ifup(priv))
+		netdev_warn(dev, "device MAC address %pM\n",
+			    dev->dev_addr);
+
+	if ((priv->revision < 0xd00) || (priv->revision > 0xe00))
+		netdev_warn(dev, "TSE revision %x\n", priv->revision);
+
+	spin_lock(&priv->mac_cfg_lock);
+	/* no-op if MAC not operating in SGMII mode*/
+	ret = init_sgmii_pcs(dev);
+	if (ret) {
+		netdev_err(dev,
+			   "Cannot init the SGMII PCS (error: %d)\n", ret);
+		spin_unlock(&priv->mac_cfg_lock);
+		goto phy_error;
+	}
+
+	ret = reset_mac(priv);
+	/* Note that reset_mac will fail if the clocks are gated by the PHY
+	 * due to the PHY being put into isolation or power down mode.
+	 * This is not an error if reset fails due to no clock.
+	 */
+	if (ret)
+		netdev_dbg(dev, "Cannot reset MAC core (error: %d)\n", ret);
+
+	ret = init_mac(priv);
+	spin_unlock(&priv->mac_cfg_lock);
+	if (ret) {
+		netdev_err(dev, "Cannot init MAC core (error: %d)\n", ret);
+		goto alloc_skbuf_error;
+	}
+
+	priv->dmaops->reset_dma(priv);
+
+	/* Create and initialize the TX/RX descriptors chains. */
+	priv->rx_ring_size = dma_rx_num;
+	priv->tx_ring_size = dma_tx_num;
+	ret = alloc_init_skbufs(priv);
+	if (ret) {
+		netdev_err(dev, "DMA descriptors initialization failed\n");
+		goto alloc_skbuf_error;
+	}
+
+
+	/* Register RX interrupt */
+	ret = request_irq(priv->rx_irq, altera_isr, IRQF_SHARED,
+			  dev->name, dev);
+	if (ret) {
+		netdev_err(dev, "Unable to register RX interrupt %d\n",
+			   priv->rx_irq);
+		goto init_error;
+	}
+
+	/* Register TX interrupt */
+	ret = request_irq(priv->tx_irq, altera_isr, IRQF_SHARED,
+			  dev->name, dev);
+	if (ret) {
+		netdev_err(dev, "Unable to register TX interrupt %d\n",
+			   priv->tx_irq);
+		goto tx_request_irq_error;
+	}
+
+	/* Enable DMA interrupts */
+	spin_lock_irqsave(&priv->rxdma_irq_lock, flags);
+	priv->dmaops->enable_rxirq(priv);
+	priv->dmaops->enable_txirq(priv);
+
+	/* Setup RX descriptor chain */
+	for (i = 0; i < priv->rx_ring_size; i++)
+		priv->dmaops->add_rx_desc(priv, &priv->rx_ring[i]);
+
+	spin_unlock_irqrestore(&priv->rxdma_irq_lock, flags);
+
+	if (dev->phydev)
+		phy_start(dev->phydev);
+
+	napi_enable(&priv->napi);
+	netif_start_queue(dev);
+
+	priv->dmaops->start_rxdma(priv);
+
+	/* Start MAC Rx/Tx */
+	spin_lock(&priv->mac_cfg_lock);
+	tse_set_mac(priv, true);
+	spin_unlock(&priv->mac_cfg_lock);
+
+	return 0;
+
+tx_request_irq_error:
+	free_irq(priv->rx_irq, dev);
+init_error:
+	free_skbufs(dev);
+alloc_skbuf_error:
+phy_error:
+	return ret;
+}
+
+/* Stop TSE MAC interface and put the device in an inactive state
+ */
+static int tse_shutdown(struct net_device *dev)
+{
+	struct altera_tse_private *priv = netdev_priv(dev);
+	int ret;
+	unsigned long int flags;
+
+	/* Stop the PHY */
+	if (dev->phydev)
+		phy_stop(dev->phydev);
+
+	netif_stop_queue(dev);
+	napi_disable(&priv->napi);
+
+	/* Disable DMA interrupts */
+	spin_lock_irqsave(&priv->rxdma_irq_lock, flags);
+	priv->dmaops->disable_rxirq(priv);
+	priv->dmaops->disable_txirq(priv);
+	spin_unlock_irqrestore(&priv->rxdma_irq_lock, flags);
+
+	/* Free the IRQ lines */
+	free_irq(priv->rx_irq, dev);
+	free_irq(priv->tx_irq, dev);
+
+	/* disable and reset the MAC, empties fifo */
+	spin_lock(&priv->mac_cfg_lock);
+	spin_lock(&priv->tx_lock);
+
+	ret = reset_mac(priv);
+	/* Note that reset_mac will fail if the clocks are gated by the PHY
+	 * due to the PHY being put into isolation or power down mode.
+	 * This is not an error if reset fails due to no clock.
+	 */
+	if (ret)
+		netdev_dbg(dev, "Cannot reset MAC core (error: %d)\n", ret);
+	priv->dmaops->reset_dma(priv);
+	free_skbufs(dev);
+
+	spin_unlock(&priv->tx_lock);
+	spin_unlock(&priv->mac_cfg_lock);
+
+	priv->dmaops->uninit_dma(priv);
+
+	return 0;
+}
+
+static struct net_device_ops altera_tse_netdev_ops = {
+	.ndo_open		= tse_open,
+	.ndo_stop		= tse_shutdown,
+	.ndo_start_xmit		= tse_start_xmit,
+	.ndo_set_mac_address	= eth_mac_addr,
+	.ndo_set_rx_mode	= tse_set_rx_mode,
+	.ndo_change_mtu		= tse_change_mtu,
+	.ndo_validate_addr	= eth_validate_addr,
+};
+
+static int request_and_map(struct platform_device *pdev, const char *name,
+			   struct resource **res, void __iomem **ptr)
+{
+	struct resource *region;
+	struct device *device = &pdev->dev;
+
+	*res = platform_get_resource_byname(pdev, IORESOURCE_MEM, name);
+	if (*res == NULL) {
+		dev_err(device, "resource %s not defined\n", name);
+		return -ENODEV;
+	}
+
+	region = devm_request_mem_region(device, (*res)->start,
+					 resource_size(*res), dev_name(device));
+	if (region == NULL) {
+		dev_err(device, "unable to request %s\n", name);
+		return -EBUSY;
+	}
+
+	*ptr = devm_ioremap_nocache(device, region->start,
+				    resource_size(region));
+	if (*ptr == NULL) {
+		dev_err(device, "ioremap_nocache of %s failed!", name);
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+/* Probe Altera TSE MAC device
+ */
+static int altera_tse_probe(struct platform_device *pdev)
+{
+	struct net_device *ndev;
+	int ret = -ENODEV;
+	struct resource *control_port;
+	struct resource *dma_res;
+	struct altera_tse_private *priv;
+	const unsigned char *macaddr;
+	void __iomem *descmap;
+	const struct of_device_id *of_id = NULL;
+
+	ndev = alloc_etherdev(sizeof(struct altera_tse_private));
+	if (!ndev) {
+		dev_err(&pdev->dev, "Could not allocate network device\n");
+		return -ENODEV;
+	}
+
+	SET_NETDEV_DEV(ndev, &pdev->dev);
+
+	priv = netdev_priv(ndev);
+	priv->device = &pdev->dev;
+	priv->dev = ndev;
+	priv->msg_enable = netif_msg_init(debug, default_msg_level);
+
+	of_id = of_match_device(altera_tse_ids, &pdev->dev);
+
+	if (of_id)
+		priv->dmaops = (struct altera_dmaops *)of_id->data;
+
+
+	if (priv->dmaops &&
+	    priv->dmaops->altera_dtype == ALTERA_DTYPE_SGDMA) {
+		/* Get the mapped address to the SGDMA descriptor memory */
+		ret = request_and_map(pdev, "s1", &dma_res, &descmap);
+		if (ret)
+			goto err_free_netdev;
+
+		/* Start of that memory is for transmit descriptors */
+		priv->tx_dma_desc = descmap;
+
+		/* First half is for tx descriptors, other half for tx */
+		priv->txdescmem = resource_size(dma_res)/2;
+
+		priv->txdescmem_busaddr = (dma_addr_t)dma_res->start;
+
+		priv->rx_dma_desc = (void __iomem *)((uintptr_t)(descmap +
+						     priv->txdescmem));
+		priv->rxdescmem = resource_size(dma_res)/2;
+		priv->rxdescmem_busaddr = dma_res->start;
+		priv->rxdescmem_busaddr += priv->txdescmem;
+
+		if (upper_32_bits(priv->rxdescmem_busaddr)) {
+			dev_dbg(priv->device,
+				"SGDMA bus addresses greater than 32-bits\n");
+			ret = -EINVAL;
+			goto err_free_netdev;
+		}
+		if (upper_32_bits(priv->txdescmem_busaddr)) {
+			dev_dbg(priv->device,
+				"SGDMA bus addresses greater than 32-bits\n");
+			ret = -EINVAL;
+			goto err_free_netdev;
+		}
+	} else if (priv->dmaops &&
+		   priv->dmaops->altera_dtype == ALTERA_DTYPE_MSGDMA) {
+		ret = request_and_map(pdev, "rx_resp", &dma_res,
+				      &priv->rx_dma_resp);
+		if (ret)
+			goto err_free_netdev;
+
+		ret = request_and_map(pdev, "tx_desc", &dma_res,
+				      &priv->tx_dma_desc);
+		if (ret)
+			goto err_free_netdev;
+
+		priv->txdescmem = resource_size(dma_res);
+		priv->txdescmem_busaddr = dma_res->start;
+
+		ret = request_and_map(pdev, "rx_desc", &dma_res,
+				      &priv->rx_dma_desc);
+		if (ret)
+			goto err_free_netdev;
+
+		priv->rxdescmem = resource_size(dma_res);
+		priv->rxdescmem_busaddr = dma_res->start;
+
+	} else {
+		goto err_free_netdev;
+	}
+
+	if (!dma_set_mask(priv->device, DMA_BIT_MASK(priv->dmaops->dmamask)))
+		dma_set_coherent_mask(priv->device,
+				      DMA_BIT_MASK(priv->dmaops->dmamask));
+	else if (!dma_set_mask(priv->device, DMA_BIT_MASK(32)))
+		dma_set_coherent_mask(priv->device, DMA_BIT_MASK(32));
+	else
+		goto err_free_netdev;
+
+	/* MAC address space */
+	ret = request_and_map(pdev, "control_port", &control_port,
+			      (void __iomem **)&priv->mac_dev);
+	if (ret)
+		goto err_free_netdev;
+
+	/* xSGDMA Rx Dispatcher address space */
+	ret = request_and_map(pdev, "rx_csr", &dma_res,
+			      &priv->rx_dma_csr);
+	if (ret)
+		goto err_free_netdev;
+
+
+	/* xSGDMA Tx Dispatcher address space */
+	ret = request_and_map(pdev, "tx_csr", &dma_res,
+			      &priv->tx_dma_csr);
+	if (ret)
+		goto err_free_netdev;
+
+
+	/* Rx IRQ */
+	priv->rx_irq = platform_get_irq_byname(pdev, "rx_irq");
+	if (priv->rx_irq == -ENXIO) {
+		dev_err(&pdev->dev, "cannot obtain Rx IRQ\n");
+		ret = -ENXIO;
+		goto err_free_netdev;
+	}
+
+	/* Tx IRQ */
+	priv->tx_irq = platform_get_irq_byname(pdev, "tx_irq");
+	if (priv->tx_irq == -ENXIO) {
+		dev_err(&pdev->dev, "cannot obtain Tx IRQ\n");
+		ret = -ENXIO;
+		goto err_free_netdev;
+	}
+
+	/* get FIFO depths from device tree */
+	if (of_property_read_u32(pdev->dev.of_node, "rx-fifo-depth",
+				 &priv->rx_fifo_depth)) {
+		dev_err(&pdev->dev, "cannot obtain rx-fifo-depth\n");
+		ret = -ENXIO;
+		goto err_free_netdev;
+	}
+
+	if (of_property_read_u32(pdev->dev.of_node, "tx-fifo-depth",
+				 &priv->tx_fifo_depth)) {
+		dev_err(&pdev->dev, "cannot obtain tx-fifo-depth\n");
+		ret = -ENXIO;
+		goto err_free_netdev;
+	}
+
+	/* get hash filter settings for this instance */
+	priv->hash_filter =
+		of_property_read_bool(pdev->dev.of_node,
+				      "altr,has-hash-multicast-filter");
+
+	/* Set hash filter to not set for now until the
+	 * multicast filter receive issue is debugged
+	 */
+	priv->hash_filter = 0;
+
+	/* get supplemental address settings for this instance */
+	priv->added_unicast =
+		of_property_read_bool(pdev->dev.of_node,
+				      "altr,has-supplementary-unicast");
+
+	priv->dev->min_mtu = ETH_ZLEN + ETH_FCS_LEN;
+	/* Max MTU is 1500, ETH_DATA_LEN */
+	priv->dev->max_mtu = ETH_DATA_LEN;
+
+	/* Get the max mtu from the device tree. Note that the
+	 * "max-frame-size" parameter is actually max mtu. Definition
+	 * in the ePAPR v1.1 spec and usage differ, so go with usage.
+	 */
+	of_property_read_u32(pdev->dev.of_node, "max-frame-size",
+			     &priv->dev->max_mtu);
+
+	/* The DMA buffer size already accounts for an alignment bias
+	 * to avoid unaligned access exceptions for the NIOS processor,
+	 */
+	priv->rx_dma_buf_sz = ALTERA_RXDMABUFFER_SIZE;
+
+	/* get default MAC address from device tree */
+	macaddr = of_get_mac_address(pdev->dev.of_node);
+	if (macaddr)
+		ether_addr_copy(ndev->dev_addr, macaddr);
+	else
+		eth_hw_addr_random(ndev);
+
+	/* get phy addr and create mdio */
+	ret = altera_tse_phy_get_addr_mdio_create(ndev);
+
+	if (ret)
+		goto err_free_netdev;
+
+	/* initialize netdev */
+	ndev->mem_start = control_port->start;
+	ndev->mem_end = control_port->end;
+	ndev->netdev_ops = &altera_tse_netdev_ops;
+	altera_tse_set_ethtool_ops(ndev);
+
+	altera_tse_netdev_ops.ndo_set_rx_mode = tse_set_rx_mode;
+
+	if (priv->hash_filter)
+		altera_tse_netdev_ops.ndo_set_rx_mode =
+			tse_set_rx_mode_hashfilter;
+
+	/* Scatter/gather IO is not supported,
+	 * so it is turned off
+	 */
+	ndev->hw_features &= ~NETIF_F_SG;
+	ndev->features |= ndev->hw_features | NETIF_F_HIGHDMA;
+
+	/* VLAN offloading of tagging, stripping and filtering is not
+	 * supported by hardware, but driver will accommodate the
+	 * extra 4-byte VLAN tag for processing by upper layers
+	 */
+	ndev->features |= NETIF_F_HW_VLAN_CTAG_RX;
+
+	/* setup NAPI interface */
+	netif_napi_add(ndev, &priv->napi, tse_poll, NAPI_POLL_WEIGHT);
+
+	spin_lock_init(&priv->mac_cfg_lock);
+	spin_lock_init(&priv->tx_lock);
+	spin_lock_init(&priv->rxdma_irq_lock);
+
+	netif_carrier_off(ndev);
+	ret = register_netdev(ndev);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to register TSE net device\n");
+		goto err_register_netdev;
+	}
+
+	platform_set_drvdata(pdev, ndev);
+
+	priv->revision = ioread32(&priv->mac_dev->megacore_revision);
+
+	if (netif_msg_probe(priv))
+		dev_info(&pdev->dev, "Altera TSE MAC version %d.%d at 0x%08lx irq %d/%d\n",
+			 (priv->revision >> 8) & 0xff,
+			 priv->revision & 0xff,
+			 (unsigned long) control_port->start, priv->rx_irq,
+			 priv->tx_irq);
+
+	ret = init_phy(ndev);
+	if (ret != 0) {
+		netdev_err(ndev, "Cannot attach to PHY (error: %d)\n", ret);
+		goto err_init_phy;
+	}
+	return 0;
+
+err_init_phy:
+	unregister_netdev(ndev);
+err_register_netdev:
+	netif_napi_del(&priv->napi);
+	altera_tse_mdio_destroy(ndev);
+err_free_netdev:
+	free_netdev(ndev);
+	return ret;
+}
+
+/* Remove Altera TSE MAC device
+ */
+static int altera_tse_remove(struct platform_device *pdev)
+{
+	struct net_device *ndev = platform_get_drvdata(pdev);
+	struct altera_tse_private *priv = netdev_priv(ndev);
+
+	if (ndev->phydev) {
+		phy_disconnect(ndev->phydev);
+
+		if (of_phy_is_fixed_link(priv->device->of_node))
+			of_phy_deregister_fixed_link(priv->device->of_node);
+	}
+
+	platform_set_drvdata(pdev, NULL);
+	altera_tse_mdio_destroy(ndev);
+	unregister_netdev(ndev);
+	free_netdev(ndev);
+
+	return 0;
+}
+
+static const struct altera_dmaops altera_dtype_sgdma = {
+	.altera_dtype = ALTERA_DTYPE_SGDMA,
+	.dmamask = 32,
+	.reset_dma = sgdma_reset,
+	.enable_txirq = sgdma_enable_txirq,
+	.enable_rxirq = sgdma_enable_rxirq,
+	.disable_txirq = sgdma_disable_txirq,
+	.disable_rxirq = sgdma_disable_rxirq,
+	.clear_txirq = sgdma_clear_txirq,
+	.clear_rxirq = sgdma_clear_rxirq,
+	.tx_buffer = sgdma_tx_buffer,
+	.tx_completions = sgdma_tx_completions,
+	.add_rx_desc = sgdma_add_rx_desc,
+	.get_rx_status = sgdma_rx_status,
+	.init_dma = sgdma_initialize,
+	.uninit_dma = sgdma_uninitialize,
+	.start_rxdma = sgdma_start_rxdma,
+};
+
+static const struct altera_dmaops altera_dtype_msgdma = {
+	.altera_dtype = ALTERA_DTYPE_MSGDMA,
+	.dmamask = 64,
+	.reset_dma = msgdma_reset,
+	.enable_txirq = msgdma_enable_txirq,
+	.enable_rxirq = msgdma_enable_rxirq,
+	.disable_txirq = msgdma_disable_txirq,
+	.disable_rxirq = msgdma_disable_rxirq,
+	.clear_txirq = msgdma_clear_txirq,
+	.clear_rxirq = msgdma_clear_rxirq,
+	.tx_buffer = msgdma_tx_buffer,
+	.tx_completions = msgdma_tx_completions,
+	.add_rx_desc = msgdma_add_rx_desc,
+	.get_rx_status = msgdma_rx_status,
+	.init_dma = msgdma_initialize,
+	.uninit_dma = msgdma_uninitialize,
+	.start_rxdma = msgdma_start_rxdma,
+};
+
+static const struct of_device_id altera_tse_ids[] = {
+	{ .compatible = "altr,tse-msgdma-1.0", .data = &altera_dtype_msgdma, },
+	{ .compatible = "altr,tse-1.0", .data = &altera_dtype_sgdma, },
+	{ .compatible = "ALTR,tse-1.0", .data = &altera_dtype_sgdma, },
+	{},
+};
+MODULE_DEVICE_TABLE(of, altera_tse_ids);
+
+static struct platform_driver altera_tse_driver = {
+	.probe		= altera_tse_probe,
+	.remove		= altera_tse_remove,
+	.suspend	= NULL,
+	.resume		= NULL,
+	.driver		= {
+		.name	= ALTERA_TSE_RESOURCE_NAME,
+		.of_match_table = altera_tse_ids,
+	},
+};
+
+module_platform_driver(altera_tse_driver);
+
+MODULE_AUTHOR("Altera Corporation");
+MODULE_DESCRIPTION("Altera Triple Speed Ethernet MAC driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
index caf069a..c602ca8 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
@@ -401,7 +401,7 @@ static void stmmac_get_rx_hwtstamp(struct stmmac_priv *priv, struct dma_desc *p,
 		else
 			ns = priv->hw->desc->get_timestamp(p, priv->adv_ts);
 
-		netdev_info(priv->dev, "get valid RX hw timestamp %llu\n", ns);
+		//netdev_info(priv->dev, "get valid RX hw timestamp %llu\n", ns);
 		shhwtstamp = skb_hwtstamps(skb);
 		memset(shhwtstamp, 0, sizeof(struct skb_shared_hwtstamps));
 		shhwtstamp->hwtstamp = ns_to_ktime(ns);
diff --git a/drivers/net/phy/phy_device.c b/drivers/net/phy/phy_device.c
index c4ceb08..ceb1cf6 100644
--- a/drivers/net/phy/phy_device.c
+++ b/drivers/net/phy/phy_device.c
@@ -14,6 +14,7 @@
 
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 
+#define DEBUG 1
 #include <linux/kernel.h>
 #include <linux/string.h>
 #include <linux/errno.h>
diff --git a/drivers/spi/spi-rt2880.c b/drivers/spi/spi-rt2880.c
new file mode 100644
index 0000000..3c3e471
--- /dev/null
+++ b/drivers/spi/spi-rt2880.c
@@ -0,0 +1,482 @@
+/*
+ * spi-rt2880.c -- Ralink RT288x/RT305x SPI controller driver
+ *
+ * Copyright (C) 2011 Sergiy <piratfm@gmail.com>
+ * Copyright (C) 2011-2013 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * Some parts are based on spi-orion.c:
+ *   Author: Shadi Ammouri <shadi@marvell.com>
+ *   Copyright (C) 2007-2008 Marvell Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/reset.h>
+#include <linux/spi/spi.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+
+#include <ralink_regs.h>
+
+#define SPI_BPW_MASK(bits) BIT((bits) - 1)
+
+#define DRIVER_NAME			"spi-rt2880"
+/* in usec */
+#define RALINK_SPI_WAIT_MAX_LOOP	2000
+
+#define RAMIPS_SPI_STAT(cs)			(0x00 + cs * 0x40)
+#define RAMIPS_SPI_CFG(cs)			(0x10 + cs * 0x40)
+#define RAMIPS_SPI_CTL(cs)			(0x14 + cs * 0x40)
+#define RAMIPS_SPI_DATA(cs)			(0x20 + cs * 0x40)
+#define RAMIPS_SPI_ARBITER          0xf0
+
+/* SPISTAT register bit field */
+#define SPISTAT_BUSY			BIT(0)
+
+/* SPICFG register bit field */
+#define SPICFG_LSBFIRST			0
+#define SPICFG_MSBFIRST			BIT(8)
+#define SPICFG_SPICLKPOL		BIT(6)
+#define SPICFG_RXCLKEDGE_FALLING	BIT(5)
+#define SPICFG_TXCLKEDGE_FALLING	BIT(4)
+#define SPICFG_SPICLK_PRESCALE_MASK	0x7
+#define SPICFG_SPICLK_DIV2		0
+#define SPICFG_SPICLK_DIV4		1
+#define SPICFG_SPICLK_DIV8		2
+#define SPICFG_SPICLK_DIV16		3
+#define SPICFG_SPICLK_DIV32		4
+#define SPICFG_SPICLK_DIV64		5
+#define SPICFG_SPICLK_DIV128		6
+#define SPICFG_SPICLK_DISABLE		7
+
+/* SPICTL register bit field */
+#define SPICTL_HIZSDO			BIT(3)
+#define SPICTL_STARTWR			BIT(2)
+#define SPICTL_STARTRD			BIT(1)
+#define SPICTL_SPIENA			BIT(0)
+
+/* SPIFIFOSTAT register bit field */
+#define SPIFIFOSTAT_TXFULL		BIT(17)
+
+/* SPIARBITER register bit */
+#define SPIARB_EN               BIT(31)
+#define SPIARB_SPI1_POR         BIT(1)
+#define SPIARB_SPI0_POR         BIT(0)
+
+struct rt2880_spi;
+
+struct rt2880_spi_ops {
+    void (*init_hw)(struct rt2880_spi *rs);
+    void (*set_cs)(struct spi_device *spi, int enable);
+    int (*baudrate_set)(struct spi_device *spi, unsigned int speed);
+    unsigned int (*write_read)(struct spi_device *spi, struct list_head *list, struct spi_transfer *xfer);
+};
+
+struct rt2880_spi {
+    struct spi_master	*master;
+    void __iomem		*base;
+    unsigned int		sys_freq;
+    unsigned int		speed;
+    struct clk		*clk;
+    spinlock_t		lock;
+
+    struct rt2880_spi_ops	*ops;
+};
+
+static inline struct rt2880_spi *spidev_to_rt2880_spi(struct spi_device *spi)
+{
+    return spi_master_get_devdata(spi->master);
+}
+
+static inline u32 rt2880_spi_read(struct rt2880_spi *rs, u32 reg)
+{
+    return ioread32(rs->base + reg);
+}
+
+static inline void rt2880_spi_write(struct rt2880_spi *rs, u32 reg, u32 val)
+{
+    iowrite32(val, rs->base + reg);
+}
+
+static inline void rt2880_spi_setbits(struct rt2880_spi *rs, u32 reg, u32 mask)
+{
+    void __iomem *addr = rs->base + reg;
+    unsigned long flags;
+    u32 val;
+
+    spin_lock_irqsave(&rs->lock, flags);
+    val = ioread32(addr);
+    val |= mask;
+    iowrite32(val, addr);
+    spin_unlock_irqrestore(&rs->lock, flags);
+}
+
+static inline void rt2880_spi_clrbits(struct rt2880_spi *rs, u32 reg, u32 mask)
+{
+    void __iomem *addr = rs->base + reg;
+    unsigned long flags;
+    u32 val;
+
+    spin_lock_irqsave(&rs->lock, flags);
+    val = ioread32(addr);
+    val &= ~mask;
+    iowrite32(val, addr);
+    spin_unlock_irqrestore(&rs->lock, flags);
+}
+
+static int rt2880_spi_baudrate_set(struct spi_device *spi, unsigned int speed)
+{
+    struct rt2880_spi *rs = spidev_to_rt2880_spi(spi);
+    int cs = spi->chip_select;
+
+    u32 rate;
+    u32 prescale;
+    u32 reg;
+
+    dev_dbg(&spi->dev, "speed:%u\n", speed);
+
+    /*
+     * the supported rates are: 2, 4, 8, ... 128
+     * round up as we look for equal or less speed
+     */
+    rate = DIV_ROUND_UP(rs->sys_freq, speed);
+    dev_dbg(&spi->dev, "rate-1:%u\n", rate);
+    rate = roundup_pow_of_two(rate);
+    dev_dbg(&spi->dev, "rate-2:%u\n", rate);
+
+    /* check if requested speed is too small */
+    if (rate > 128)
+        return -EINVAL;
+
+    if (rate < 2)
+        rate = 2;
+
+    /* Convert the rate to SPI clock divisor value.	*/
+    prescale = ilog2(rate / 2);
+    dev_dbg(&spi->dev, "prescale:%u\n", prescale);
+
+    reg = rt2880_spi_read(rs, RAMIPS_SPI_CFG(cs));
+    reg = ((reg & ~SPICFG_SPICLK_PRESCALE_MASK) | prescale);
+    rt2880_spi_write(rs, RAMIPS_SPI_CFG(cs), reg);
+    rs->speed = speed;
+    return 0;
+}
+
+/*
+ * called only when no transfer is active on the bus
+ */
+static int
+rt2880_spi_setup_transfer(struct spi_device *spi, struct spi_transfer *t)
+{
+    struct rt2880_spi *rs = spidev_to_rt2880_spi(spi);
+    unsigned int speed = spi->max_speed_hz;
+    int rc;
+
+    if ((t != NULL) && t->speed_hz)
+        speed = t->speed_hz;
+
+    if (rs->speed != speed) {
+        dev_dbg(&spi->dev, "speed_hz:%u\n", speed);
+        rc = rs->ops->baudrate_set(spi, speed);
+        if (rc)
+            return rc;
+    }
+
+    return 0;
+}
+
+static void rt2880_spi_set_cs(struct spi_device *spi, int enable)
+{
+    struct rt2880_spi *rs = spidev_to_rt2880_spi(spi);
+    int cs = spi->chip_select;
+    if (enable)
+        rt2880_spi_clrbits(rs, RAMIPS_SPI_CTL(cs), SPICTL_SPIENA);
+    else
+        rt2880_spi_setbits(rs, RAMIPS_SPI_CTL(cs), SPICTL_SPIENA);
+}
+
+static inline int rt2880_spi_wait_till_ready(struct spi_device *spi)
+{
+    struct rt2880_spi *rs = spidev_to_rt2880_spi(spi);
+    int cs = spi->chip_select;
+    int i;
+
+    for (i = 0; i < RALINK_SPI_WAIT_MAX_LOOP; i++) {
+        u32 status;
+
+        status = rt2880_spi_read(rs, RAMIPS_SPI_STAT(cs));
+        if ((status & SPISTAT_BUSY) == 0)
+            return 0;
+
+        cpu_relax();
+        udelay(1);
+    }
+
+    return -ETIMEDOUT;
+}
+
+static unsigned int
+rt2880_spi_write_read(struct spi_device *spi, struct list_head *list, struct spi_transfer *xfer)
+{
+    struct rt2880_spi *rs = spidev_to_rt2880_spi(spi);
+    int cs = spi->chip_select;
+
+    unsigned count = 0;
+    u8 *rx = xfer->rx_buf;
+    const u8 *tx = xfer->tx_buf;
+    int err;
+
+    dev_dbg(&spi->dev, "read (%d): %s %s\n", xfer->len,
+          (tx != NULL) ? "tx" : "  ",
+          (rx != NULL) ? "rx" : "  ");
+
+    if (tx) {
+        for (count = 0; count < xfer->len; count++) {
+            rt2880_spi_write(rs, RAMIPS_SPI_DATA(cs), tx[count]);
+            rt2880_spi_setbits(rs, RAMIPS_SPI_CTL(cs), SPICTL_STARTWR);
+            err = rt2880_spi_wait_till_ready(spi);
+            if (err) {
+                dev_err(&spi->dev, "TX failed, err=%d\n", err);
+                goto out;
+            }
+        }
+    }
+
+    if (rx) {
+        for (count = 0; count < xfer->len; count++) {
+            rt2880_spi_setbits(rs, RAMIPS_SPI_CTL(cs), SPICTL_STARTRD);
+            err = rt2880_spi_wait_till_ready(spi);
+            if (err) {
+                dev_err(&spi->dev, "RX failed, err=%d\n", err);
+                goto out;
+            }
+            rx[count] = (u8) rt2880_spi_read(rs, RAMIPS_SPI_DATA(cs));
+        }
+    }
+
+out:
+    return count;
+}
+
+static int rt2880_spi_transfer_one_message(struct spi_master *master,
+                       struct spi_message *m)
+{
+    struct rt2880_spi *rs = spi_master_get_devdata(master);
+    struct spi_device *spi = m->spi;
+    struct spi_transfer *t = NULL;
+    int par_override = 0;
+    int status = 0;
+    int cs_active = 0;
+
+    /* Load defaults */
+    status = rt2880_spi_setup_transfer(spi, NULL);
+    if (status < 0)
+        goto msg_done;
+
+    list_for_each_entry(t, &m->transfers, transfer_list) {
+        if (t->tx_buf == NULL && t->rx_buf == NULL && t->len) {
+            dev_err(&spi->dev,
+                "message rejected: invalid transfer data buffers\n");
+            status = -EIO;
+            goto msg_done;
+        }
+
+        if (t->speed_hz && t->speed_hz < (rs->sys_freq / 128)) {
+            dev_err(&spi->dev,
+                "message rejected: device min speed (%d Hz) exceeds required transfer speed (%d Hz)\n",
+                (rs->sys_freq / 128), t->speed_hz);
+            status = -EIO;
+            goto msg_done;
+        }
+
+        if (par_override || t->speed_hz || t->bits_per_word) {
+            par_override = 1;
+            status = rt2880_spi_setup_transfer(spi, t);
+            if (status < 0)
+                goto msg_done;
+            if (!t->speed_hz && !t->bits_per_word)
+                par_override = 0;
+        }
+
+        if (!cs_active) {
+            rs->ops->set_cs(spi, 1);
+            cs_active = 1;
+        }
+
+        if (t->len)
+            m->actual_length += rs->ops->write_read(spi, &m->transfers, t);
+
+        if (t->delay_usecs)
+            udelay(t->delay_usecs);
+
+        if (t->cs_change) {
+            rs->ops->set_cs(spi, 0);
+            cs_active = 0;
+        }
+    }
+
+msg_done:
+    if (cs_active)
+        rs->ops->set_cs(spi, 0);
+
+    m->status = status;
+    spi_finalize_current_message(master);
+
+    return 0;
+}
+
+static int rt2880_spi_setup(struct spi_device *spi)
+{
+    struct rt2880_spi *rs = spidev_to_rt2880_spi(spi);
+
+    if ((spi->max_speed_hz == 0) ||
+        (spi->max_speed_hz > (rs->sys_freq / 2)))
+        spi->max_speed_hz = (rs->sys_freq / 2);
+
+    if (spi->max_speed_hz < (rs->sys_freq / 128)) {
+        spi->max_speed_hz = rs->sys_freq / 128;
+        //dev_err(&spi->dev, "setup: requested speed is too low %d Hz\n",
+        //    spi->max_speed_hz);
+        //return -EINVAL;
+    }
+
+    /*
+     * baudrate & width will be set rt2880_spi_setup_transfer
+     */
+    return 0;
+}
+
+static void rt2880_spi_reset(struct rt2880_spi *rs)
+{
+    rt2880_spi_write(rs, RAMIPS_SPI_ARBITER, SPIARB_EN);
+
+    rt2880_spi_write(rs, RAMIPS_SPI_CFG(0),
+             SPICFG_MSBFIRST | SPICFG_TXCLKEDGE_FALLING |
+             SPICFG_SPICLK_DIV16 | SPICFG_SPICLKPOL);
+    rt2880_spi_write(rs, RAMIPS_SPI_CTL(0), SPICTL_HIZSDO | SPICTL_SPIENA);
+
+    rt2880_spi_write(rs, RAMIPS_SPI_CFG(1),
+             SPICFG_MSBFIRST | SPICFG_TXCLKEDGE_FALLING |
+             SPICFG_SPICLK_DIV16 | SPICFG_SPICLKPOL);
+    rt2880_spi_write(rs, RAMIPS_SPI_CTL(1), SPICTL_HIZSDO | SPICTL_SPIENA);
+}
+
+static struct rt2880_spi_ops spi_ops[] = {
+    {
+        .init_hw = rt2880_spi_reset,
+        .set_cs = rt2880_spi_set_cs,
+        .baudrate_set = rt2880_spi_baudrate_set,
+        .write_read = rt2880_spi_write_read,
+    },
+};
+
+static const struct of_device_id rt2880_spi_match[] = {
+    { .compatible = "ralink,rt2880-spi", .data = &spi_ops[0]},
+    {},
+};
+MODULE_DEVICE_TABLE(of, rt2880_spi_match);
+
+static int rt2880_spi_probe(struct platform_device *pdev)
+{
+        const struct of_device_id *match;
+    struct spi_master *master;
+    struct rt2880_spi *rs;
+    unsigned long flags;
+    void __iomem *base;
+    struct resource *r;
+    int status = 0;
+    struct clk *clk;
+
+        match = of_match_device(rt2880_spi_match, &pdev->dev);
+    if (!match)
+        return -EINVAL;
+
+    r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+    base = devm_ioremap_resource(&pdev->dev, r);
+    if (IS_ERR(base))
+        return PTR_ERR(base);
+
+    clk = devm_clk_get(&pdev->dev, NULL);
+    if (IS_ERR(clk)) {
+        dev_err(&pdev->dev, "unable to get SYS clock, err=%d\n",
+            status);
+        return PTR_ERR(clk);
+    }
+
+    status = clk_prepare_enable(clk);
+    if (status)
+        return status;
+
+    master = spi_alloc_master(&pdev->dev, sizeof(*rs));
+    if (master == NULL) {
+        dev_dbg(&pdev->dev, "master allocation failed\n");
+        return -ENOMEM;
+    }
+
+    /* we support only mode 0, and no options */
+    master->mode_bits = SPI_CS_HIGH;
+
+    master->setup = rt2880_spi_setup;
+    master->transfer_one_message = rt2880_spi_transfer_one_message;
+    master->num_chipselect = 2;
+    master->bits_per_word_mask = SPI_BPW_MASK(8);
+    master->dev.of_node = pdev->dev.of_node;
+
+    dev_set_drvdata(&pdev->dev, master);
+
+    rs = spi_master_get_devdata(master);
+    rs->base = base;
+    rs->clk = clk;
+    rs->master = master;
+    rs->sys_freq = clk_get_rate(rs->clk);
+    rs->ops = (struct rt2880_spi_ops *) match->data;
+    dev_dbg(&pdev->dev, "sys_freq: %u\n", rs->sys_freq);
+    spin_lock_irqsave(&rs->lock, flags);
+
+    device_reset(&pdev->dev);
+
+    rs->ops->init_hw(rs);
+
+    return spi_register_master(master);
+}
+
+static int rt2880_spi_remove(struct platform_device *pdev)
+{
+    struct spi_master *master;
+    struct rt2880_spi *rs;
+
+    master = dev_get_drvdata(&pdev->dev);
+    rs = spi_master_get_devdata(master);
+
+    clk_disable(rs->clk);
+    spi_unregister_master(master);
+
+    return 0;
+}
+
+MODULE_ALIAS("platform:" DRIVER_NAME);
+
+static struct platform_driver rt2880_spi_driver = {
+    .driver = {
+        .name = DRIVER_NAME,
+        .owner = THIS_MODULE,
+        .of_match_table = rt2880_spi_match,
+    },
+    .probe = rt2880_spi_probe,
+    .remove = rt2880_spi_remove,
+};
+
+module_platform_driver(rt2880_spi_driver);
+
+MODULE_DESCRIPTION("Ralink SPI driver");
+MODULE_AUTHOR("Sergiy <piratfm@gmail.com>");
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_LICENSE("GPL");
diff --git a/include/dt-bindings/clock/clk-si5338.h b/include/dt-bindings/clock/clk-si5338.h
new file mode 100644
index 0000000..545c80d
--- /dev/null
+++ b/include/dt-bindings/clock/clk-si5338.h
@@ -0,0 +1,68 @@
+/*
+ * This header provides constants for SI5338 I2C clock generator
+ *
+ * The constants defined in this header are used in dts files
+ *
+ * Copyright 2015 Freescale Semiconductor
+ *
+ * York Sun <yorksun@freescale.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _DT_BINDINGS_CLK_SI5338_H
+#define _DT_BINDINGS_CLK_SI5338_H
+
+/* Used to identify input clock */
+#define SI5338_INPUT_CLK12		0
+#define SI5338_INPUT_CLK3		1
+#define SI5338_INPUT_CLK4		2
+#define SI5338_INPUT_CLK56		3
+
+/* Used to identify the mux source */
+#define SI5338_REF_SRC_CLKIN12		0
+#define SI5338_REF_SRC_CLKIN3		1
+#define SI5338_FB_SRC_CLKIN4		2
+#define SI5338_FB_SRC_CLKIN56		3
+#define SI5338_REF_SRC_XTAL		4
+#define SI5338_FB_SRC_NOCLK		5
+
+/* Used to identify the pfd_in_ref mux source */
+#define SI5338_PFD_IN_REF_REFCLK	0
+#define SI5338_PFD_IN_REF_FBCLK		1
+#define SI5338_PFD_IN_REF_DIVREFCLK	2
+#define SI5338_PFD_IN_REF_DIVFBCLK	3
+#define SI5338_PFD_IN_REF_XOCLK		4
+#define SI5338_PFD_IN_REF_NOCLK		5
+
+/* Used to identify the pfd_in_fb mux source */
+#define SI5338_PFD_IN_FB_FBCLK		0
+#define SI5338_PFD_IN_FB_REFCLK		1
+#define SI5338_PFD_IN_FB_DIVFBCLK	2
+#define SI5338_PFD_IN_FB_DIVREFCLK	3
+#define SI5338_PFD_IN_FB_RESERVED	4
+#define SI5338_PFD_IN_FB_NOCLK		5
+
+/* Used to identify the mux source */
+#define SI5338_OUT_MUX_FBCLK		0
+#define SI5338_OUT_MUX_REFCLK		1
+#define SI5338_OUT_MUX_DIVFBCLK		2
+#define SI5338_OUT_MUX_DIVREFCLK	3
+#define SI5338_OUT_MUX_XOCLK		4
+#define SI5338_OUT_MUX_MS0		5
+#define SI5338_OUT_MUX_MSN		6	/* MS0/1/2/3 respectivelly */
+#define SI5338_OUT_MUX_NOCLK		7
+
+#define SI5338_OUT_DIS_HIZ		0
+#define SI5338_OUT_DIS_LOW		1
+#define SI5338_OUT_DIS_HI		2
+#define SI5338_OUT_DIS_ALWAYS_ON	3
+
+#endif /* _DT_BINDINGS_CLK_SI5338_H */
